<?xml version="1.0" encoding="utf-8"?>
<set xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
	xml:id="index" xml:lang="en">
	<title>Uniface Manual</title>
	<info xmlns="http://docbook.org/ns/docbook" xml:id="bookinfo">
		<authorgroup xmlns="http://docbook.org/ns/docbook" xml:id="authors">
			<author>
				<personname>
					<firstname>Dennis</firstname>
					<surname>Vorst</surname>
				</personname>
			</author>
		</authorgroup>
		<pubdate>
			<?dbtimestamp format="Y-m-d"?>
		</pubdate>
		<copyright>
			<year>2012-<?dbtimestamp format="Y"?>
			</year>
			<holder>Vorst Informatisering</holder>
		</copyright>
		<legalnotice xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="copyright">
			<title>Copyright</title>
			<simpara> Copyright © 2012 - <?dbtimestamp format="Y"?> by Vorst Informatisering. This
				material may be distributed only subject to the terms and conditions set forth in
				the Creative Commons Attribution 3.0 License or later. A copy of the Creative
				Commons Attribution 3.0 license is distributed with this manual. The latest version
				is presently available at <link
					xlink:href="http://creativecommons.org/licenses/by/3.0/"
					>http://creativecommons.org/licenses/by/3.0/</link>. </simpara>
			<simpara> If you are interested in redistribution or republishing of this document in
				whole or in part, either modified or unmodified, and you have questions, please
				contact the Copyright holders at <link
					xlink:href="mailto:info@materialictsolutions.nl"
					>info@vorst-informatisering.nl</link>. Note that this address is mapped to a
				publicly archived mailing list. </simpara>
		</legalnotice>
	</info>
	<book xml:id="best_practices">
		<title>Best Practices</title>
		<chapter xml:id="best_practices.general">
			<title>General</title>
			<sect1>
				<title>Labels and messages</title>
				<para> In order to keep the number of labels and messages as small as possible you
					should try to reuse the labels and messages. </para>
				<para> First check if the labeltext you need already exists in the library. If it
					does use that message. </para>
				<para> If it doesnot exist create a new one, keeping in mind the <link
						linkend="standards.naming.general">naming conventions for labels</link>.
				</para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.uniface">
			<title>Uniface unless...</title>
			<para> In the fast changing world of ICT there are a few things that have remained
				constant over time. One of these principles is that you should always use one
				database management tool on your database. multiple DBMS'es have different behaviour
				and may therefore alter your data without you knowing it. and if they do the outcome
				may not be traceable. </para>
			<para> In my career i was once stationed at a large leasing company. This company leased
				motorvehicles to their customers. The leasing business is very competitive. You must
				be able to quote a very sharp rpize without loosing money. This can be done to
				calculate a prize per kilometer for maintanence, tires etc. These companies do this
				by calculating the prize per kilometer in cents. with 5 decimal places. </para>
			<para> At one point during a conversion from one DBMS to another we found out that the
				behaviour of the new system was not to round the 6th decimal place (the one just out
				of focus) and just cutting it. Dropping 0.000005 cents. This doesnot seem like a lot
				of money. But if you think that a leasecar generally drives 40.000 kilometers per
				year and a contract is generally 3 to 4 years means that the company was losing 20
				cents per car a year. Still not a lot. But if you take in consideration that they
				services more than a 100,000 cars per year it turns out to be a lot of money. </para>
			<para> So you need to make sure that there is only one DBMS active on your system. So
				the basic rule for development in a Uniface system should be that all components
				should be built using uniface. If you wish to divert from this rule there has to be
				a strong motivation to do so. But in general the rule should be to built it in
				Uniface. Unless... there is as shortcoming in Uniface that another product is better
				suited for. </para>
		</chapter>
		<chapter xml:id="best_practices.entities">
			<title>Entities</title>
			<sect1>
				<title>General</title>
				<para> When creating model entities there are a few rules you should consider: The
					field U_VERSION should be defined </para>
				<para> The locking type for the new table shoule be optimistic locking </para>
				<para> The order of the fields should be PRIMARY KEY, U_VERSION, FOREIGN KEY, USER
					FIELDS, TECHNICAL FIELDS </para>
			</sect1>
			<sect1>
				<title>Fields</title>
				<para> In an entity in a model entity is mandatory you should try to enter a default
					value as well. </para>
				<para> Always use syntax, interface and display templates </para>
				<para> How to decode the entry for an application in a multilingual environment.
					F.i. Y means yes(en), ja(D), ja(GE), Oui (Fr) No means No(en), Nee(D), Nein(GE),
					non(Fr) </para>
			</sect1>
			<sect1>
				<title>Keys</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Relationships</title>
				<para> Primary key fields and related foreign key fields: - have the samename - have
					the same datatype </para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.three_tier">
			<title>Three tier versus two-tier applications</title>
			<para> Do you really need a three tier application artist that just some fashionable
				statement that everybody thinks is cool to have. That depends. Does your application
				a client/server application or does it consist of an application with a web
				environment? In the former you do not really need a three-tier application set up.
				You only need a three-tier application in cases where you want to separate the
				business logic from presentation logic. For instance web applications or
				applications that require different technology to represent presentation layer. </para>
			<para> in the classic client/server applications you do not require a business logic and
				presentation logic separation. You can suffice by using the good old client/server
				methodology. This means creating components that write directly to the database. </para>
			<para> in this case we will assume that you are using Uniface as a product. This means
				that the classic three-tier application will not work because the deer and
				application consists of the database protocol or data layer. This layer is handled
				by the Uniface internal operations. Therefore we can only speak of to two tier or
				one tier applications. So in this example we will be talking about separation of
				business logic and presentation logic or combining the two in one element. </para>
		</chapter>
		<chapter xml:id="best_practices.lists">
			<title>selecting your values</title>
			<para> most of the legacy Uniface application that I've seen in years that I've been
				developing Uniface as a career, I have come across applications where every entity
				that needed a component for selection that component was created manually. This is
				pretty laborous work and takes a lot of time create.not the standalone selection
				screen but if you take them all into account – a lot of time spent building all
				these components. And basically there is no need for creating so many selection
				screens. </para>
			<para> In my time I have discovered that there are basically three ways of selecting
				values. Values are generally selected from a list or a list within a list. A list
				can be presented in three different ways: </para>
			<para> The first list is a selection of approximately 5 to 15 values. These values are
				pretty obvious to the user and can be overview without using very high tech
				technology or editing searching scanning the application. Generally the user can
				find his value very easy when it is a list of less than say 10 items. </para>
			<para> the second list consists of a list off more than 10 and less than 50 items. This
				case it might be helpful for the user to add a set of buttons at his disposal for
				sorting the selected values. Food these buttons he will be able to find is value
				without spending too much time scanning a lis </para>
			<para> The first list is a list of more than 50 items. This list may be presented to a
				user with the possibility for entering parts of the desired value but at the screen
				will display a subset of the value that matches the search criteria. </para>
			<para> The first list can be presented to a user using a drop-down list or maybe a radio
				group or some other small set of items. The other two lists may be presented to the
				user using a different screen, or a pop-up screen. When the first screen that the
				user is presented there are only buttons to sort and order the list in the second as
				fields where subsequent values can be entered. </para>
			<para> example </para>
			<para> The screen is displayed above this text is a template that has been defined in
				Uniface. This is the only selection screen that is available in the application.
				Values for this screen are put together in a service and then tossed on a list to
				the selection screen. After double-clicking or selecting evaluating the screen to
				select the value is returned to the calling service and calling service will relay
				the selected value towards the component where the value needs to be selected. This
				way you only have to define one selection screen for your entire application and you
				need only to maintain this screen in your entire application. </para>
			<para> Of course there is one exception to the rule! Because there are always a few
				entities in an application that require their own selection screens that access to
				database directly just because the data set that is retrieved and passed on is too
				large for either the list or it is too large to guarantee a good performance to the
				user. Only in those cases should you define a and the specific selection screen any
				other circumstance you would be better off defining one selection screen for the
				entire application. if you follow this link you can download and export file where
				the above shown example can be downloaded. </para>
		</chapter>
		<chapter xml:id="best_practices.generation">
			<title>Generating your application</title>
			<para> this next chapter does not really work very well for existing legacy systems but
				nevertheless we thought that it is very useful information for you to know.80% of
				all applications that are built around the world are pretty much straightforward
				looking screens with logic for creating reading updating and deleting records from a
				database.why are developers working so hard manually to get these components built?
				Would it not be better to generate these elements in your code? </para>
			<para> If you wish to generate 80% of the application that are a couple of steps you
				need to do: </para>
			<para> first of all you need to decide if you are creating a single tier or
				client/server application, or a multitier or Web-enabled or otherwise enabled
				application.if you are working on a single-chip client/server application you do not
				need to generate a service layer.if however you are working on an application that
				is either Web-enabled or has several types of presentation to customers, for
				instance it has a web interface, you can access it to your mobile phone, and it has
				a client/server extension, then you might want to consider splitting the business
				logic from the presentation logic. </para>
			<para> second you need to think about the way you want to present your data on your
				screen.the way information is displayed on the screen and the way parent child
				relationships between entities are related to the user determine effectiveness of
				the application.so in order to create an effective application you need to decide
				how the general way of presenting information looks like. </para>
		</chapter>
		<chapter xml:id="best_practices.crud">
			<title>CRUD Matrix</title>
			<para> There are basically three types of entities: </para>
			<para> - There are parent entities These are entities that do not have a relationship or
				are always the parent in every relationship they have. They are the outer most
				entities like customers or companies or are entities that contains lists of values. </para>
			<para> - There are child entities These are entities that are always the many or child
				node in a relationship. In most cases these are modelled many to many relationships. </para>
			<para> - And there are entities that are both parent and child These are entities that
				have at least 2 relationships with other entities where they are the child node in
				one and the parent node in the other. These entities usually are a diversification
				of its grandparent. </para>
		</chapter>
		<chapter>
			<title>Deleting or updating values </title>
			<para> Depending on the update and delete constraints Uniface needs to know who the
				related child entities are in the application. This can be done in one of three
				ways: </para>
			<para> - Paint all the related child nodes, and their respective child nodes in the
				parent This will result In a very dense formpaint including all the inner entitites
				within the parent. </para>
			<para> - Paint only the one entity and create a coded reference to the child entities.
				This requires a lot of coding and will be subject to human error. </para>
			<para> - Generate services that contain the parent and its first in line children Parent
				entities are responsible for their children. This is true in the real world. You
				teach your children so they can teach their kids. Grandparents babysit but are not
				responsible for their grandkids’ behaviour. Their parents are. So in this case you
				paint the parent and within it its children. Deleting the parent will result in
				triggering the delete from the kids, activating their delete services. </para>
		</chapter>
		<chapter xml:id="best_practices.components">
			<title>Components</title>
			<sect1>
				<title>Compiling</title>
				<para> When compiling a component you should make sure that: the component compiles
					error free and the warning ‘field assumed length of 40’ of ‘non referenced
					fields’ is not visible in the message log </para>
			</sect1>
			<sect1>
				<title>Painting entities</title>
				<para> Entities that are related to each other in the application model can be
					painted as frames-within-frames. </para>
				<para> Entities that are not related to each other in the application model should
					be painted on the component as individual mnost-outer entities. If you need them
					to been painted within each other you should create a relationship or define a
					view acroos both tables and have this table be related to the outer entity.
				</para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.writing_code">
			<title>Writing Code</title>
			<para>Writing code in any programming language is not that difficult. You just need to know
				syntax, commands and the lot and you are good to go. But that is only half the work.
				You need to create sound structured readable code. There are not many books written
				about cretaing good readable code. In this chapter we will try to provide some
				pointers on how to create good readable code.</para>
			<sect1>
				<title>Use Paragraphs</title>
				<para>When writing a story you use certain rules. Each chapter, or paragraph talks about 
					a different subject of the story. You can apply these rules the same way in software code.</para>
				<para>For instance if you put the lines together without any blank lines in between this doesnot make 
					for very readable code. Take for instance the following eaxmple:</para>
				<programlisting role="uniface"><![CDATA[
	entry GET_RECORDS
	params
	string p_param1 : in
	string p_param2 : in
	string p_param3 : out	
	endparams
	variables 
	string v_var1
	endvariables 
	v_var1 = "creating some kind of string"
	if (v_var1 = "some value")
	clear/e "ENTITY"
	FIELD1.ENTITY = p_param1
	FIELD2.ENTITY = p_param2
	retrieve/e "ENTITY"
    endif
    if ($status &gt; 0)
    p_param3 = FIELD3.ENTITY
    endif 
    return(0)
    end ; GET_RECORDS
	]]></programlisting>
				<para>In this function we can see a story developing. Some parameters are parsed in the function. 
					These vaslues are used to retrieve a record from an entity. If the status indicates it has found occurences we 
				transfer a value to an out parameter. It will probably take you a little more time to decipher the code than the 
				same aexample that we paragraphed.</para>
				<programlisting role="uniface"><![CDATA[
	entry GET_RECORDS
	params
	string p_param1 : in
	string p_param2 : in
	string p_param3 : out	
	endparams
	variables 
	string v_var1
	endvariables 

v_var1 = "creating some kind of string"

if (v_var1 = "some value")
	clear/e "ENTITY"
	FIELD1.ENTITY = p_param1
	FIELD2.ENTITY = p_param2
	retrieve/e "ENTITY"
	
	if ($status &gt; 0)
	return(-1)
	endif

endif

if (FIELD3.ENTITY &gt; v_var1)
    p_param3 = FIELD3.ENTITY
    endif 

return(0)

end ; GET_RECORDS
	]]></programlisting>
				<para>In the last example we inserted blank lines where we start with a different subject. 
					We placed the params and variables section side by side. Then we inserted a blank line and 
				did some initialisation. Then another blank line followed by a condiontial set of code. As you 
				see we did some spacing between the retrieve and the conditional status handling. After the endif a 
				blank line followed by the last conditional code. Finally a blank line and the return(0). 
				Our chapter GET_RECORDS is done and it was fun to read.</para>
			</sect1>

			<sect1>
				
				<title>Comments</title>
				<para> Comments in code are important to clarify what happens in a trigger or function.
					Comments should be put on a different line, preferrably the line, preceeding the
					line it regards to. 
					<programlisting role="uniface"><![CDATA[
	entry CE_COMMENT
	; here we will descibe what the function does
	
	params 
	numeric p_foo : in
	numeric p_bar : in
	endparams 
	
	; this is the right type of comment
	clear/e "FOO"
	retrieve/e "FOO"
	
	if (p_foo = p_bar) ; this is wrong 
	...
	endif
	
	if (p_foo > p_bar) 
	; here i will explain what happens when p_foo is larger than p_bar
	...
	
	else 
	; here i will explain what happens if p_foo is not larger than p_bar
	...
	endif
	
	return(0)
	end ; CE_COMMENT
	]]></programlisting>
				</para>
				<para> Comments should also be used to clarify complex processes in a function. It is
					wrong to assume that the developer that has to alter your code will understand your
					train of thought. Try to explain it to him in a functional way rather than a
					technical one. <programlisting role="uniface"><![CDATA[
	entry CE_COMPLEX
	; here we will comment some complex stuff 
	params 
	numeric p_foo : in
	numeric p_bar : in
	numeric p_foobar : in
	endparams 
	
	; When doing some complex stuff it is best to do some functional 
	; commenting 
	; 
	if ((p_foo * p_bar = p_foobar) %\
	| (p_foo / p_foobar = p_foobar * p_bar) %\
	| (p_foobar * p_foobar = (p_bar * p_bar) + (p_foo) * (p_foo))
	)
	...
	endif 
	return(0)
	end ; CE_WRONG
	]]></programlisting>
				</para>
				<para> Comments that contain code fragments should be removed from the component or
					function. <programlisting role="uniface"><![CDATA[
	; commented code fragments should be removed!!
	;entry CE_COMMENTED
	; here we will comment some complex stuff 
	;params 
	;numeric p_foo : in
	;numeric p_bar : in
	;numeric p_foobar : in
	;endparams 
	;return(0)
	;end ; CE_COMMENTED
	]]></programlisting>
				</para>
			</sect1>
		</chapter>
		
		<chapter xml:id="best_practices.containers">
			<info>
				<title>Containers for specific values</title>
			</info>
			<para> Variables and or parameters that are linked to a certain fieldname or entity name
				should have the same name as that field. For instance if an application has a field
				POLICYNR in the entity POLICY, the variable or parameter should be v_policynr and
				p_policynr. All other variable or parameter names should be disallowed. This way it
				is possible to track the whereabouts of a policynr. </para>
			<para> Variables that are used to contain a certain value should not be abused for other
				values. The variable v_policynr should not be used to contain the value of
				customer_id. It is better to create another variable v_customer_id. In the past it
				was considered to be good practice to reuse as much as possible of the available
				memory. With the systems of today memory is available in abundance and it should not
				matter whether you claim a bit mor memory doing this. </para>
			<para> For dummy fields this costraint also applies. If there is a dummy entity named
				Dummy and it should have a policynr than the field should be namend D_POLICYNR.
			</para>
		</chapter>
		<chapter xml:id="best_practices.global_variables">
			<info>
				<title>Global Variables</title>
			</info>
			<sect1>
				<title>generic versus specific</title>
				<para> Although the use of global variables is wrong and shoul be disouraged there
					are levels of wrongness in the way you use global variables. </para>
				<para> There are two kinds the generic ones and the specific ons. A generic varibale
					is a variable with a non-specific name like $51, $$P2 and so on. It is not clear
					what the variable is used for. </para>
				<para> Then there are the specific global variables like $$person of $$company. Even
					better would be to use $$idperson and $$idcompany. In the former there might be
					severel peaces of data put in the varaibel where the latter only containts the
					number or code that identifies that person. </para>
				<para> The use of generic global varibales is dead-wrong. You may start with this
					code <programlisting role="uniface"><![CDATA[
entry CE_GET_PERSON

; retrieve the person records
clear/e "PERSON"                
IDPERSON.PERSON/init = $51
retrieve/e "PERSON"

...

putlistitems/occ "PERSON", $51

return (0)

end ; CE_GET_PERSON
]]></programlisting> This will work. But what happens when another developer edits the code and adds
					the following <programlisting role="uniface"><![CDATA[
entry CE_GET_PERSON

; retrieve the person records

clear/e "PERSON"
IDPERSON.PERSON/init = $51
retrieve/e "PERSON"

...

putlistitems/occ "PERSON", $51

; do something weird using the $51 variable

$51 = "FOOBAR"

return (0)

end ; CE_GET_PERSON]]></programlisting>
				</para>
				<para> Now the entry will return something unexpected. Debugging this error in this
					case is fairly easy. But what happens if the developer enters a call to another
					entry that calls several entries to get the person information. Are you sure the
					$51 variable will not be altered somewhere in the process. No you donot. And if
					you do, over time, other developers will alter the code and add or remove
					elements. One of them is bound to use the $51 variable and mess your code up.
				</para>
			</sect1>
			<sect1>
				<title>Specific Global Variables</title>
				<para> So it is better to use specific variables? Well it is better than using the
					generic ones. But the danger still exitst that somewhere in you code the
					variable will be overwritten, with another person id. So the best case is to use
					parameters to pass values to and from functions. </para>
				<para> If you have functons that are widely used throughout the application and you
					are building on legacy code (yes you are) you cannot add parameters without
					having to alter all the calls to this function in you application. In that case
					you can simulate parameters by using variables and passing the value from the
					global variable to a local or component variable. It is not a pretty solution
					but better than using the global variables. </para>
				<para>
					<programlisting role="uniface"><![CDATA[
; extract from the EXECUTE TRIGGER
clear/e "PERSON"
IDPERSON.PERSON/init = $$idperson
retrieve/e "PERSON"
]]></programlisting>
				</para>
				<para> should be altered in either: </para>
				<para>
					<programlisting role="uniface"><![CDATA[
; extract from the EXECUTE TRIGGER
; first parse the value to a component variable
$idperson$ = $$idperson

; then retreive the person
clear/e "PERSON"
IDPERSON.PERSON/init = $idperson$
retrieve/e "PERSON"
]]></programlisting>
				</para>
				<para> In an entry this would be: <programlisting><![CDATA[
entry ee_get_person
variables
numeric v_idperson
endvariables

; first parse the value to a component variable
v_idperson = $$idperson

; then retrieve the person
clear/e "PERSON"
IDPERSON.PERSON/init = v_idperson                        
retrieve/e "PERSON"

...

;return the value
$$idperson = v_idperson
return(0)                        
end ; ee_get_person
]]></programlisting> Notice that we reverse the variable in the end to give $$idperson the correct
					value, before returning to the parent function. In a component you can do this
					last bit in the accept and/or quit trigger. </para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.dry">
			<info>
				<title>Donot Repeat Yourself</title>
			</info>
			<para> Never, ever, and we mean never, ever copy and paste code. If you are [CTRL] + [C]
				and [CTRL] + [V]íng your code you are not realy developing. Are you? </para>
			<para> If you feel the need to copy, than you should remove the code from the original
				place and put it in a higher, more abstract level in Uniface. Being it an Include
				Proc or a Conceptual Entity Proc. </para>
		</chapter>
		<chapter xml:id="best_practices.code_location">
			<info>
				<title>How to determine the right place to code</title>
			</info>
			<para> When you start using Uniface you first have to start shedding some of the lineair
				programming skills you might have and start adopting some of the Object Oriented
				principles. Uniface can be more effectively utilized when it is used as an OO
				language. However it can be used as a lineair progamming language. </para>
			<para> When Uniface is used as a lineair language most of the code is defined at the
				component level. This results in components with a high level of duplicate code. </para>
			<para> So how are you going to use Uniface as an Object Oriented programming language?
				That's real easy! You just have to get the code to the right level in the
				application. </para>
			<para> In order to code at the right location of the application you need to follow a
				few basic rules. </para>
			<para xmlns="http://docbook.org/ns/docbook">Please consider the following component: <example>
					<title>Some title</title>
					<mediaobject>
						<alt>Output of example : Simple example</alt>
						<imageobject>
							<imagedata align="center" format="PNG" fileref="images/c_uform.png"/>
						</imageobject>
					</mediaobject>
				</example></para>
			<para> On this component are drawn two entities. One is the UFORM entioty from the DICT
				application model and one is a DUMMY entity with a button on it. Pressing the button
				will result in the activation of two entries. One will retrieve the UFORM records
				and the second will display a message that the records have been retrieved. </para>
			<para>
				<programlisting role="uniface"><![CDATA[
entry CE_GET_UFORM
; retrieve all the uform records 
clear/e "UFORM"
retrieve/e "UFORM"

return(0)
end ; CE_GET_UFORM

entry CE_DISP_MESSAGE
; display a mmessage that retrieval was succesful
message "UFORM was succesfully retrieved!"

return(0)
end ; CE_DISP_MESSAGE
]]></programlisting>
			</para>
			<para> As long as this is the only component in the application that uses the UFORM
				entity it is oke the have this code set at the component level. But what happens
				when we need to create another component where we need to retrieve the entity UFORM
				and display a message? </para>
			<para> The first thought that might cross your mind is to copy the component and reuse
				it. That would be wrong. Wrong is such a strong word let me rephrase that. That is
				using a lineair or 3GL approach to 4GL. That's like driving a Ferrarri and then
				obiding by the speed limit. A little awkward. But in the 10+ years i have been
				working as a Uniface decveloper i have come across this behaviour more than I care
				to admit. </para>
			<para> The right thing to do is lift both entries to a higher level and then reuse them
				in both components. But where do you put them? If we look at both entries there you
				may notice that one of them has a reference to an entity (UFORM) and the other
				doesnot. The one that has no reference to entities should be defined in a library as
				a Global or Include proc so that it can be reused. The other should be moved to the
				local procs trigger of the UFORM entity in the DICT model. </para>
			<para> That is basically how it works. In a table it would look like this: 
				<table>
					<title>Locality of the code</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Description</entry>
								<entry>Logical Place</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>The function doesnot apply, or contain any references to
									fields or entities.</entry>
								<entry>Include Proc or Global Proc</entry>
							</row>
							<row>
								<entry>The function applies to exactly one field of exactly one
									conceptual entity.</entry>
								<entry>Field level triggers or entity level triggers.</entry>
							</row>
							<row>
								<entry>The function applies to 2 or more fields of exactly one
									conceptual entity.</entry>
								<entry>Entity level triggers</entry>
							</row>
							<row>
								<entry>The function applies to 2 or more conceptual
									entities.</entry>
								<entry>Service</entry>
							</row>
							<row>
								<entry>The function applies to a dum,my entity.</entry>
								<entry>If the dummy entity is defined in an application model you
									should put it in the conceptual entity triggers. If it only
									exists on the component it should be defined on a component
									level. </entry>
							</row>
							<row>
								<entry>The function applies to a dummy entity that is used for the
									same functionality on different components.</entry>
								<entry>In this case the entity should be defined in an application
									model.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</chapter>
		<chapter xml:id="best_practices.entries">
			<title>Entries and Operations</title>
			<sect1>
				<title>Return(0)</title>
				<para> Entries should always be ended using the retun(0) statement. For instance
					when using a setocc statement and then returning there is the possibillity that
					the status of the setocc (being a negative one) is returned to the calling
					function triggering the errorhandling. </para>
				<para>
					<programlisting role="uniface"><![CDATA[
entry CE_WRONG
; this entry is a component entry that will return a  
; negative status 

; get the FOO records from the database 
clear/e "FOO"
retrieve/e "FOO"

; step through the FOO records
while ($status >= 0)
; do something 
...

; next occurence 
setocc "FOO", $curocc("FOO") + 1

endwhile 
; when we get here the status wil be negative. Because the next record was never found. 
; this is not wrong but actually correct behaviour. Nevertheless this function returns a 
; negative value triggering the error handling.
end ; CE_WRONG
]]></programlisting>
				</para>
				<para> By adding a return(0) this will work just fine. </para>
				<para>
					<programlisting role="uniface"><![CDATA[
entry CE_RIGHT
; this entry is a component entry that is a copy of the previous 
; entry but will now function correctly. 
; negative status 

; get the FOO records from the database 
clear/e "FOO"
retrieve/e "FOO"

; step through the FOO records
while ($status >= 0)
; do something 
...

; next occurence 
setocc "FOO", $curocc("FOO") + 1

endwhile 
; when we get here the status wil be negative. Because the next record was never found. 
; by adding an explicit return of a 0 value. The code will continue without a hitch. 
return(0)

end ; CE_RIGHT
]]></programlisting>
				</para>
			</sect1>
			<sect1>
				<title>Ending an Entry or Operation</title>
				<para> Always end the definition of either an entry or an operation using the END
					command. Earlier verions (up until 7.2.06) allow the END command the be ommitted
					from the definition. </para>
				<para> Always add the end command when closing a function. <programlisting role="uniface"><![CDATA[
entry CE_FOO
...
end
]]></programlisting>
				</para>
				<para> For longer operations it might get a bit confusing to which definition the
					END statement belongs to. In order to prevent confusion comment the name of the
					function after the END command. </para>
				<para>
					<programlisting role="uniface"><![CDATA[
entry CE_FOO
; imagine this is a very, very long function.

...

; then it is wise to assign the END command a value.
end ; CE_FOO
]]></programlisting>
				</para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.sql_usage">
			<title>Database Specific References</title>
			<sect1>
				<title>No SQL Usage</title>
				<para> Uniface boasts on his platform and database independence. In order to keep
					the software database independant you should refrain from using SQL in your
					Uniface components. If you need complex queries to produce the required result
					try to use a view. This will be displayed in Uniface as a table that can be
					drawn in components. </para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.programming">
			<title>Programming</title>
			<sect1>
				<title>Include Procs</title>
				<para> When including include procs in your code you shoul always include the library name in
					the code. <programlisting><![CDATA[
; two ways to include IP_PROC from the library MY_LIBRARY
; this is wrong 
#include IP_PROC

; this is right
#include MY_LIBRARY:IP_PROC]]></programlisting></para>
			</sect1>
			<sect1>
				<title>Debug</title>
				<para> the debug statements should be removed from your code before you check it in
					to be deployed to a production environment. Even if the debug has a condition is
					never true on this production environment you should remove it. </para>
			</sect1>
			<sect1>
				<title>Goto</title>
				<para> Do not use the GOTO command. We know it exists and you can use it. But if you
					need to use a GOTO statement. You are better of creating a function. </para>
			</sect1>
			<sect1>
				<title>Break</title>
				<para> Use break commands only in loops. While, for..next etc. Nowhere else </para>
			</sect1>
			<sect1>
				<title>Error Handling</title>
				<para> All calls to entries, operations, include procs and global procs, as well as components
					should be followed by error handling. This prefferably done using include procs.
						<itemizedlist spacing="compact">
						<listitem>
							<para> Interaction with the database: <itemizedlist spacing="compact">
									<listitem>
										<para>
											<literal>commit</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>erase</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>retrieve</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>rollback</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>selectdb</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>sql</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>store</literal>
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para> Interaction with the filesystem: <itemizedlist spacing="compact">
									<listitem>
										<para>
											<literal>filecopy</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>filedump</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>lfilecopy</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>lfiledelete</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>lfiledump</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>lfileload</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>lfilemove</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>lfilerename</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>xmlload</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>xmlsave</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>xmlvalidate</literal>
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para> After accesing other components of functions <itemizedlist
									spacing="compact">
									<listitem>
										<para>
											<literal>run</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>activate</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>newinstance</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>call</literal>
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para> After accesing a 3GL function or other external item:
									<itemizedlist spacing="compact">
									<listitem>
										<para>
											<literal>spawn</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>perform</literal>
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para> When creating reports: <itemizedlist spacing="compact">
									<listitem>
										<para>
											<literal>printbreak</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>print</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>printbreak</literal>
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para> When editing records: <itemizedlist spacing="compact">
									<listitem>
										<para>
											<literal>creocc</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>remocc</literal>
										</para>
									</listitem>
									<listitem>
										<para>
											<literal>setocc</literal>
										</para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist></para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.parametrize">
			<title>Parametrize</title>
			<para> In earlier versions of Uniface (5 and 6) it was possible to pass values to other
				components using global variables. Since Uniface 7 it is possible to parse
				parameters to and from components, operations entries and so on. Many of the
				applications that are currently being developed are migrated from the lower Uniface
				versions to the later versions. Due to the backwards compatible nature of the
				product the software still accepts this way of using variables. </para>
			<sect1>
				<title>Refurbish old objects</title>
				<para> When you need to make alterations to an entry or an operation it is advisable
					that you alter the function by removing all the global and component variuables
					and turn them into parameters. </para>
			</sect1>
			<sect1>
				<title>Do not use component variables in include procs</title>
				<para> This is really a nobrainer. You should us parameters at all times. Using
					component variables in your include procs requires the variables the be defined
					in all components that the code is used in. This highly diminishes the
					reusabillity of the include proc. </para>
			</sect1>
		</chapter>
		<chapter xml:id="best_practices.error_handling">
			<title>Error Handling</title>
			<para> Every call, activate or run statement should be followed by error handling code.
				Even if the called function only puts a message on the screen. There might be a
				developer in the near future that puts something else in that function or component
				that does require error handling. In that case you are prepared up front. </para>
			<para> Other commands that require error handling are: RETRIEVE, </para>
		</chapter>
	</book>


	<book xml:id="quality_assurance">
		<title>Quality Assurance</title>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="mindset">
			<info>
				<title>Mindset</title>
			</info>
			<para> ... </para>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="evolution">
			<info>
				<title>Evolution over Revolution</title>
			</info>
			<para> Many people i have spoken about Quality Assurence and the use of Standards and
				Guidelines always try to convince me that it is better to wait until they have
				started development on a new system to replace the old. I tend to disagree. Many of
				the systems i ahve come across in the years as a Uniface developer are systems that
				were migrated from Uniface version 5 (or maybe 6) towards version 8 or even 9. And
				because of the backwards comaptibillity with the product all the old stuff that
				wasnot required to be changed during the migration weren't changed. The new system
				almost never comes, as does the revolution. </para>
			<para> We have been very succesful with a few clients were we introduced an evolutionary
				approach to Quality Assurance. Think of your system as a house that hasnot been
				cleaned in a while that needs to be thuroughly cleaned. You don't do the house in
				one go. You go room by room. First you move the furniture out of the room, to may be
				another room. After you have done so you throw away the garbage. You clean the room
				and clean the furniture before you move them back into the clean room. Duriong this
				process the house evolves from a gross and disgusting place into a clean and
				weolcoming domicile. </para>
			<para> The same approach can be done with your Uniface system. When you need to alter a
				component in a project or a change request you are also responsible for maintaining
				the component. Replacing the existing labels, messages and code by ones that are
				according to the new standards and guidelines. Attaching a template to the
				component. Replacing all the <function>run</function> statements by an
				<function>activate</function> and so on. </para>
			<para> The key to a succesfull implementation of Standards and Guidelines and Quality
				Assurance is to start small and adopt it in a bottum-up fashion. Start for instance
				bij defining the naming conventions for fields, entities, labels and messages. In
				weekly sessions of about 30 minutes, with a select group of developers, you expand
				these guidelines. What is missing what is considered incorrect or unnecessary. After
				that you share the new additions with the rest of the development team. </para>
			<para> Donot be dissapointed or have your motivation reduced by friction form the other
				developers. In many companies, there are usually some guidelines defined but they
				are outdated and they have neglected them over time. Creating an environment where
				the developer is allowed to basically create the software as he sees fit. They
				consider it to be an inalianable right. Offcourse they will protest if these rights
				are being trampled and deminished. Just remember that code that is developed
				according to guidelines is very uniform and therefore benefits the company. That
				same company that pays your salary, i might add. </para>
			<para> If you take it slowly and draw attention to the guidelines as freqeuntly and
				often as possible, people will get conditioned and start working with and adopting
				the guidelines. They will even start to see the benefits. </para>
			<para> A good sponsor, or sponsors, is absolutely vital to the succesful implementation
				of a set of guidelines. Somebody needs to take responsibillity and ownership for
				these gudielines. Only then will the implementation have a change of success. It is
				possible to share this responsibillity between developers. In a way that is
				comparable to the way the role of Scrum master is shared in between sprints. </para>
		</chapter>
	</book>
	
	<book xml:id="standards_and_guidelines">
		<title>Standards and Guidelines</title>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="preparation">
			<info>
				<title>Meta Decisions</title>
			</info>
			<para> Before we can start defining standards and guidelines for developping in Uniface
				we must first make some decisions. We have to determine what the language is that is
				used trougout the application. Will you use the local language as a default for
				comments in code and the development of technical and functional designs or will you
				use a generally more accepted language to describe your application. Throughout this
				document we assume that you have decided to use a generally accepted language,
				English, as your default language. 
			</para>
			<sect1>
				<title>One DBMS to rule them all</title>
				<para>
					It is probably a good practice to have your system set up to have only one database management system (DBMS) 
					manipultaing and accessing your data. Your data is sacred. It needs to be protected because is is valuable to you. 
					You need to guard and protect it. So you should not allow any DBMS or any other programming language with database 
					access possibillities and a pretty mouth access to your data. It is your kingdom that needs protection put a sentry in 
					front of the gate.
				</para>
				<para>
					By doing this you accomplish a few minor but pretty important things right of the bat:
					<itemizedlist spacing="compact">
						<title>Important sucesses by using a single DBMS</title>
						<listitem>
							<para>Single point of definition means single point of failure. 
								Data is always accessed and manipulated in the same way. Errors, strange or 
								unexpected behaviour can be reduced to one single technology.
							</para>
							<para>
								Single point of definition also means a single location for data access. 
								This makes for easier control over your code  
								and more transparent coding sections. 
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</sect1>
			<sect1>
				<title>
					Assign yourself an architect 
				</title>
				<para>
					When you listen to developers sometimes it may very well be possible that Rome was indeed built in 
					a day. Changes can be fast and easy, lean and mean and above all quick and dirty. But these changes are 
					never cheap. Because every developer has it's own character (yes we are not all binary organisms but actually 
					human beings with actual feelings) and use different ways te resolve issues, no two sets of code are the same. 
				</para>
				<para>
					So it is possibly a good idea to assign an architet to oversee the development process and have a final 
					decission where it comes to weighing the interests of the developer and the customer. More often than not 
					these interests conflict where it concerns time, money and quality. 
				</para>
				<para>
					The architect is responsible for the overall technical quality of the code. This means: 
					<itemizedlist spacing="compact">
						<title>Responsibillities of the software architect</title>
						<listitem>
							<para>Keeper of the coding standards and guidelines</para>
						</listitem>
						<listitem>
							<para>
								Judge, jury and exectutioner for major design decisions. For instance database design, security etc.
							</para>
							<para>
								Codeguru for his fellow developers
							</para>
							<para>
								Quality Assurance man for the deliverence of code to test, acceptance and production stages. 
							</para>
						</listitem>
					</itemizedlist>
					This is quit an extensive list and probably to much work for one man. So there may be several developers 
					of the senior kind that create an architect bureau. Or may be you have a rotation plan where every senior developer
					gets the change to be architect for a ccertain period of time. 					
				</para>
				<para>
					The main thing is that, where most civilications are democratic there is always a supreme ruler 
					that says what goes and what doesnot, for the good of the collective. That is why you need a software architect.
				</para>
			</sect1>
			<sect1>
				<title>The pressure principle</title>
				<para>
					When desinging your application you need to take in account the pressure principle. The same as 
					diving in a submarine, the deeper you go the higher the specs that the submarine has to 
					comply with. You wouldn't want the thing to disintegrate on you, 27.000 leagues under the sea (thank you Jules verne).
				</para>
				<para>
					The same applies to your application. Some things float on the surface and are pretty shallow. They can be because there 
					are a limited number of methods, services, components or other elements referring to it. 
				</para>
				<para>
					Some are a little deeper in and should comply to more scrupulous specifications. 
				</para>
				<para>
					Some are pretty much near the floor of the ocean. these should be failsafe, fireproof and should be able to withstand the 
					strongest of forces and then some. These are the smallest parts of your application but just about 
					every other function relies on them for information or some type of processing. 
				</para>
				<para>
					Please allow me to clarify. Let's assume you are building a financial application for a large bank. This 
					application contains several entities with monetary values (because it is a bank). Each monetary value needs a currency.
					For the currencies you have created an individual table. So everytime a monetary value is retrieved, the currency table is 
					accessed to get the type of currency. If you made a mistake or just did some poor designing on the signature of the method (the parameters in the signature), 
					you need to redo your work. This means altering every entry to this object from every monetary table. Which is 
					teadious and expensive. 
				</para>
				<para>
					You would have been better of just designing a signature of two parameters, a list of input values and a list
					of output values. Where the object does it's own checks to validate the input and output lists of parameters. 
				</para>
				<para>
					So the pressure principle means that the deeper the element is embedded in your application the more flexible it 
					needs to be to withstand the demanding pressure. The more shallow the element is the lesser this applies. But in 
					order to get this right you need to think well and hard about the design of the application.
				</para>
			</sect1>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="naming_conventions">
			<info>
				<title>Naming Conventions</title>
			</info>
			<sect1 xml:id="standards.naming.general">
				<title>General</title>
				<para> When defining a naming convention you should always keep in mind that
					"simplicity is key". There is not much space for defining labels, variables and
					functions, so you should also try to keep everything as short as possible. So
					use 1 letter indicators for type. Like V for variable, P for parameter, E for
					Entry, O for Operation and so on. </para>
				<para> you should always use a short code (an abreviation if you will) to indicate
					function. GET for retrieving data, WRN for Warning, ASK for a question and so
					on. </para>
				<para>
					<table>
						<title>Abbreviations</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Abbreviation</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>v_</entry>
									<entry>(local) variable</entry>
								</row>
								<row>
									<entry>p_</entry>
									<entry>(local) parameter</entry>
								</row>
								<row>
									<entry>O</entry>
									<entry>Operation</entry>
								</row>
								<row>
									<entry>E</entry>
									<entry>Entry</entry>
								</row>
								<row>
									<entry>L_</entry>
									<entry>Label</entry>
								</row>
								<row>
									<entry>T_</entry>
									<entry>Title</entry>
								</row>
								<row>
									<entry>H_</entry>
									<entry>Helpmessage</entry>
								</row>
								<row>
									<entry>M_</entry>
									<entry>Message</entry>
								</row>
								<row>
									<entry>C_</entry>
									<entry>Component title</entry>
								</row>
								<row>
									<entry>S_</entry>
									<entry>Service title</entry>
								</row>
								<row>
									<entry>D_</entry>
									<entry>Dynamic Server Page</entry>
								</row>
								<row>
									<entry/>
									<entry/>
								</row>
								<row>
									<entry>DM_</entry>
									<entry>Dummy Application Model</entry>
								</row>
								<row>
									<entry>DE_</entry>
									<entry>Dummy Entity</entry>
								</row>
								<row>
									<entry>DF_</entry>
									<entry>Dummy Field</entry>
								</row>
								<row>
									<entry>CD_</entry>
									<entry>Code field. Usually no longer than 1, 3, 5 or 10 characters, allways
										uppercase.</entry>
								</row>
								<row>
									<entry>NR_</entry>
									<entry>Numeric values</entry>
								</row>
								<row>
									<entry>FT_</entry>
									<entry>Free text values. Large fields for notes or fields with an unknown format.</entry>
								</row>
								<row>
									<entry>NM_</entry>
									<entry>Fields with a specified format containing names</entry>
								</row>
								<row>
									<entry>ID_</entry>
									<entry>Identifiers, usually primary of foreign key fields.</entry>
								</row>
								<row>
									<entry>PK_</entry>
									<entry>Primary key fields.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Abbreviations for actions</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Abbreviation</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>CRE</entry>
									<entry>Create</entry>
								</row>
								<row>
									<entry>GET</entry>
									<entry>Retrieval of some kind</entry>
								</row>
								<row>
									<entry>DEL</entry>
									<entry>Delete or removal of some kind</entry>
								</row>
								<row>
									<entry>UPD</entry>
									<entry>Update</entry>
								</row>
								<row>
									<entry>CHK</entry>
									<entry>Function that evaluates a value</entry>
								</row>
								<row>
									<entry>WRN</entry>
									<entry>Warning</entry>
								</row>
								<row>
									<entry>MSG</entry>
									<entry>Message</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
				<para> This setup doesnot cover the entire range of actions that are possible on any
					ionformation system. Take for instance the login action performed by a user.
					This is a combination of GET_USER_INFO and CHK_PASWORD but in order to do them
					you might want to create a function named LOGIN_USER. In this case we used a
					verb to identify the action being performed by the user. The same applies to
					SEND_EMAIL, POST_TWEET, DROP_TABLE.without any explanation it is perfectly clear
					what the function does. </para>
			</sect1>
			<sect1 xml:id="standards.naming.entries">
				<title>Entries and operations</title>
				<para> Entries and operations can be defined in several locations in Uniface.
					Logical places where they can be defined are: the local procs triggers and
					operations triggers at the component level, the local procs triggers, the
					occurence operations triggers and the collection operations triggers at the
					painted entity level. And finally the the local procs triggers, the occurence
					operations triggers and the collection operations triggers at the conceptual
					entity level. Entries and operations can also be found at the library level in
					the include procs and the global procs level. </para>
				<para> You might have noticed that we didnot mention the local procs triggers at the
					conceptual and the painted fields level. We left them out on purpose. We donot
					want to encourage you to use these triggers at these levels. Anhything you would
					place in these triggers are much better of being defined in the entity level of
					the field. </para>
				<para> Back on the subject. If you have that many triggers where you can find either
					an entry or an operation you might want to add something in the name that gives
					away the location of the operation or entry. The easiest way to separate the
					entries from the operations are to use an E for Entry or an O for Operation in
					the name. The determine the location you can add another letter. Maybe a M for
					entries and operations at the Model (or Conceptual) level, </para>
				<para> In a table this looks like: 
					<table>
						<title>Namming Conventions Entries and Operations</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Level</entry>
									<entry>Entry</entry>
									<entry>Description</entry>
									<entry>Operation</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>Include Procs</entry>
									<entry>IP_</entry>
									<entry/>
									<entry/>
									<entry/>
								</row>
								<row>
									<entry>Central Procs or Global Procs</entry>
									<entry>CP_ or GP_</entry>
									<entry/>
									<entry/>
									<entry/>
								</row>
								<row>
									<entry>Model or Conceptual Entities</entry>
									<entry>ME_</entry>
									<entry>Model Entry</entry>
									<entry>MO_</entry>
									<entry>Model Operation</entry>
								</row>
								<row>
									<entry>Components</entry>
									<entry>CE_</entry>
									<entry>Component Entry</entry>
									<entry>CO_</entry>
									<entry>Component Operation</entry>
								</row>
								<row>
									<entry>Painted Entities (nonmodal)</entry>
									<entry>EE_</entry>
									<entry>Entity Entry</entry>
									<entry>EO_</entry>
									<entry>Entity Operation</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
				<para> When creating component there are only 16 characters available. So you have
					to keep the name of your component short and sweet. For template naming we
					separate the components from the services by using C for Components and S <table>
						<title>Namming Conventions Components</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Abbreviation</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>CCT_</entry>
									<entry>Component Template</entry>
								</row>
								<row>
									<entry>CRT_</entry>
									<entry>Report Template</entry>
								</row>
								<row>
									<entry>CDT_</entry>
									<entry>Dynamic Server Template</entry>
								</row>
								<row>
									<entry>CST_</entry>
									<entry>Static Server Template</entry>
								</row>
								<row>
									<entry>SET_</entry>
									<entry>Entitiy Service Template</entry>
								</row>
								<row>
									<entry>SST_</entry>
									<entry>Session Service Template</entry>
								</row>
								<row>
									<entry>ST_</entry>
									<entry>Service Template</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
				<para> When creating component there are only 16 characters available. So you have
					to keep the name of your component short and sweet. For naming componentens : <table>
						<title>Namming Conventions Components</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Abbreviation</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>C_</entry>
									<entry>Component</entry>
								</row>
								<row>
									<entry>R_</entry>
									<entry>Report</entry>
								</row>
								<row>
									<entry>D_</entry>
									<entry>Dynamic and statis Server Template</entry>
								</row>
								<row>
									<entry>S_</entry>
									<entry>Service Template</entry>
								</row>
							</tbody>
						</tgroup>
					</table> The list of comoponents is shorter than the templates. We donot think
					it is wise to differentiate between the many services that are available. You
					only have 16 characters available for your component. </para>
			</sect1>
			<sect1 xml:id="standards.naming.variables">
				<title>Variables and Parameters</title>
				<para> The same as with entries and operations variables can be defined at several
					levels in the application. There are Global Variables, Component Variables and
					variables defined in entries and operations. And then there are parameters. </para>
				<para> Global variables can be recognized by the fact that they are preceeded by two
					dollar signs ($$global_variable). Component variables carry the same dollar
					signs but in different locations ($component_variable$). So it is really nit
					necessary to assign any naming convention to both these variables. If you would
					like to make all variable names to be defined in a uniform way you can let the
					naming convention for variables defined below to be applicable to all variabled.
					(i.e. $$v_global and $v_component$) </para>
				<para> The basic rule for naming variabels and parameters is to put a letter in
					front of it defining the type of the containter. So for variables this would be
					v_variablename and for parameters this would be p_parametername. </para>
				<para> Variables and parameters should always be written in lowercase. </para>
				<sect2 xml:id="standards.naming.boolean">
					<title>Naming a boolean</title>
					<para> Booleans are switches that indicate either a true or false state in the
						application. Naming a variable of the type boolean can in some cases be
						ambiguous or unclear what is ment by the developer. For instance the boolean
						value v_extra_deposit. Does it mean that the customer made an extra deposit
						of is allowed to make extra deposits. The same is true for v_second_car.
						Does the customer have a second car? Does he want one? Without some
						additional context you cannot tell for sure what the boolean value means. </para>
					<para> So let's add a little context. You can do this by defining the boolean
						value as a question. v_made_extra_deposit tells us that the customer made an
						extra deposit. If the variable is true. <literal>v_has_second_car</literal>
						tells us, if the value is true, that the customer has a second car. The same
						is true for the following variables v_isloaded, v_ismarried, v_ownsdog,
						v_paidbill. </para>
					<para> So if you can add a question mark at the end of the boolean and it sounds
						like a question you probably defined a very strong boolean. Make sure to
						make the question a closed one. The only possible answers allowed are yes or
						no, or true or false. And make it a strong question. Consider the following
						v_ismarried, v_hasmarried both variables are used to indicate if a customer
						is married. However in the first case most people will answer either yes or
						no, where the next leaves room for discussion. He may have been married but
						may not be anymore. </para>
					<para> If you use booleans to indicate acurrent state use verbs that indicate
						that state. Words like is, has, does, owns, buys. For states in the past use
						verbs that indicate past. Did, had, owned. Or use verbs in their present
						tense. Died, divorced, wrecked. </para>
					<para> For boolean values to indicate things in the fucture use future tense.
						Will, wants et cetera. </para>
				</sect2>
				<sect2 xml:id="standards.naming.parameters">
					<title>Directionality of Parameters</title>
					<para> Parameters in functions have directionality. They are either coming in
						(in), going out (out) or bidirectional (inout). The directional words are
						just as the parametername written in lowercase. 
<programlisting role="uniface"><![CDATA[
entry CE_VARIABLES
; parameters and variables all lowercase.
params 
string p_first : in
string p_first : inout
string p_first : out
endparams
variables
string v_variable
endvariables 

return(0)
end ; CE_VARIABLES
]]></programlisting>
					</para>
					<sect3>
						<title>Order of parameters</title>
						<para> You should order the parameters by directionality. The in parameters
							first the inout parameters second and the out parameters third. This
							gives order and structure to your function. </para>
					</sect3>
					<sect3>
						<title>General or specific parameters</title>
						<para> For functions that are buried deep in the application and are the
							smallest most frequently used components it is probaly wise to use list
							parameters. One string contains all the in values and one parameters
							contains all the out parameters. In this case if you need to add a
							parameter you just add it to the list and alter the code of the
							fuinction without changing its signature (the number of parameter donot
							change). </para>
						<para> For more specific less frequently used function it is better to be
							more specific in the parameters you pass. </para>
					</sect3>
				</sect2>
			</sect1>

			<sect1 xml:id="standards.naming.application_models">
				<title>Application Models</title>
				<sect2>
					<title>Naming an application model</title>
					<para></para>
				</sect2>
			</sect1>
			<sect1 xml:id="standards.naming.entities">
				<title>Entities</title>
				<sect2>
					<title>Naming an application entity</title>
					<para> When naming an entity it is usually a good idea to think about the names of the
						entities. Whatever you decide to do it is important that you name the
						entities uniformly. For instance do you name the entities in plural or
						singular. The entity containing the persons or customers in your database
						will the be named PERSONS and CUSTOMERS or PERSON and CUSTOMER. </para>
					<para> i like to use PERSONS and CUSTOMERS because i am looking to register more than one
						person and custoner in these entities. But there is no wrong answer in this
						case. The only rule is they should be all the same whether it nbe plurar or
						singular.</para>
				</sect2>
				<sect2>
					<title>Working with prefixes</title>
					<para>If you like to work with prefixes so that you have all the tables that are supposaed to
						go together at the tips of your fingers, this might work for you but would
						it not be better to create a application model to house these entities?
						There is nu ruling on creating relationships beyond application models
						(although you'd best use an interface). Using different models also helps
						you to unclutter the application model you are currently stuffing with
						prefixes. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="standards.naming.fields">
				<title>Fields</title>
				<sect2>
					<title>Type of fields</title>
					<itemizedlist spacing="compact">
						<listitem>
							<para>String Values</para>
							<itemizedlist spacing="compact">
								<listitem>
									<para>CD - Code Fields Fields used for indication. Yes/no
										fields, male/female etc</para>
									<para> A code field is basically a field that is 1 to 5
										characters long that contains a code. This could be sexe,
										currency, countries etc. Each code represents to a
										description in a list. So they could be used for a foreign
										key relation with a table containing the values or just
										reference a list of some kind. If the field is part of a
										relationship to another entity or is a reference to an
										associated list. than you need to use the prefix CD. </para>
								</listitem>
								<listitem>
									<para>FT - Free Text or Description Fields</para>
									<para> A free text value is a non specific string field. This
										field contains information that may be usefull to the user
										but has no technical significance. It is not a foreign key
										field. It is just informatiomn to the user. It is a field
										with no technical or functional business rules. There is no
										underlying code that evaluates the entered string, and it
										has not a part of the key in a relations to other antitieis.
										If there is you need to look at another name for the field.
									</para>
								</listitem>
								<listitem>
									<para>NM - Name Fields</para>
									<para> Names are actually pretty common in an application. You
										have a username, customername, companyname, name of a city
										name of the street etc. If the value you want to register as
										of a type string and has a certain set of business rules of
										validity checks and it is not part of a relationship in the
										application model. changes are you should name it with the
										NM prefix. </para>
								</listitem>
								<listitem>
									<para>SN - Serial Number</para>
									<para>Identifier used for numbers that are actually formatted as strings. such as serial numbers, software license keys, 
										telephone numbers, social security numbers, bank account (especially with the
										upcoming IBAN introduction in 2014), employee number, license plate etc. </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Numeric Values</para>
							<itemizedlist>
								<listitem>
									<para>NR - Numeric fields</para>
									<para> There is basically only one numeric value that you can
										think of. And that is number. It can be used to express time
										parts. Like number of years, months, days, age. Measure of
										distance meters, kilometers, miles, inches and centimeters.
										It could be used to indicate content. Liters, centiliters,
										gallons but number of items in a box. number of square
										inches, cubic feet. Passengers etc. Timestamps fit in this
										category as well because they too are a number. Scores,
									</para>
								</listitem>
								<listitem>
									<para>ID - Identification</para>
									<para> There is one other numeric field that we need to distinguish. This is the identifier
										for records. Customer id. Person id, etc. This ID field is
										usually referenced to another field bearing the samen name
										defined in another entity. We use the prefix ID to indicate
										that the field is of the type Primary Key.</para>
								</listitem>
								<listitem>
									<para>PC - Percentages</para>
									<para> Percentages are number of a different kind. For the 
										naming we choose to use PC.</para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Date or Datetime Values</para>
							<itemizedlist>
								<listitem>
									<para>DT - Date fields or datetime</para>
									<para> For the registration of birthdays, creation dates
										etcetera you need a date field. This field can also be used
										to signify a datetime field as wel. </para>
								</listitem>
								<listitem>
									<para>TM - Time fields</para>
									<para> If you requirre to create a field for specific
										registration of times, start times and end times for
										instance, you can use this acronym. </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Money Values</para>
							<itemizedlist>
								<listitem>
									<para> AT - Amounts </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Boolean Values</para>
							<itemizedlist>
								<listitem>
									<para>BN -Boolean </para>
									<para>We strongly suggest you not using booleans in a database.
										But use a string of type code instead. This gives you some
										flexibillity when the number of values that are supposed to
										go in the database will change. </para>
									<para>
										For instance the gender used to be male or female. So some applications just 
										assume that the person is female when the ISMALE field contains a FALSE value. 
										In recent years these systems couldnot handle the registrationh of transgenders.
										These are persons with both male and female characterisitcs. 
									</para>
									<para>
										If you do need to use BOOLEAN values. Use them in the form of a question. 
										For instance ISCHECKED means that the record is checked when the value is TRUE. 
										If FALSE the records still needs to be checked.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
						
						<listitem>
							<para>Non-Database Values</para>
							<itemizedlist>
								<listitem>
									<para>DF - Dummy Field </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Control Structure Values</para>
							<itemizedlist>
								<listitem>
									<para>BT - Button </para>
									<para>Make sure that when you are using buttons you maintain the same order 
									as the operating system does. In windows it is form left to right Ok, cancel, Apply.
									Any other layout may confuse the user. 
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Images</para>
							<itemizedlist>
								<listitem>
									<para> IM - Image </para>
								</listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
					<para> These definitions are basically all you need. If you need a field to
						contain a year you just name it NR_YEAR instead of YR_. Same thing for
						months and days. If you think you need another category you are probably not
						looking at the data the right way. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="standards.naming.templates">
				<title>Templates</title>
				<sect2 xml:id="standards.naming.templates.component">
					<title>Component Templates</title>
					<para> ... </para>
				</sect2>
				<sect2 xml:id="standards.naming.templates.entity_interface">
					<title>Entity Interface</title>
					<para> ... </para>
				</sect2>
				<sect2 xml:id="standards.naming.templates.field_interface">
					<title>Field Interface</title>
					<para> The field interface defines the width of the field as well as a little
						more detail of the datatype. For instance an interface C40 usually means
						that the length of the field is 40 and that the field only contains
						characters. Although this usually means that the datatype is string it is
						not supposed to be used this way. </para>
					<para> Uniface supports both a shorthand and a template for all three field
						definitions (i.e syntax, interface and layout). We do encourage you to use
						templates as much as possible. The use of templates allows you to do
						alterations on the template that are automatically inherited by the fields
						that have that certain template. </para>
					<para> There are several ways to use these templates. For instance <itemizedlist
							spacing="compact">
							<listitem>
								<para> Creating a template for each individual field in the
									application model; </para>
								<para> In this instance every field (with the same name) is issued
									the same template. This will result in a set of templates that
									is too large (as large as all fields in the application models)
									to manage. </para>
							</listitem>
							<listitem>
								<para> Creating a generic template for all fields with the same
									technical properties; </para>
								<para> This option wil result in a set of templates that is more
									easily to manage. Although problems will hit as soon as one of
									the fields is too small for what is needed to be put in the
									field. You have to adjust the template and then have to alter
									all the fields that have that same template. Even if they donot
									need to be enlarged. </para>
							</listitem>
							<listitem>
								<para> Create a mix of templates that is just right; </para>
								<para> This is a mix of the other two scenarios. And consists of two
									rules: <itemizedlist spacing="compact">
										<listitem>
											<para> For each primary key you create a unique template </para>
											<para> This means that all the foreign keys that are
												related to this field, must carry the same template.
												If you need to enlarge or reduce the size you just
												adjust the template and update the primary key and
												the related fields. </para>
										</listitem>
										<listitem>
											<para> For every other value you create a generic
												template </para>
											<para> A database usually has several fields that
												contain amounts of money, description, codes of some
												kind. For these fields you create one, or a few
												templates. For instance you create a template for a
												description field with a size of 100 characters or
												200 characters. </para>
											<para> If case you need a description field of 125
												characters. donot create it. Just use the 200
												characters sized one. Only if there is a real
												restriction behind it. For example the field is used
												to tweet some information you need to restrict it to
												140 characters and you need to create an indiviual
												template. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2 xml:id="standards.naming.templates.field_syntax">
					<title>Field Syntax</title>
					<para> When naming field syntax templates you should keep two things in ming. </para>
					<para> First the prfix should be short and easy. For instance just adding an S_
						to name the template should be sufficient. </para>
					<para> Second you shoul obide by the naming conventions. Be specific for keys.
						Be generic for any other value. </para>
				</sect2>
				<sect2 xml:id="standards.naming.templates.field_layout">
					<title>Field Layout</title>
					<para> ... </para>
				</sect2>
				<sect2 xml:id="standards.naming.templates.field_template">
					<title>Field Template</title>
					<para> ... </para>
				</sect2>
			</sect1>
			<sect1 xml:id="standards.naming.models">
				<title>Application Models</title>
				<sect2 xml:id="standards.naming.models.model">
					<title>Models</title>
					<para> ... </para>
				</sect2>
				<sect2 xml:id="standards.naming.models.entity">
					<title>Entities</title>
					<sect3 xml:id="standards.naming.models.entity.keys">
						<title>Keys</title>
						<para> ... </para>
					</sect3>
				</sect2>
				<sect2 xml:id="standards.naming.models.field">
					<title>Fields</title>
					<para> ... </para>
					<sect3 xml:id="standards.naming.models.field.syntax">
						<title>Syntax Definition</title>
						<para> ... </para>
					</sect3>
					<sect3 xml:id="standards.naming.models.field.interface">
						<title>Interface Definition</title>
						<para> ... </para>
					</sect3>
					<sect3 xml:id="standards.naming.models.field.layout">
						<title>Layout Definition</title>
						<para> ... </para>
					</sect3>
				</sect2>
			</sect1>
			<sect1 xml:id="standards.naming.libraries">
				<title>Libraries</title>
				<sect2 xml:id="standards.naming.labels">
					<title>Messages</title>
					<para>Messages come in all different shapes and sizes. Labels, warning messages,
						error mesages and so on. When definin a messages try to identify the type
						first before you name it. </para>
					<para><code>T_NNNNNNNNN</code></para>
					<para>The <code>T</code> is the type of the message. With one letter you should be able to
						identify the type of message.</para>
					<para><table frame="all">
							<title>Component types</title>
							<tgroup cols="2">
								<colspec colname="c1" colnum="1" colwidth="1.0*"/>
								<colspec colname="c2" colnum="2" colwidth="1.0*"/>
								<thead>
									<row>
										<entry>Code</entry>
										<entry>Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry>T</entry>
										<entry>Title</entry>
									</row>
									<row>
										<entry>L</entry>
										<entry>Label</entry>
									</row>
									<row>
										<entry>M</entry>
										<entry>Message</entry>
									</row>
									<row>
										<entry>H</entry>
										<entry>Helptext</entry>
									</row>
									<row>
										<entry>E</entry>
										<entry>Error</entry>
									</row>
									<row>
										<entry>W</entry>
										<entry>Warning</entry>
									</row>
									<row>
										<entry>I</entry>
										<entry>Information</entry>
									</row>
									<row>
										<entry/>
										<entry/>
									</row>
								</tbody>
							</tgroup>
						</table>The <code>N</code> identifies the name of the message. The actual
						name depends on the type of message. In case of the title of a component the
						message shoud read <code>T_&lt;componentname></code>. Where in case of a
						label the name should probably read <code>L_&lt;fieldname></code> without
						the entityname. Just in case you would like to reuse it for fields with the
						same name in another entity. </para>
					<para>But how about values in a list. For instance the values in the list that
						determines the sexe of a person? How about <code>L_&lt;value></code>.
						Meaning L_MALE for the male value of the list and <code>L_FEMALE</code> for
						the Female part. You may even add a value <code>L_BOTH</code> to identify
						transgenders Or a list of addresses? <code>L_HOME</code>,
							<code>L_OFFICE</code> clearly identifies Home and office
						addresses.</para>
					<para>Helptexts work the same as labels, just add the name of the field after
						the type. <code>H_&lt;fieldname></code>. Here again no entityname, so we can
						reuse it at the component level bij just adding the line <code>help
							$text(H_&lt;$fieldname>)</code> to the help trigger. We may even want to
						create an <code>#include</code> proc with this value so that we can change
						the ugly help screen later by something cool we built ourselves. </para>
					<para>How about the type of messages. How can we distinguish a warning from an error or
						information message. You could choose to use the characters E, W and I to
						distinguish the different messages, or you could use the syntax
							<code>M_E_&lt;error_message></code> to identify error messages. Both
						have some good arguments. </para>
				</sect2>
				<sect2>
					<title>Include Procs</title>
					<para><code>IP_&lt;name of the include proc></code></para>
					<para><code/></para>
				</sect2>
				<sect2>
					<title>Global Procs</title>
					<para><code>GP_&lt;name of the include proc></code></para>
					<para>Because a global procs uses the same syntax as a local entry we need to
						distinguish them from the local stuff. The prefix GP should accomplisch just
						that.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="standards.naming.components">
				<title>Components</title>
				<para>When wroking with activations of components it is not always clear what the type of
					component is or of which part of the application it is. In order to identify the
					component in code we suggest you use a naming convention that consists of the
					following syntax: <code>T_MMM_NNNNNNNNN</code></para>
				<para>Where the <code>T</code> stands for the type of document. The type can be any value as
					mentioned in the Component Types table</para>
				<para>The <code>M</code> stands for Modelname. When you are coding in Uniface it is
					usually good practice to bound a component to a main application model. For
					instance a login screen is part of an application model that revolves around
					users, where an invoice screen is part of a financial part of the system. So a
					login form should be named <code>C_USR_LOGIN</code> and an invoicecomponent
					could be named C_FIN_INVOICE. You should keep track in your standards and
					guidelines what three leytter abbreviation to use for the application
					model.</para>
				<para>The <code>N</code> stands for Name of the component. No regulations for this
					part of the name other than you should keep it short and sweet.</para>
				<para>
					<table frame="all">
						<title>Component types</title>
						<tgroup cols="2">
							<colspec colname="c1" colnum="1" colwidth="1.0*"/>
							<colspec colname="c2" colnum="2" colwidth="1.0*"/>
							<thead>
								<row>
									<entry>Type</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>F</entry>
									<entry>Form</entry>
								</row>
								<row>
									<entry>R</entry>
									<entry>Report</entry>
								</row>
								<row>
									<entry>P(age)</entry>
									<entry>Static Server Page</entry>
								</row>
								<row>
									<entry>D</entry>
									<entry>Dynamic Server Page</entry>
								</row>
								<row>
									<entry>E</entry>
									<entry>Entity Service</entry>
								</row>
								<row>
									<entry>I</entry>
									<entry>Session Service</entry>
									<entry/>
								</row>
								<row>
									<entry>S</entry>
									<entry>Service</entry>
								</row>
								<row>
									<entry/>
									<entry/>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
				<para>Most of the chosen abbreviations are straight forward. We suggest you use the
					first character of the name of the component type to identify the component. In
					order to keep all the components together while sorting we furthermore suggest
					you donot use a character more than once. using a character more than once
					creates ambiguis component names.</para>
				<para>For the component types that start with the same name we used one of the other
					charactyers to identify the type. Feel free to use any other character. </para>
			</sect1>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="coding_conventions">
			<info>
				<title>Coding Conventions</title>
			</info>
			<sect1 xml:id="standards.coding.general">
				<title>General</title>
				<para> One of the most important things of a standard and guidelines document are
					the coding conventions. In this section we will discuss the wide range of
					conventions there are when coding Uniface. </para>
				<sect2>
					<title>Uniform Coding</title>
					<para> Although Uniface allows you to write oneliners when it comes to the if
						statement. You should discipline yourself to always use the endif statement
						to clase an if statement. </para>
					<para> This is incorrect: <programlisting role="uniface"><![CDATA[
; example of a oneliner 
if ($status >= 0) return(-1)
]]></programlisting>
					</para>
					<para> This is correct: <programlisting role="uniface"><![CDATA[
; correct 
if ($status >= 0) 
   return(-1)
endif
]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Field- and entitynames</title>
					<para> All fieldnames and entity names should be written in uppercase. Commands,
						variables and constants and any opther code should be written in lowercase.
					</para>
				</sect2>
				<sect2>
					<title>Indentations</title>
					<para> Indentations should be 3 spaces after the following commands: <programlisting role="uniface"><![CDATA[
; function 
entry 
operation 

; sections 
variables
params

; conditional operators
selectcase 
case
if
else
elseif
endif
while
endwhile
for
endfor
]]></programlisting> NOTE: please do not use tabs when coding uniface. It will mess up the
						indentation. </para>
					<para> The indentation must be decreased by 3 spaces when encountering lines
						that start with: <programlisting role="uniface"><![CDATA[
; closing function for both operation and entry
end

; sections 
endvariables
endparams

; conditional operators
endselectcase 
else...endif
endwhile 
endfor
]]></programlisting> NOTE: please do not use tabs when coding uniface. It will mess up the
						indentation. </para>
				</sect2>
				<sect2>
					<title> Brackets </title>
					<para> When using brackets in code you should accustom yourself to have the
						brackets directly after the command and the following string right behind
						the bracket. <programlisting role="uniface"><![CDATA[
<?php
 echo("FOOBAR");
echo ("vind ik niet ") ; 
; druk de waarde af
?>
$text("FOOBAR")
]]></programlisting> You should refrain from using examples like: <informalexample>
							<programlisting role="uniface"><![CDATA[
$text ( "FOOBAR" ) // or 
$text( "FOOBAR" ) // or 
]]></programlisting>
						</informalexample>
					</para>
					<para> In most cases the entity name should be placed in between brackets. For
						instance <informalexample>
							<programlisting role="uniface"><![CDATA[
$dbocc("FOOBAR") // or 
$curocc("FOOBAR") // or 
setocc("FOOBAR")
]]></programlisting>
						</informalexample> Where FOOBAR is the name of the entity. </para>
				</sect2>
			</sect1>
		</chapter>
		<!-- DO NOT EDIT THIS FILE. The index info comes from PhD -->
		<appendix xmlns="http://docbook.org/ns/docbook" xml:id="indexes">
			<title>Index listing</title>
			<section xml:id="indexes.functions">
				<title>Function and Method listing</title>
				<para>List of all the functions and methods in the manual</para>
				<?phpdoc generate-index-for="refentry"?>
			</section>
			<section xml:id="indexes.examples">
				<title>Example listing</title>
				<para>List of all the examples in the manual</para>
				<?phpdoc generate-index-for="examples"?>
			</section>
		</appendix>
	</book>
	
	<book xml:id="legacy">
		<title>Maintaining Your Legacy System</title>
		<chapter xml:id="legacy.introduction">
			<title>Introduction</title>
			<para> Most of the Uniface application that exist today are large, complex legacy
				systems. It is a utopuia to think that somewhere in the near future, management is
				going to decide to rebuild the application from scratch. Therefore that ultimate
				moment to rethink your software development strategy, the implementation of
				standards and guidelines and all the other things you had planned to do at that
				moment will never materialize. Because managament will never make that decisions. In
				very few cases they will and they have but most of the time? No chance. </para>
			<para> So the best time to start refurbishing and doing maintenance on your application
				is right now. In this section of this document we will give you some pointers on
				things that are quite easy to establish and maintain. </para>
		</chapter>
		<chapter xml:id="legacy.general">
			<title>General Maintenance</title>
			<sect1>
				<title>Removal of duplicate code snippets</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Replacing 3GL by Signatures</title>
				<para> ... </para>
			</sect1>
		</chapter>
		<chapter xml:id="legacy.library">
			<title>Maintaining the library</title>
			<sect1>
				<title>Removal of duplicate messages and labels</title>
				<para> Over time the messages and labels in the application could get very
					cluttered. Especially in environments where developers are allowed to create
					their own messages. There is always one, you know who he or she is, that will
					cut corners to save time and create a message or label with the same text as an
					allready existing one. </para>
			</sect1>
			<sect1>
				<title>Checking the existence for all messages</title>
				<para> Most applications have at least two languages in which the labels are
					defined. It is the native language and the English language. For each language
					that is defined in the applkication there should be a message defined. </para>
				<para> Common mistakes that are made by developers are in two categories: <itemizedlist>
					<listitem>
						<para> All text, or at least one of the languages is ommitted. For
							instance the Dutch text is defined, but the English message is
							missing. </para>
					</listitem>
					<listitem>
						<para> The messages are created in all languages, but the text are the
							same. For instance: Languages are Dutch and English. They both exist
							but the text in both languages is Dutch. The English text is Dutch
							as well. </para>
					</listitem>
				</itemizedlist>
				</para>
			</sect1>
			<sect1>
				<title>Removal of obsolete messages and labels</title>
				<para> Messages that are defined in the library but are not used should be removed. Messages can
					be used in : <itemizedlist>
						<listitem>
							<para> Formpaint </para>
						</listitem>
						<listitem>
							<para> Label properties of the conceptual fields </para>
						</listitem>
						<listitem>
							<para> Triggercode <itemizedlist>
									<listitem>
										<para> Include Procs </para>
									</listitem>
									<listitem>
										<para> Global Procs </para>
									</listitem>
									<listitem>
										<para> Conceptual Entity Triggers </para>
									</listitem>
									<listitem>
										<para> Conceptual Field Triggers </para>
									</listitem>
									<listitem>
										<para> Component Triggers </para>
									</listitem>
									<listitem>
										<para> Painted Entity Triggers </para>
									</listitem>
									<listitem>
										<para> Painted Field Triggers </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist></para>
			</sect1>
			<sect1>
				<title>Convert Global Procs to Include Procs</title>
				<para> ... </para>
			</sect1>
		</chapter>
		<chapter xml:id="legacy.model">
			<title>Maintaining the Application Model</title>
			<sect1>
				<title>Checking datatypes</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>validating relationships</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Moving Dummy entities to the model</title>
				<para> ... </para>
			</sect1>
		</chapter>
		<chapter xml:id="legacy.components">
			<title>Maintaining the Components</title>
			<sect1>
				<title>Replacing Runs by Activate</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Removing global variable for parameters</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Converting hidden forms to services</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Connecting templates to components</title>
				<para> ... </para>
			</sect1>
			<sect1>
				<title>Replacing hard coded XML tags to real XML interaction</title>
				<para> ... </para>
			</sect1>
		</chapter>
	</book>
	<book xml:id="environment_management">
		<title>Environment Management</title>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="environent.assignment">
			<info>
				<title>Assignment Files</title>
			</info>
			<para> ... </para>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="environent.ini_files">
			<info>
				<title>INI Files</title>
			</info>
			<para> ... </para>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="environent.setting_up">
			<info>
				<title>Setting up your own environment</title>
			</info>
			<sect1 xml:id="environent.setting_up.shortcuts">
				<title>Creating shortcuts</title>
				<para> ... </para>
			</sect1>
			<sect1 xml:id="environent.setting_up.asn_files">
				<title>Creating assignment files</title>
				<para> ... </para>
			</sect1>
			<sect1 xml:id="environent.setting_up.ini_files">
				<title>Creating an INI file</title>
				<para> ... </para>
			</sect1>
			<sect1 xml:id="environent.setting_up.folders">
				<title>Creating separate folders for your components</title>
				<para> ... </para>
			</sect1>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="environent.CI">
			<info>
				<title>Continuous Integration</title>
			</info>
			<sect1 xml:id="environent.CI.VCS">
				<title>Setting up a version control system</title>
				<para> ... </para>
			</sect1>
			<sect1 xml:id="environent.CI.jenkins">
				<title>Setting up Jenkins</title>
				<para> ... </para>
			</sect1>
			<sect1 xml:id="environent.CI.scrum">
				<title>Uniface and Scrum</title>
				<para> ... </para>
			</sect1>
			<sect1 xml:id="environent.CI.hot_deploy">
				<title>Hot deployment using Uniface</title>
				<sect2>
					<title>Getting Jenkins</title>
					<para> You can start by simply downloading Jenkins from the website <link
						xlink:href="http://jenkins-ci.org/">www.jenkins-ci.org/</link>. For this
						tutorial we assume that you are using a Windows installation. On the right
						hand side of the homepage we have downloaded the windows version under
						native package. In this case we downloaded version 1.451. </para>
				</sect2>
				<sect2>
					<title>Installing Jenkins</title>
					<para> Extract the zip file and doubleclick the MSI file. The installation as we
						did it was next --> next --> finish. In other words we did nothing out of
						the ordinary when installing the product. If your installation is succesful
						you will see a HTML pag on you screen that looks something like this:
					</para>
				</sect2>
			</sect1>
		</chapter>
	</book>
	<book xml:id="tutorials">
		<title>Tutorials</title>
		<chapter xml:id="tutorials.templates">
			<title>Creating Templates</title>
			<para> ... </para>
		</chapter>
		<chapter xml:id="tutorials.single_select">
			<title>One Single Select Screen</title>
			<para> ... </para>
		</chapter>
		<chapter xml:id="tutorials.generating">
			<title>Generating your application</title>
			<para> ... </para>
		</chapter>
	</book>
	
	<book xml:id="langref">
		<title>Language Reference</title>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="langref.gold">
			<info>
				<title>Gold Keys and Profiles</title>
			</info>
			<sect1 xml:id="langref.gold.subfield">
				<title>Subfield Separator</title>
				<para>
					<table>
						<title>Separator</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Example</entry>
									<entry>Name</entry>
									<entry>Result</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>[GOLD] + [;]</entry>
									<entry>List seperator</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>;]]></programlisting>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
				<para>
					<programlisting role="uniface"><![CDATA[entry CE_LIST
variables 
string v_list 
endvariables  
list = "item_1<gold>;item_2<gold>;item_3"
return(0)
end ; CE_MODULO]]></programlisting>
				</para>
			</sect1>
			<sect1 xml:id="langref.gold.profile">
				<title>Profile Characters</title>
				<para>
					<table>
						<title>Profile Characters</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Example</entry>
									<entry>Name</entry>
									<entry>Result</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>[GOLD] + [*]</entry>
									<entry>Match 0-n characters</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>*]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [?]</entry>
									<entry>Match any single characters</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>?]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [=]</entry>
									<entry>Is equal to</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>=]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [&gt;]</entry>
									<entry>Is greater than</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>>]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [&lt;]</entry>
									<entry>Is lesss than</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold><]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [!]</entry>
									<entry>Logical Not</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>!]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [&amp;]</entry>
									<entry>Logical And</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>&]]></programlisting>
									</entry>
								</row>
								<row>
									<entry>[GOLD] + [|]</entry>
									<entry>Logical Or</entry>
									<entry>
										<programlisting role="uniface"><![CDATA[<gold>|]]></programlisting>
									</entry>
								</row>
							</tbody>
						</tgroup>

					</table>
				</para>
			</sect1>
			<sect1 xml:id="langref.gold.keys">
				<title>Gold Keys</title>
				<para>
					<table>
						<title>Gold Keys</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Key Combination</entry>
									<entry>Structure Editor Function</entry>
									<entry>Result</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>[GOLD] + [SPACE]</entry>
									<entry>SUPER key.</entry>
								</row>
								<row>
									<entry>[GOLD] + [A]</entry>
									<entry><![CDATA[^ACCEPT]]></entry>
									<entry>Activate the Accept trigger for the current
										component.</entry>
								</row>
								<row>
									<entry>[GOLD] + [B]</entry>
									<entry>^BOLD</entry>
									<entry>Toggle the Bold character attribute.</entry>
								</row>
								<row>
									<entry>[GOLD] + [C]</entry>
									<entry>^MENU</entry>
									<entry>Activate a Menu trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [D]</entry>
									<entry>^DETAIL</entry>
									<entry>Activate a Detail trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [E]</entry>
									<entry>^ERASE</entry>
									<entry>Activate the Erase trigger for the current
										component.</entry>
								</row>
								<row>
									<entry>[GOLD] + [F]</entry>
									<entry>^FRAME</entry>
									<entry>Run the Define Frame form.</entry>
								</row>
								<row>
									<entry>[GOLD] + [G]</entry>
									<entry>^CLEAR</entry>
									<entry>Activate the Clear trigger for the component.</entry>
								</row>
								<row>
									<entry>[GOLD] + [H]</entry>
									<entry>^HELP</entry>
									<entry>Activate a Help trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [I]</entry>
									<entry>^ITALIC</entry>
									<entry>Toggle the Italic character attribute.</entry>
								</row>
								<row>
									<entry>[GOLD] + [J]</entry>
									<entry>^COMPOSE</entry>
									<entry>Start composing a character.</entry>
								</row>
								<row>
									<entry>[GOLD] + [K]</entry>
									<entry>^KEY_HELP</entry>
									<entry>Display the keyboard help message.</entry>
								</row>
								<row>
									<entry>[GOLD] + [L]</entry>
									<entry>^PULLDOWN</entry>
									<entry>Activate the menu bar.</entry>
								</row>
								<row>
									<entry>[GOLD] + [M]</entry>
									<entry>^MESSAGE</entry>
									<entry>Display the message frame.</entry>
								</row>
								<row>
									<entry>[GOLD] + [N]</entry>
									<entry>^RETRIEVE_SEQ</entry>
									<entry>Activate the Retrieve Sequential trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [O]</entry>
									<entry>^INS_OVER</entry>
									<entry>Toggle the Insert/Overstrike mode.</entry>
								</row>
								<row>
									<entry>[GOLD] + [P]</entry>
									<entry>^PRINT</entry>
									<entry>Activate the Print trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [Q]</entry>
									<entry>^QUIT</entry>
									<entry>Activate the Quit trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [R]</entry>
									<entry>^RETRIEVE</entry>
									<entry>Activate the Retrieve trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [S]</entry>
									<entry>^STORE</entry>
									<entry>Activate the Store trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [T]</entry>
									<entry>^RULER</entry>
									<entry>Start the Ruler form.</entry>
								</row>
								<row>
									<entry>[GOLD] + [U]</entry>
									<entry>^UNDERLINE</entry>
									<entry>Toggle the Underline character attribute.</entry>
								</row>
								<row>
									<entry>[GOLD] + [V]</entry>
									<entry>^VIEW</entry>
									<entry>Toggle the View mode.</entry>
								</row>
								<row>
									<entry>[GOLD] + [W]</entry>
									<entry>^SQL</entry>
									<entry>Run the SQL form.</entry>
								</row>
								<row>
									<entry>[GOLD] + [X]</entry>
									<entry>^ATTRIBUTE</entry>
									<entry>Toggle the session panel and tool bar.</entry>
								</row>
								<row>
									<entry>[GOLD] + [Y]</entry>
									<entry>^SWITCH_KEY</entry>
									<entry>Activate the Switch Keyboard trigger.</entry>
								</row>
								<row>
									<entry>[GOLD] + [Z]</entry>
									<entry>^ZOOM</entry>
									<entry>Zoom the current field incrementally.</entry>
								</row>
								<row>
									<entry>[GOLD] + [GOLD] + [Z]</entry>
									<entry> ^QUICK_ZOOM</entry>
									<entry>Zoom the current file to the maximum zoom size in one
										step.</entry>
								</row>
								<row>
									<entry>[GOLD] + [.]</entry>
									<entry> ^SELECT</entry>
									<entry>Select mode on.</entry>
								</row>
								<row>
									<entry>[GOLD] + [GOLD] + [.]</entry>
									<entry>^RESET_SELECT</entry>
									<entry>Select mode off.</entry>
								</row>
								<row>
									<entry>[GOLD] + [,]</entry>
									<entry> ^FIND_TEXT</entry>
									<entry>Search for the current profile.</entry>
								</row>
								<row>
									<entry>[GOLD] + [GOLD] + [,]</entry>
									<entry>^PROFILE</entry>
									<entry>Define a profile for the next ^FIND_TEXT.</entry>
								</row>
								<row>
									<entry>[GOLD] + [GOLD]</entry>
									<entry>(none)</entry>
									<entry>No action, that is, cancels the outstanding [GOLD] +
										request.</entry>
								</row>
								<row>
									<entry>INSERT DETAIL</entry>
									<entry>^INS_FILE</entry>
									<entry>Insert a file into the current field.</entry>
								</row>
								<row>
									<entry>REMOVE DETAIL</entry>
									<entry>^REM_FILE</entry>
									<entry>Remove the current field into a file.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
			</sect1>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="langref.precompiler">
			<info>
				<title>Precompiler Directives</title>
			</info>
			<sect1 xml:id="precompref.error">
				<title>#error</title>
				<para> Produce a compiler error message. #error Text Parameters Text—message text
					Description The directive #error causes the Proc compiler to generate an error
					message. The message Text appears in the message frame, and the error is added
					to the total for the module being compiled. The following example causes the
					Proc compiler to generate an error message if the compile-time constant
					MYCONSTANT has not been defined: #ifundefined MYCONSTANT #error The constant
					MYCONSTANT has not been defined. #endif </para>
			</sect1>
			<sect1 xml:id="precompref.for">
				<title>#for</title>
				<para> Generate blocks of repeated Proc code. </para>
				<para><![CDATA[
#for Item = (List) {, Counter} 
;... Proc statements and precompiler directives ... 
#endfor
]]> Parameters Item—constant that contains an item of List. List—list of items separated by commas
					or by spaces. Counter—constant containing a sequential number, starting with 0,
					identifying the position of item of Item in the List Both Item and Counter are
					defined only during processing of the #for block. Description The #for directive
					generates a repeating block of Proc code for each item in a list. In the
					following example, the compile-time constant <literal>MYLIST</literal> has been
					defined as A,B,C: <![CDATA[
#for ITEM = (<MYLIST>), COUNTER
message "Element <COUNTER> in the list is <ITEM>"
#endfor
]]> The Proc code generated by this #for block is: <![CDATA[
message "Element 0 in the list is A"
message "Element 1 in the list is B"
message "Element 2 in the list is C"
]]>
				</para>
			</sect1>
			<sect1 xml:id="precompref.if">
				<title>#if</title>
				<para> Generate Proc code conditionally. </para>
				<sect2>
					<title>Syntax</title>
					<programlisting role="uniface"><![CDATA[
#if ( Expression 1 ) 
... Proc statements and precompiler directives 
{#elseif ( Expression 2 ) 
... Proc statements and precompiler directives ... 
... } 
{#else 
... Proc statements and precompiler directives ... } 
#endif 
]]></programlisting>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Expression—logical expression that evaluates to true or false</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The #if directive generates Proc code conditionally based on the results
						of logical expressions. Each Expression is evaluated in sequence, beginning
						with the one with the #if statement. </para>
					<para>The Expression can contain one or more of the relational operators, = or
						!=, connected with the logical operators !, &amp;, and !. Parenthesis can be
						used to create nested expressions.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example adds a debug statement to the Proc code being
						compiled if the constant &lt;DEBUGGING&gt; is defined as 1: </para>
					<programlisting role="uniface"><![CDATA[#ifdefined DEBUGGING
   #if (&lt;DEBUGGING&gt;=1)
      debug
   #endif
#endif
]]></programlisting>
					<itemizedlist>
						<listitem>
							<para>If the constant &lt;DEBUGGING&gt; is not defined, no further code
								is generated. </para>
						</listitem>
						<listitem>
							<para>If the constant &lt;DEBUGGING&gt; is defined as 0, the #if
								directive is generated as follows:
								<programlisting role="uniface"><![CDATA[#if (1=0)
   debug
#endif]]></programlisting></para>
							<para>In this case, no Proc code is generated. </para>
						</listitem>
						<listitem>
							<para>If the constant &lt;DEBUGGING&gt; is defined as 1, the #if
								directive is generated as follows:
								<programlisting role="uniface"><![CDATA[#if (1=1)
   debug
#endif]]></programlisting></para>
							<para>In this case, the following Proc statement is compiled:
								<programlisting role="uniface"><![CDATA[debug]]></programlisting></para>
						</listitem>
					</itemizedlist>
				</sect2>
			</sect1>
			<sect1 xml:id="precompref.ifdefined ">
				<title>#ifdefined</title>
				<para> Test if a constant has been defined. </para>
				<sect2>
					<title>Syntax</title>
					<para> </para>
					<para>#ifdefined Constant </para>
					<para>... Proc statments and precompiler directives ... </para>
					<para>#endif </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Constant—constant name</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The #ifdefined directive can be used to create a block of Proc statements
						and precompiler directives whenever the constant specified already exists.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[#ifdefined DEBUGGING
   #if (&lt;DEBUGGING&gt;=1)
      debug
   #endif
#endif
]]></programlisting>
						<itemizedlist>
							<listitem>
								<para>If the constant &lt;DEBUGGING&gt; is not defined, no further
									code is generated. </para>
							</listitem>
							<listitem>
								<para>If the constant &lt;DEBUGGING&gt; is defined as 0, the #if
									directive is generated as follows:
									<programlisting role="uniface"><![CDATA[#if (1=0)
   debug
#endif]]></programlisting></para>
								<para>In this case, no Proc code is generated. </para>
							</listitem>
							<listitem>
								<para>If the constant &lt;DEBUGGING&gt; is defined as 1, the #if
									directive is generated as follows:
								</para>
<programlisting role="uniface"><![CDATA[#if (1=1)
debug
#endif]]></programlisting>
								<para>In this case, the following Proc statement is compiled:
									<programlisting role="uniface"><![CDATA[debug]]></programlisting>
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="precompref.include">
				<title>#include</title>
				<para> Copy the specified include Proc. </para>
				<sect2>
					<title>Syntax</title>
					<para>#include {Library:}Module </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Library—name of the library containing Module. If omitted, the
									library of the current component, global Proc, menu, and so on,
									is used, as appropriate. </para>
							</listitem>
							<listitem>
								<para>Module—name of an include Proc </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The #include directive copies the contents of the specified include Proc
						into the Proc code being generated. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> </para>
					<para>The component MYCOMP contains a component variable, $TRIG_TRACE$, that can
						be set dynamically at run time to turn trigger ‘tracing’ on and off.
						Whenever this variable is TRUE, a message is added to the message frame at
						the start of each trigger. </para>
					<para>Each trigger in MYCOMP begins with an #include directive referencing the
						include Proc START_TRIG in library MYLIB; for example: </para>
					<programlisting role="uniface"><![CDATA[#include MYLIB:START_TRIG]]></programlisting>
					<para>The include Proc START_TRIG in library MYLIB contains the following: </para>
					<programlisting role="uniface"><![CDATA[;Trigger: &lt;$TRIGGER&gt;
if ($TRIG_TRACE$)
   putmess "Entering trigger &lt;$TRIGGER&gt;"
endif]]></programlisting>
					<para>For a field-level Detail trigger, the precompiler hands the following Proc
						code to the compiler: </para>
					<programlisting role="uniface"><![CDATA[;Trigger: DTLF
if ($TRIG_TRACE$)
   putmess "Entering trigger DTLF"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="precompref.info">
				<title>#info</title>
				<para> Produce a compiler information message. </para>
				<sect2>
					<title>Syntax</title>
					<para>#info Text </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Text—compiler message text</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The #info directive causes the Proc compiler to generate an information
						message. The message Text appears in the message frame, and the information
						message is added to the total for the module being compiled. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example causes the Proc compiler to generate an information
						message if the compile-time constant &lt;MYCONSTANT&gt; has not been
						defined: </para>
					<programlisting role="uniface"><![CDATA[#ifundefined MYCONSTANT
   #info The constant MYCONSTANT has not been defined.
#endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="precompref.undefine">
				<title>#undefine</title>
				<para> Undefine a constant </para>
				<sect2>
					<title>Syntax</title>
					<para>#undefine Constant </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Constant—constant name</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The #undefine directive undefines the specified constant, making it
						unavailable during compilation for the current scope of the trigger.</para>
					<para>You can use #undefine to undefine a constant inherited from another
						object, for example, the application model or a component template.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following example undefines the constant MYCONSTANT, resulting in a
						warning during compilation if MYCONSTANT exists: </para>
					<programlisting role="uniface"><![CDATA[#undefine MYCONSTANT
#ifdefined MYCONSTANT
   #warning Constant MYCONSTANT exists
#endif]]></programlisting>
					<para>After compilation, no message will be generated.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="precompref.warning">
				<title>#warning</title>
				<para> Produce a compiler warning message. </para>
				<sect2>
					<title>Syntax</title>
					<para>#warning Text </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Text—message text</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The #warning directive causes the Proc compiler to generate a warning
						message. The message Text appears in the message frame, and the warning
						message is added to the total for the module being compiled. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example causes the Proc compiler to generate a warning
						message if the compile-time constant &lt;MYCONSTANT&gt; has not been
						defined: </para>
					<programlisting role="uniface"><![CDATA[#ifundefined MYCONSTANT
   #warning The constant MYCONSTANT has not been defined.
#endif]]></programlisting>
				</sect2>
			</sect1>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="langref.operators">
			<info>
				<title>Operators</title>
			</info>
			<sect1 xml:id="langref.operators.arithmatic">
				<title>Arithmatic Operators</title>
				<para>
					<table>
						<title>Operators</title>
						<tgroup cols="4">
							<thead>
								<row>
									<entry>Example</entry>
									<entry>Name</entry>
									<entry>Result</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>v_a * -1</entry>
									<entry>Negation</entry>
									<entry>Opposite of v_a</entry>
								</row>
								<row>
									<entry>v_a + v_b</entry>
									<entry>Addition</entry>
									<entry>Sum of v_a and v_b</entry>
								</row>
								<row>
									<entry>v_a - v_b</entry>
									<entry>Subtraction</entry>
									<entry>Difference of v_a and v_b</entry>
								</row>
								<row>
									<entry>v_a * v_b</entry>
									<entry>Multiplication</entry>
									<entry>Product of v_a and v_b</entry>
								</row>
								<row>
									<entry>v_a / v_b</entry>
									<entry>Division</entry>
									<entry>Quotient of v_a and v_b</entry>
								</row>
								<row>
									<entry>v_a % v_b</entry>
									<entry>\Modulus</entry>
									<entry>Remainder of v_a divided by v_b</entry>
								</row>
							</tbody>
						</tgroup>

					</table>
				</para>
				<para>
					<programlisting role="uniface"><![CDATA[entry CE_MODULO
variables 
numeric v_a
endvariables  
v_a = 5 % 3 ; v_a = 2
v_a = 5 % -3 ; v_a = 2
v_a = -5 % 3 ; v_a = -2
v_a = -5 % -3 ; v_a = -2
return(0)
end ; CE_MODULO]]></programlisting>
				</para>
				<para>
					<programlisting role="uniface"><![CDATA[entry CE_MATH
variables 
numeric v_a, v_b
endvariables 
debug 
v_a = 100  ;set 100 to v_a
v_a += 5   ; Addition v_a = 105
v_a -= 3   ; Subtraction v_a = 102
v_a *= 3   ; Multiplication v_a = 306
v_a /= 3   ; Division v_a = 102 again
v_a %= 3   ; modulo v_a = 0 no remainder
return(0)
end ; CE_MATH]]></programlisting>
				</para>
			</sect1>
			<sect1 xml:id="langref.operators.logical">
				<title>Logical Operators</title>
				<para>
					<table>
						<title>Logical Operators</title>
						<tgroup cols="4">
							<thead>
								<row>
									<entry>Example</entry>
									<entry>Name</entry>
									<entry>Result</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>v_a &amp; v_b</entry>
									<entry>And</entry>
									<entry>TRUE if both v_a and v_b are TRUE.</entry>
								</row>
								<row>
									<entry>v_a | v_b</entry>
									<entry>Or</entry>
									<entry>TRUE if either v_a or v_b is TRUE.</entry>
								</row>
								<row>
									<entry>v_a &gt; v_b</entry>
									<entry>Larger then</entry>
									<entry>TRUE if v_a is larger than v_b.</entry>
								</row>
								<row>
									<entry>v_a &lt; v_b</entry>
									<entry>Littler then</entry>
									<entry>TRUE if v_a is litler than v_b.</entry>
								</row>
								<row>
									<entry>v_a != v_b</entry>
									<entry>Not equal</entry>
									<entry>TRUE if v_a is not equal v_b.</entry>
								</row>
							</tbody>
						</tgroup>

					</table>
				</para>
			</sect1>
			<sect1 xml:id="langref.operators.string">
				<title>String Operators</title>
				<para>
					<table>
						<title>String Operators</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Example</entry>
									<entry>Name</entry>
									<entry>Result</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>%%^</entry>
									<entry>Enf of line character</entry>
									<entry/>
								</row>
								<row>
									<entry>%%"</entry>
									<entry>Double Quote</entry>
									<entry/>
								</row>
								<row>
									<entry>
										<programlisting role="uniface"><![CDATA[if (v_a = 1 %\
v_b =1)]]></programlisting>
									</entry>
									<entry>Line Continuator</entry>
									<entry/>
								</row>
								<row>
									<entry>"%%v_a%%%"</entry>
									<entry>String Substitution</entry>
									<entry/>
								</row>
							</tbody>
						</tgroup>

					</table>
				</para>
			</sect1>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="langref.datatypes">
			<info>
				<title>Datatypes</title>
			</info>
			<para>...</para>
		</chapter>
		<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
			xml:id="langref.procs">
			<info>
				<title>Procs</title>
			</info>
			<sect1 xml:id="langref.dollar_about">
				<title>$about</title>
				<para> Introduced in: U9 </para>
				<para>Returns information about the current Uniface installation, version, and
					platform. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$about</command>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Information Returned by $about</title>
							<tgroup cols="3">
								<thead>
									<row>

										<entry> Property</entry>
										<entry> Description</entry>
										<entry> Example</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> tag </entry>
										<entry> Not used</entry>
										<entry> N/A</entry>
									</row>
									<row>
										<entry> update </entry>
										<entry> Not used</entry>
										<entry> N/A</entry>
									</row>
									<row>
										<entry> track </entry>
										<entry> Full Uniface version number, including the build
											identifier </entry>
										<entry> 9.2.01.01 </entry>
									</row>
									<row>
										<entry> date </entry>
										<entry> Build date</entry>
										<entry> October 04, 2007 </entry>
									</row>
									<row>
										<entry> config </entry>
										<entry> Build configuration identifier</entry>
										<entry> 1004_1 </entry>
									</row>
									<row>
										<entry> platform </entry>
										<entry> Platform compatiblity code, such as WXP, LI9, or
											AS2. For details, see the <link
												xlink:href="http://http://frontline.compuware.com/products/uf/tech/15617.aspx"
												>Platform Availablity Matrix</link> published on
												<link
												xlink:href="http://frontline.compuware.com/products/UF/"
												>Frontline Uniface</link>. </entry>
										<entry> WXP </entry>
									</row>
									<row>
										<entry> version </entry>
										<entry> Uniface version number</entry>
										<entry> 9.2.01 </entry>
									</row>
								</tbody>
							</tgroup>

						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> All components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The $about function returns an associative list of properties and their
						values, which describe the current Uniface installation. You can include
						this information in an About dialog, commonly available from the Help menu
						of most applications. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following code displays an information dialog with the Uniface
						version, build, and date. <programlisting role="uniface"><![CDATA[;Detail trigger
variables
string vVersion
string vBuild
string vBuildDate
endvariables
getitem/id vVersion $about "version"
getitem/id vBuild $about "config"
getitem/id vBuildDate $about "date"
askmess/info "Uniface version: %%vVersion%%% (%%vBuild%%%) %%^Date: %%vBuildDate%%%", "OK"]]></programlisting></para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_abs">
				<title>$abs</title>
				<para> Introduced in: U8 </para>
				<para>
					<programlisting role="uniface"><![CDATA[variables 
numeric v_abs
endvariables
; v_abs will contain 312.22
v_abs = $abs(-312.22)]]></programlisting>
				</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$abs</command> ( <constant>X</constant> ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Absolute value of X. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the absolute value of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$ABSOF$ = $abs(ANUMBER - 100)]]></programlisting>
					<para>If the value of ANUMBER is 25, the value stored in $ABSOF$ is 75. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_acos">
				<title>$acos</title>
				<para> Introduced in: U8 </para>
				<para> Values of X must be between 1 and -1 </para>
				<para>
					<programlisting role="uniface"><![CDATA[variables 
   numeric v_acos
endvariables
; v_abs will contain 1.04719755119659774615421446109316762806
v_acos = $acos(0.5)]]></programlisting>
				</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> X—numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. X must
						be in the range -1 through 1, inclusive. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Calculated arc cosine value. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$acos</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1203 </entry>
									<entry>&lt;UPROCERR_RANGE&gt; </entry>
									<entry> Value out of range. </entry>
								</row>
							</tbody>
						</tgroup>

					</table>

				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The $acos function calculates the arc cosine of X, that is, it returns
						that angle, in radians, whose cosine (see $cos) is X. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following example returns the arc cosine of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$ARCOSIN$ = $acos(1 / 2) ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_applname">
				<title>$applname</title>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$applname</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>String that contains the name of the current start-up shell (in
								uppercase). </para>
						</listitem>
						<listitem>
							<para>Name of its application server, if component is remote (that is, a
								service, session service, entity service or report running on a
								server) . </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The name is returned with uppercase letters, so this name is not
						necessarily the same as the application name seen by the operating system.
						For example, applications built on a Unix platform are created in lowercase,
						but $applname returns the Uniface application name, which is in uppercase. </para>
					<para>One use for $applname could be to restrict the use of a global Proc to
						certain (named) applications; a test on the value of $applname at the start
						of the Proc module could prevent use of the module by returning immediately.
						If you distribute only the object code for your global Proc (in UAR files
						containing <emphasis role="bold">\prc\*.prc </emphasis>, for example) and
						not the source, you can use this technique to prevent unauthorized use of
						the global Proc. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example outputs an initial message and a final message when
						the start-up shell BOOK is run: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Application Execute
putmess "Started application %%$applname at %%$clock"
run "MAIN_MENU"
putmess "Terminated application %%$applname at %%$clock"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_applproperties">
				<title>$applproperties</title>
				<para> Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$applproperties</command> ( ) = Properties </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<itemizedlist>
						<listitem>
							<para>Properties—associative list of properties and their values </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Properties set by $applproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Property</entry>
									<entry> Physical Property Name</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Background Color </entry>
									<entry> BackColor </entry>
									<entry> Background color of the window.</entry>
								</row>
								<row>
									<entry> Background Image </entry>
									<entry> BackImage </entry>
									<entry> Background image of the window. </entry>
								</row>
								<row>
									<entry> Caption </entry>
									<entry> Title </entry>
									<entry> Specify whether a title bar is displayed at the top of
										the window at run time. </entry>
								</row>
								<row>
									<entry> Resizable </entry>
									<entry> CanResize </entry>
									<entry> Specify whether the application window can be resized at
										run time.</entry>
								</row>
								<row>
									<entry> Horizontal Alignment </entry>
									<entry> HAlign </entry>
									<entry> Horizontal alignment of the background image</entry>
								</row>
								<row>
									<entry> Horizontal Image Scaling </entry>
									<entry> HScale </entry>
									<entry> Horizontal scaling of the background image</entry>
								</row>
								<row>
									<entry> Vertical Alignment </entry>
									<entry> VAlign </entry>
									<entry> Vertical alignment of background image</entry>
								</row>
								<row>
									<entry> Vertical Image Scaling </entry>
									<entry> VScale </entry>
									<entry> Vertical scaling of background image</entry>
								</row>
								<row>
									<entry> Preserve Aspect Ratio </entry>
									<entry> PreserveAspect </entry>
									<entry> Specify whether to preserve the aspect ratio of the
										background image at all times.</entry>
								</row>
							</tbody>
						</tgroup>

					</table>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> $applproperties returns the requested property and value. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in startup shells. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Setting properties using $applproperties overrides the values set in the
						initialization file with the SHELL or values set in the startup shell
						definition in the Development Environment.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<programlisting role="uniface"><![CDATA[$applproperties() = "backimage=^LOGO"]]></programlisting>
					<programlisting role="uniface"><![CDATA[$applproperties() = "backimage=@logo.jpg<emphasis role="underline">;</emphasis>"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.ollar_appltitle">
				<title>$appltitle</title>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$appltitle</command>
					</para>
					<para>
						<command>$appltitle</command> = ApplTitle </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> ApplTitle—new title for the application window; can be a string, or a
						field (or indirect reference to a field), a variable, or a function that
						evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Title of the application window. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in application start-up shells and in form components (and in
						service and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $appltitle function has effect only when the application is using a
						GUI driver. Changing $appltitle overrides the value defined in the
						GUI-specific settings. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> ...
						<programlisting role="uniface"><![CDATA[; Place your code here ]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_asin">
				<title>$asin</title>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$asin</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> X—numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. X must
						be in the range -1 through 1, inclusive. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Calculated arc sine value. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error.</para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$asin</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1203 </entry>
									<entry> &lt;UPROCERR_RANGE&gt; </entry>
									<entry> Value out of range. </entry>
								</row>
							</tbody>
						</tgroup>

					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $asin calculates the arc sine of X, that is, it returns that
						angle, in radians, whose sine ($sin) is X. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the arc sine of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$ARCSIN$ = $asin(1 / 2)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_atan">
				<title>$atan</title>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$atan</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> X—numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Calculated arc tangent value. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $atan function calculates the arc tangent of X, that is, it returns
						that angle, in radians, whose tangent ($tan) is X. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the arc tangent of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$ARCTAN$ = $atan(1 / 2)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.ollar_batch">
				<title>$batch</title>
				<para> Return or set the batch mode indicator. </para>
				<sect2>
					<title>Syntax</title>
					<para>$batch </para>
					<para>$batch = Expression </para>
					<para>set | reset $batch </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Expression—Proc expression. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Return Values</title>
							<tgroup cols="2">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 1 </entry>
										<entry> Uniface is in a batch process</entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> Uniface is <emphasis role="italic">not </emphasis>in
											a batch process</entry>
									</row>
									<row>
										<entry> &lt;0 </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
								</tbody>
							</tgroup>

						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use $batch to test whether Uniface is in a batch process. Anything which
						requires keyboard input or screen output (an askmess or edit statement, for
						example) cannot be used in batch mode. Attempting to do this may crash the
						application. </para>
					<para>It is sometimes useful to test whether Uniface is operating in batch mode.
						For example, if a form is designed both for reports (batch mode printing)
						and for interactive use, you need to be able to test whether Uniface is
						printing in batch mode before using certain Proc code. In these situations,
						you can use the following construction to execute the statements that are
						for interactive use only: </para>
					<programlisting role="uniface"><![CDATA[if (!$batch) ;running interactively
...
endif
]]></programlisting>
					<para>
						<emphasis role="bold"> Note:</emphasis> The putmess statement in batch mode
						writes the message directly to the terminal or batch log file, depending on
						your operating system settings. </para>
				</sect2>
				<sect2>
					<title>Changing the value of $batch</title>
					<para>You can also use $batch as the target in the left-hand side of an
						assignment, for example: </para>
					<programlisting role="uniface"><![CDATA[$batch=!$batch ]]></programlisting>
					<para>Since $batch is essentially a Boolean function, when Expression evaluates
						to a nonzero value, $batch becomes 1. </para>
				</sect2>
				<sect2>
					<title>3GL and $batch</title>
					<para> The Uniface 3GL function UNIFBEG sets the value of $batch. When UNIFBEG
						starts an interactive session, $batch is set to 0; when UNIFBEG starts a
						batch session, $batch is set to 1. For more information, see unifbeg.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The Proc code in the following example first checks whether the
						application is running in batch mode. If it is, a message is written to the
						message frame to record the number of pages just printed. If the application
						is not running in batch mode, the user is asked if they want to leave the
						application or return to the main menu. </para>
					<programlisting role="uniface"><![CDATA[if ($batch = 1)
   putmess "%%$page pages sent to printer at %%$clock"
   exit(0)
else
   askmess "Return to Main menu or Quit? (M/Q)","M,Q"
   if ($status = 1)
      exit "mainmenu"
   else
      apexit
   endif
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_bold">
				<title>$bold</title>
				<para> Introduced in: U9 </para>
				<para>Return the result of applying the bold character attribute to a string.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$batch</command> ( <parameter>String</parameter>) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para> String—A string, or a field (or indirect reference to a field), a
						variable, or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> The function $bold returns the result of applying the bold character
						attribute to String </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types, but only applicable to unifields.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $bold returns the result of applying the bold character
						attribute to String. The result is visible only in a displayed
						unifield.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following example shows the result of applying $bold to a string and
						storing it in a unifield: </para>
					<programlisting role="uniface"><![CDATA[MY_UNIFIELD = $bold("aaabbb")]]></programlisting>
					<para>Afterwards, MY_UNIFIELD contains "aaabbb". </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_cellinfo">
				<title>$cellinfo</title>
				<para>Get an associative list with the dimensions of a character cell in
					pixels.</para>
				<para>Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$cellinfo</command>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Returns an associative list with the height (xsize) and width (ysize) in
						pixels of a character cell as displayed on the screen. The dimensions are
						determined by the font0 setting in [SCREEN] section of <emphasis role="bold"
							>usys.ini</emphasis>.</para>
					<para>xsize= Pixels <emphasis role="underline">;</emphasis> ysize= Pixels </para>
					<para>An empty string is returned when the function is used in batch mode or in
						a non-interactive Windows environment.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Use only in form components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$cellinfo returns the dimensions of single cell as determined by the font0
						setting in [SCREEN] section of <emphasis role="bold">usys.ini</emphasis>.
						These dimensions can be used as input for $windowproperties to adjust the
						size of the window.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_char">
				<title>$char</title>
				<para>In a unifield, return the Uniface character code for the key that activated a
					trigger. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$char</command>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Code for the character or function chosen by the user which
									activated a trigger. </para>
							</listitem>
							<listitem>
								<para>In the User Key trigger, $char contains the ^USER_KEY
									identifier character code. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>In a unifield, the function $char returns the last Uniface character or
						function (in decimal format) which activated a trigger. It is most commonly
						used with the Start Modification and User Key triggers, but can be used with
						all triggers. </para>
					<para>Note: The function $char is available only in unifields. Its value in
						another widget cannot be predicted. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, Proc code in the Start Modification trigger
						checks $char to see if the user entered the letter 'Y' into the field. If
						that was the modification, the Proc module ends and the user can continue.
						If the user entered any other letter, the code sets $status to -1, causing
						the modification to be discarded. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Start Modification
if (($char = 89) | ($char = 121))
return
else
message "This field may only be set to ’Y’!"
return (-1)
endif]]></programlisting>
					<para>The kind of value checking shown in the previous example can also be
						achieved by using a declarative entry format for the field, for example,
						ENT(y) . However, entry formats are only checked when the user leaves the
						field. The Start Modification trigger is activated the moment the user
						enters data. Proc code in this trigger can only check the first character
						the user has entered, so it cannot be used to enforce an entry format of
						ENT((yes)(no)). </para>
					<para>The following example puts the structure editor into Zoom mode and inserts
						a salutation when the user enters a capital D ($char="D" ): </para>
					<programlisting role="uniface"><![CDATA[; trigger: Start Modification
if ($char = 68) ; "D"
if (GENDER = "M")
$1 = "Mr."
else
$1 = "Ms."
endif
macro "^127^096ear %%$1 %%SURNAME, ^CURSOR_RIGHT"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_check">
				<title>$check</title>
				<para>Return or set the checked status of a menu item. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$check</command></para>
					<para> $check = Expression </para>
					<para>set | reset $check </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Return Values</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1</entry>
									<entry> Menu item is checked</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Menu item is not checked</entry>
								</row>
							</tbody>
						</tgroup>

					</table>
					<para>In an error occurs, $procerror contains the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Predisplay trigger of form components (and in service,
						session service, entity service, and report components that are not
						self-contained), . </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $check function determines whether a check mark appears next to the
						current menu item. The value of $check does not affect the menu accelerator
						for that menu item. </para>
					<para>
						<emphasis role="bold">Note:</emphasis> You can only use this function in the
						Predisplay trigger. </para>
					<para> You can also use $check as the target in the left-hand side of an
						assignment, for example: </para>
					<programlisting role="uniface"><![CDATA[$check=!$check ]]></programlisting>
					<para>Since $check is essentially a Boolean function, when Expression evaluates
						to a nonzero value, $check becomes 1. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example displays a check mark next to a menu item: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Predisplay
set $check ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_clock">
				<title>$clock</title>
				<para>Return the system time or convert the argument to the Time data type. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$clock</command> {( Source )}</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Source—string, a field, or a variable. If the value of Source is numeric,
						it is first converted to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>Used without Source, $clock returns a string containing the system
								clock time as 00000000hhnnsstt that is accurate to one hundredth of
								a second (1 tick). </para>
							<para>If a service or report component is running in a remote
								environment, $clock returns the system time of the server (not of
								the client). </para>
						</listitem>
						<listitem>
							<para>Used with Source, $clock returns the value as a time data type
								value (which does not include ticks). </para>
						</listitem>
						<listitem>
							<para>If Source contains characters that are not valid or if any of the
								parts of the time (hours, minutes, or seconds) are not in the
								appropriate range, $clock returns an empty string (""). (For
								example, both $clock("A") and $clock("240000") return an empty
								string.) </para>
						</listitem>
						<listitem>
							<para>If an error occurs, $procerror contains a negative value that
								identifies the exact error. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>You can use $clock to assign the current system time to fields in header
						or trailer frames (using data type Time, for example) or to put a timestamp
						on occurrences (using data type String, for example). </para>
				</sect2>
				<sect2>
					<title>Using $clock with Source</title>
					<para>$clock can be used with the Source argument when you are loading ASCII
						text files into a database and you have to convert time data stored as text
						into a field stored as Time. </para>
					<para>When using $clock with Source:</para>
					<itemizedlist>
						<listitem>
							<para>If Source is formatted with one or two colons (:) used as
								separators (for example, hh : nn or hh : nn : ss), $clock converts
								Source to a time without considering the length of <emphasis
									role="italic">Source</emphasis>. </para>
							<para>If <emphasis role="italic">Source</emphasis> only contains one
								separator, it is interpreted as hh : nn. </para>
						</listitem>
						<listitem>
							<para>If Source is a free-format number, with no colon separators
								included, $clock uses the number of digits in Source to determine
								the way Source is converted into a Time. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Converting strings to time with $clock</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Number of digits </entry>
									<entry> Interpreted as </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry>
										<emphasis role="italic">h </emphasis></entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry>
										<emphasis role="italic">hh </emphasis></entry>
								</row>
								<row>
									<entry> 3 </entry>
									<entry>
										<emphasis role="italic">h </emphasis>: <emphasis
											role="italic">nn </emphasis></entry>
								</row>
								<row>
									<entry> 4 </entry>
									<entry>
										<emphasis role="italic">hh </emphasis>: <emphasis
											role="italic">nn </emphasis></entry>
								</row>
								<row>
									<entry> 5 </entry>
									<entry>
										<emphasis role="italic">h </emphasis>: <emphasis
											role="italic">nn </emphasis>: <emphasis role="italic">ss
										</emphasis></entry>
								</row>
								<row>
									<entry> 6 </entry>
									<entry>
										<emphasis role="italic">hh </emphasis>: <emphasis
											role="italic">nn </emphasis>: <emphasis role="italic">ss
										</emphasis></entry>
								</row>
								<row>
									<entry> &gt;6 </entry>
									<entry> NULL </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The following table shows the different values returned by $clock,
						$number, and $clock($number), depending on the length of the <emphasis
							role="italic">Source </emphasis>operand: </para>
					<table>
						<title>Table 2. Examples of values returned by $clock, $number, and
							$clock($number)</title>
						<tgroup cols="4">
							<thead>
								<row>
									<entry> $1 </entry>
									<entry> $clock($1) </entry>
									<entry> $number($1) </entry>
									<entry> $clock($number($1)) </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "00:2:" </entry>
									<entry> 00:02:00 </entry>
									<entry> 0 </entry>
									<entry> 00:00:00 </entry>
								</row>
								<row>
									<entry> "2" </entry>
									<entry> 02:00:00 </entry>
									<entry> 2 </entry>
									<entry> 02:00:00 </entry>
								</row>
								<row>
									<entry> "02" </entry>
									<entry> 02:00:00 </entry>
									<entry> 2 </entry>
									<entry> 02:00:00 </entry>
								</row>
								<row>
									<entry> 002" </entry>
									<entry> 00:02:00 </entry>
									<entry> 2 </entry>
									<entry> 02:00:00 </entry>
								</row>
								<row>
									<entry> "0002" </entry>
									<entry> 00:02:00 </entry>
									<entry> 2 </entry>
									<entry> 02:00:00 </entry>
								</row>
								<row>
									<entry> "00002" </entry>
									<entry> 00:00:02 </entry>
									<entry> 2 </entry>
									<entry> 02:00:00 </entry>
								</row>
								<row>
									<entry> "102" </entry>
									<entry> 01:02:00 </entry>
									<entry> 102 </entry>
									<entry> 01:02:00 </entry>
								</row>
								<row>
									<entry> "1002" </entry>
									<entry> 10:02:00 </entry>
									<entry> 1002 </entry>
									<entry> 10:02:00 </entry>
								</row>
								<row>
									<entry> "10002" </entry>
									<entry> 01:00:02 </entry>
									<entry> 10002 </entry>
									<entry> 01:00:02 </entry>
								</row>
								<row>
									<entry> "111002" </entry>
									<entry> 11:10:02 </entry>
									<entry> 111002 </entry>
									<entry> 11:10:02 </entry>
								</row>
								<row>
									<entry> "999002" </entry>
									<entry> NULL </entry>
									<entry> 999002 </entry>
									<entry> NULL </entry>
								</row>
								<row>
									<entry> "240000" </entry>
									<entry> NULL </entry>
									<entry> 240000 </entry>
									<entry> NULL </entry>
								</row>
								<row>
									<entry> "2400" </entry>
									<entry> NULL </entry>
									<entry> 2400 </entry>
									<entry> NULL </entry>
								</row>
								<row>
									<entry> "235959" </entry>
									<entry> 23:59:59 </entry>
									<entry> 235959 </entry>
									<entry> 23:59:59 </entry>
								</row>
								<row>
									<entry> "1" </entry>
									<entry> 01:00:00 </entry>
									<entry> 1 </entry>
									<entry> 01:00:00 </entry>
								</row>
								<row>
									<entry> "02" </entry>
									<entry> 02:00:00 </entry>
									<entry> 2 </entry>
									<entry> 02:00:00 </entry>
								</row>
								<row>
									<entry> "003" </entry>
									<entry> 00:03:00 </entry>
									<entry> 3 </entry>
									<entry> 03:00:00 </entry>
								</row>
								<row>
									<entry> "0004" </entry>
									<entry> 00:04:00 </entry>
									<entry> 4 </entry>
									<entry> 04:00:00 </entry>
								</row>
								<row>
									<entry> "00005" </entry>
									<entry> 00:00:05 </entry>
									<entry> 5 </entry>
									<entry> 05:00:00 </entry>
								</row>
								<row>
									<entry> "000006" </entry>
									<entry> 00:00:06 </entry>
									<entry> 6 </entry>
									<entry> 06:00:00 </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Using $clock to Convert Text Data</title>
					<para>When loading free-format time data from an ASCII text file, use a global
						or component variable defined as data type String. Define the layout for the
						variable as either DIS(999999) for hhnnss data, or DIS(9999) for hhnn data,
						then copy the data into this variable. Use $clock on the variable to convert
						the numeric string to a Time. </para>
					<para>When loading text data, you should ensure that the date is correctly
						converted. Ensuring correct conversion depends on the way the source text is
						stored. If the data is completely raw (that is, it contains no separators,
						and has leading spaces, such as " 412"), declare a Numeric global or
						component variable with DIS(999999), and copy the data into it. This ensures
						the correct number of digits for hhnnss, since leading blanks are converted
						to leading zeros. </para>
					<para>If, however, the data is partially formatted (such as ‘2:3:12’), you must
						declare a String global or component variable, because a Numeric variable
						only accepts digits before the first colon (:) (the first ‘2’ in ‘2:3:12’).
						A layout is not required for this type of variable. Copy the data into the
						variable, then use $clock to convert the data in the variable into a time.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example assigns the current system time to the field
						REPORTTIME.HEADER: </para>
					<programlisting role="uniface"><![CDATA[REPORTTIME.HEADER = $clock ]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Converting Raw or Formatted Data into Time Data</title>
					<para> The following example shows a global Proc that converts raw or formatted
						data into actual time data. This Proc converts a free format text field into
						a time field. It uses a numeric or string global variable, depending on
						whether the data is formatted or not. </para>
					<programlisting role="uniface"><![CDATA[; Uses: 
; $1 - source 
; $2 - result, as a time 
; $$STRING_TIME - global variable, string 
; $$NUMBER_TIME - global variable, number, dis(999999)  
scan $1,’:’ ;is $1 formatted ? 
if ($result &gt; 0) ; $1 contains a ’:’ 
  $$STRING_TIME = $1 ;keep format 
  $2 = $clock($$STRING_TIME) ;convert to time using formatted data 
else ;$1 does not contain a ’:’ 
  $$NUMBER_TIME = $1 ;$1 is raw text data, so force leading zeros 
  $2 = $clock($$NUMBER_TIME) ;convert six digit number to time endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_collhandle">
				<title>$collhandle</title>
				<para>Return the handle of the specified entity. </para>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$collhandle</command> ({Entity})</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>Handle of the specified entity. </para>
						</listitem>
						<listitem>
							<para>NULL handle if an error occurs, or in the following circumstances: <itemizedlist>
									<listitem>
										<para>Entity is an incorrect entity. </para>
									</listitem>
									<listitem>
										<para>No occurrence for the given entity with the name
											Entity. </para>
									</listitem>
									<listitem>
										<para>No public operations defined for the entity. If there
											are no public operations, no signature can be created
											for it. Without a signature, no handle can be returned;
											instead a NULL value is returned. </para>
									</listitem>
								</itemizedlist></para>
							<para>If an error occurs, $procerror contains a negative value that
								identifies the exact error. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$collhandle</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> UPROCERR_ENTITY </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_componentinfo">
				<title>$componentinfo</title>
				<para>Return information about a component instance. </para>
				<para>Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>$componentinfo ( InstName , TopicName ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>InstName—name of the component instance; can be string, or a
									variable, function, or parameter, or indirect reference to a
									field, that evaluates to a string. </para>
							</listitem>
							<listitem>
								<para>TopicName—keyword expressed as a string, or a field (or
									indirect reference to a field), a variable, or a function that
									evaluates to a string. The topic name is not case-sensitive; you
									can use uppercase or lowercase letters, or any combination of
									these, to increase readability. Valid names are: <itemizedlist>
										<listitem>
											<para>"VARIABLES"—list component variables for the
												specified component instance </para>
										</listitem>
										<listitem>
											<para>"OUTERENTITIES"—list the names of outer entities
												of the specified component instance </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns a list as specified by the TopicName. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$componentinfo</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1105 </entry>
									<entry> UPROCERR_INSTANCE </entry>
									<entry> The instance name provided is not valid.</entry>
								</row>
								<row>
									<entry> -1110 </entry>
									<entry> UPROCERR_TOPIC </entry>
									<entry> Topic name not known. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The following examples show how you can specify the instance name:</para>
					<itemizedlist>
						<listitem>
							<para>Null string: $componentinfo("","VARIABLES"), in which case the
								name of the current instance is used. </para>
						</listitem>
						<listitem>
							<para>String that contains the name of an instance in the component
								pool: </para>
							<para>$componentinfo("MYINSTANCE","VARIABLES") </para>
						</listitem>
						<listitem>
							<para>Variable , where $1 contains "MYINSTANCE": </para>
							<para>$componentinfo($1,"VARIABLES"). </para>
						</listitem>
						<listitem>
							<para>Function, where $instancename is "MYINSTANCE":
								$componentinfo($instancename,"VARIABLES"). </para>
						</listitem>
						<listitem>
							<para>Parameter, where PARAM1 contains "MYINSTANCE": </para>
							<para>$componentinfo(PARAM1,"VARIABLES") </para>
						</listitem>
						<listitem>
							<para>Indirect reference to a field, where the target field evaluates to
								a string that contains the name of a component instance: </para>
							<para>$componentinfo(@$1,"VARIABLES"), where $1 contains "FLD1" and FLD1
								contains "MYINSTANCE" </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_componentname">
				<title>$componentname</title>
				<para>Return the name of the component from which the specified instance was
					created. </para>
				<sect2>
					<title>Syntax</title>
					<para> $componentname{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> InstName—name of the component instance; can be a string, or a variable,
						function, parameter or indirect refererence to a field containing the name.
						If omitted, the current instance is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Name of the component from which the specified instance was created, in
						uppercase. An empty string ("") is returned if an error occurred. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$componentname</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -57 </entry>
									<entry> UACTERR_NO_INSTANCE </entry>
									<entry> The named instance cannot be found in the component
										pool. </entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
								<row>
									<entry> -1105 </entry>
									<entry> UPROCERR_INSTANCE </entry>
									<entry> The instance name provided is not valid (See newinstance
										for more information.) For example, the argument contains
										incorrect characters. </entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> UPROCERR_UNKNOWN_CONTEXT&gt;</entry>
									<entry> Function not allowed, unknown context. The InstName
										argument was omitted and no instance is current, for
										example, in the Application Execute trigger. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>Example: Tracing Application Execution You can use the value in
						$instancename to help trace an application's execution. For example: trigger
						_EXEC putmess "Started instance %%$instancename at %%$clock" edit putmess
						"Terminated instance %%$instancename at %%$clock" end ; end trigger </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_componenttype">
				<title>$componenttype</title>
				<para>Return the type of the specified component instance. </para>
				<sect2>
					<title>Syntax</title>
					<para> $componenttype{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> InstName—name of the component instance; can be a string, or variable,
						function, parameter, or indirect reference to a field that evaluates to a
						string. If omitted, the current instance is used. If no instance is current,
						for example, in the Application Execute trigger, the returned type indicates
						that the instance is the application's start-up shell. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $componenttype </title>
							<tgroup cols="2">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> F </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from a form component. </entry>
									</row>
									<row>
										<entry> R </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from a report component. </entry>
									</row>
									<row>
										<entry> D </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from a dynamic server page component </entry>
									</row>
									<row>
										<entry> P </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from a static server page component </entry>
									</row>
									<row>
										<entry> S </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from a service component. </entry>
									</row>
									<row>
										<entry> E </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from an entity service component </entry>
									</row>
									<row>
										<entry> N </entry>
										<entry>
											<emphasis role="italic">InstName </emphasis>was created
											from a session service component </entry>
									</row>
									<row>
										<entry> A </entry>
										<entry> The <emphasis role="italic">InstName
											</emphasis>argument was omitted and no instance is
											current, for example, in the Application Execute
											trigger. </entry>
									</row>
									<row>
										<entry> An empty string ("") </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$componenttype</title>
							<tgroup cols="3">
								<thead>

									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE</entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> UPROCERR_FIELD</entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1105 </entry>
										<entry> &lt;UPROCERR_INSTANCE </entry>
										<entry> The instance name provided is not valid; for
											example, the argument contains incorrect characters.
										</entry>
									</row>
									<row>
										<entry> -1304 </entry>
										<entry> UPROCERR_UNKNOWN_CONTEXT </entry>
										<entry> Function not allowed, unknown context. The <emphasis
												role="italic">InstName</emphasis> argument was
											omitted and no instance is current, for example, in the
											Application Execute trigger. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The InstName can be any of the following: </para>
					<itemizedlist>
						<listitem>
							<para>String: $componenttype("MYINSTANCE"). </para>
						</listitem>
						<listitem>
							<para>Variable, , where $1 contains "MYINSTANCE": </para>
							<para>$componenttype($1). </para>
						</listitem>
						<listitem>
							<para>Function, where $entname is "MYINSTANCE" </para>
							<para>$componenttype($entname),. </para>
						</listitem>
						<listitem>
							<para>Parameter, , where PARAM1 contains "MYINSTANCE": </para>
							<para>$componenttype(PARAM1). </para>
						</listitem>
						<listitem>
							<para>Indirect reference to a field, where the target field evaluates to
								a string that contains the name of an instance: </para>
							<para>$componenttype(@$1), where $1 contains "FLD1" and FLD1 contains
								"MYINSTANCE". </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example writes a message to the message frame that indicates
						the type of the component from which the current instance was created: </para>
					<programlisting role="uniface"><![CDATA[getitem/id $COMPTYPE$, "F=form;S=service;R=report;=unknown", $componenttype
if ($componenttype = "A")
   putmess "Start-up shell is %%$applname"
else
   putmess "Current instance is from a %%$COMPTYPE$" named %%$componentname"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_concat">
				<title>$concat</title>
				<para> Introduced in: U8 </para>
				<para>Concatenate up to 5 strings. </para>
				<sect2>
					<title>Syntax</title>
					<para> $concat ( Source , String{, String2{, String3{, String4}}}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Source, String—strings to be concatenated. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Concatenated string. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$1="Uniface "
$2="is "
$3="great"
$4=$concat($1, $2, $3)
; $4 now contains "Uniface is great"
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_condition">
				<title>$condition</title>
				<para> Introduced in: U8 </para>
				<para>Return the result of evaluating a conditional expression. </para>
				<sect2>
					<title>Syntax</title>
					<para> $condition ( Condition{, DataList}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Condition—any legal conditional Proc expression or compiled
									conditional expression; can be a string, or a field (or indirect
									reference to a field), a variable, or a function that evaluates
									to a string. <itemizedlist>
										<listitem>
											<para>Only Proc allowed in the current component type
												can be used. </para>
										</listitem>
										<listitem>
											<para>An operand in the expression cannot contain
												another expression. For example, an expression that
												includes $fieldendmod cannot be used in a report or
												service. </para>
										</listitem>
										<listitem>
											<para>Any field referred to must be included in the
												field list for the component entity. </para>
										</listitem>
										<listitem>
											<para>Variables included in Condition must be in scope.
											</para>
										</listitem>
									</itemizedlist>
								</para>
							</listitem>
							<listitem>
								<para>DataList—list used to substitute variables (or fields) in the
									expression with data. This works just like the string
									substitution. Optional. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> $condition returns either TRUE or to FALSE after evaluating Condition. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<para>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$condition and $expression</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1301 </entry>
										<entry> &lt;UPROCERR_SYNTAX&gt; </entry>
										<entry> Syntax error. </entry>
									</row>
									<row>
										<entry> -1302 </entry>
										<entry> &lt;UPROCERR_SERVICE&gt; </entry>
										<entry> Function not allowed in service. </entry>
									</row>
									<row>
										<entry> -1303 </entry>
										<entry> &lt;UPROCERR_REPORT&gt; </entry>
										<entry> Function not allowed in report. </entry>
									</row>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. </entry>
									</row>
									<row>
										<entry> -1305 </entry>
										<entry> &lt;UPROCERR_EXPRESSION&gt; </entry>
										<entry> Expression not allowed. </entry>
									</row>
									<row>
										<entry> -1306 </entry>
										<entry> &lt;UPROCERR_CONDITION&gt; </entry>
										<entry> Condition not allowed. </entry>
									</row>
									<row>
										<entry> -1307 </entry>
										<entry> &lt;UPROCERR_EXTRACTION_EXPR&gt; </entry>
										<entry> Extraction expression is a condition. </entry>
									</row>
									<row>
										<entry> -1308 </entry>
										<entry> &lt;UPROCERR_INDIRECTION&gt; </entry>
										<entry> Indirection followed by brackets. </entry>
									</row>
									<row>
										<entry> -1309 </entry>
										<entry> &lt;UPROCERR_PARENTHESES&gt; </entry>
										<entry> Operand followed by parentheses. </entry>
									</row>
									<row>
										<entry> -1310 </entry>
										<entry> &lt;UPROCERR_BRACKETS&gt; </entry>
										<entry> Operand followed by square brackets. </entry>
									</row>
									<row>
										<entry> -1311 </entry>
										<entry> &lt;UPROCERR_UNRESOLVED_OPERAND&gt; </entry>
										<entry> A field, parameter, or variable could not be found
											in current context.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Optional Argument for $condition</title>
					<para>The following example shows the use of the optional argument IdItemList
						for $condition. </para>
					<programlisting role="uniface"><![CDATA[$2="one=1<emphasis role="underline">;</emphasis>two=2<emphasis role="underline">;</emphasis>three=3"
$1=$condition("one+two+three=6", $2)
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Compiling Proc at Runtime</title>
					<para>The following example demonstrates the use of proccompile, $condition, and
						$expression. proccompile is used to check the entered business rules in the
						DO_DISCOUNT and DISCOUNT fields, $condition is used to evaluate DO_DISCOUNT,
						and $expression is used to return the result of DISCOUNT. </para>
					<para>The field DO_DISCOUNT contains the condition for a discount and DISCOUNT
						contains the actual expression for the discount. At run time, values can be
						entered for both fields that will determine whether a discount should be
						given, and the actual amount of the discount. </para>
					<para>For example, the following line should be entered in the field DO_DISCOUNT
						if a discount should be given when more then 100 articles are ordered (where
						the field AMOUNT contains the number of ordered articles): </para>
					<programlisting role="uniface"><![CDATA[AMOUNT&gt;100
]]></programlisting>
					<para>And the following line should be entered in the field DISCOUNT if the
						actual discount is 10 percent of the total cost of the articles (where the
						field PRICE contains the unit price of the ordered article): </para>
					<programlisting role="uniface"><![CDATA[0.1*AMOUNT*PRICE
]]></programlisting>
					<para>The following Proc code checks the entered business rules and executes
						them accordingly:</para>
					<programlisting role="uniface"><![CDATA[entry total_cost
variables
   numeric vDiscount
endvariables
; This Proc entry calculates total cost of ordered article including discount
; Check syntax of discount condition in field DO_DISCOUNT
proccompile/condition DO_DISCOUNT, "FIELDS=AMOUNT"
if ($procerror &lt; 0)
   message/error "Incorrect syntax for discount condition (%%$procerror)"
   putmess $procerrorcontext
   return -1
endif
; Check discount condition
if ($condition($result)) ; Use compiled Proc in $result
; A discount should be given
; Check syntax of discount expression in field DISCOUNT
   proccompile/expression DISCOUNT, "FIELDS=AMOUNT<emphasis role="underline">!;</emphasis>PRICE"
   if ($procerror &lt; 0)
      message/error "Incorrect syntax for discount expression (%%$procerror)"
      putmess $procerrorcontext
      return -1
   endif
; Execute discount
; Use compiled Proc in $result
   vDiscount = $expression($result)
; Or, use uncompiled expression
; vDiscount = $expression(DISCOUNT)
else
; No discount should be given
; Set discount to 0
   vDiscount = 0
endif
COST = AMOUNT * PRICE - vDiscount
return 0
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_cos">
				<title>$cos</title>
				<para> Introduced in: U8 </para>
				<para>Return the cosine of X. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$cos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X —angle in radians or a field (or indirect reference to a field), a
						variable, or a function or expression which evaluates to an angle in
						radians. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Calculated cosine <emphasis role="italic">X </emphasis>. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the cosine of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$COSINEPIR$ = $cos($pi() * RADIANS)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_curhits">
				<title>$curhits</title>
				<para>Return the number of occurrences currently in the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para> $curhits{( <emphasis role="italic">Entity </emphasis>)} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. If omitted, the current entity is
									used. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $curhits</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> ""</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> &lt;0 </entry>
										<entry> Hitlist has been only partially built</entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Number of occurrences in the hitlist.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$curhits</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The value of $curhits is negative if the hitlist has been partially built.
						This occurs when there can be further occurrences in the DBMS that match the
						retrieve profile but that are not yet in the hitlist. A partially built
						hitlist is called a 'stepped hitlist', since it is built in steps. Not all
						DBMSs support stepped hitlists, and those that do may not use the default
						value of ten occurrences in a step. To check whether your DBMS supports
						stepped hitlists, see the appropriate connector documentation. </para>
					<para>When only a partial hitlist is built, the values returned by $curhits can
						(at first) appear confusing. A partial hitlist is usually built in steps of
						ten occurrences. When the user inspects the first ten occurrences, $curhits
						is -10; the negative value indicates that there may be further occurrences
						to be fetched. After the user sees the eleventh occurrence, $curhits returns
						-20, because another set of ten occurrences has been added to the hitlist.
						$curhits continues to return -20, until the user inspects the twenty-first
						occurrence. At that point the next set of ten occurrences is fetched and
						$curhits returns -30. $curhits returns a positive value only when the
						complete hitlist has been built, and then the value is the same as $hits.
						(This process is illustrated in the table in the discussion of $totocc.) </para>
					<para>The performance benefits of using a stepped hitlist are lost if you use a
						function like $hits, which results in the complete hitlist being built. A
						complete hitlist is also built in response to the following commands: </para>
					<itemizedlist>
						<listitem>
							<para>setocc <emphasis role="italic">Entity </emphasis>,-1 </para>
						</listitem>
						<listitem>
							<para>creocc <emphasis role="italic">Entity </emphasis>,-1 </para>
						</listitem>
						<listitem>
							<para>The order by clause in a read statement (where the DBMS does not
								support this feature) </para>
						</listitem>
					</itemizedlist>
					<para>For some DBMSs a stepped hitlist uses a dynamic size for each step. This
						is because the DBMS can select only all records with the same index value,
						not just some of them. So, if a retrieve profile specified all records with
						a foreign key greater than 20, for example, and the first 15 occurrences all
						have a foreign key of 21, the step size for the stepped hitlist is 15. This
						means that $curhits returns -15 (if the hitlist is only partially built).
					</para>
				</sect2>
				<sect2>
					<title>Example: Displaying the Number of Items in the Hitlist</title>
					<para>The following example displays the number of elements in the hitlist. If
						the value returned by $curhits is negative, the message includes the text
						'so far'. Note the use of the flag $RETR$. This prevents the message from
						being displayed until after a retrieve has completed: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Retrieve
$RETR$ = 1
retrieve
if ($curhits &lt; 0)
   $1 = $curhits * -1
   message "%%$1 hits selected (so far)"
else
   message "%%$hits occurrences retrieved"
endif
$RETR$ = 0
]]></programlisting>
					<programlisting role="uniface"><![CDATA[; trigger: &lt;Read&gt;
read
if ($RETR$ = 0)
   if ($curhits &lt; 0)
      $1 = $curhits * -1
      message "%%$1 hits selected (so far)"
   else
      message "%%$hits occurrences retrieved"
   endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_curkey">
				<title>$curkey</title>
				<para>Return the number of the current key in a Validate Key or Leave Modified Key
					trigger. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$curkey</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values Returned by $curkey</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &gt;1 </entry>
										<entry> Key number of a candidate key as defined on the
											Define Key form </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Primary key </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> An error occurred </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values returned by $procerror following $curkey</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. For example,
											$curkey was encountered in an incorrect trigger.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, session service, entity service, and service components
						(and in report components that are not self-contained), only in a Validate
						Key or Leave Modified Key trigger. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $curkey function returns the key number in the current occurrence for
						which the Validate Key or Leave Modified Key trigger was activated. </para>
				</sect2>
				<sect2>
					<title>Example: Validating Keys and Error Handling </title>
					<para> The following example uses the $curkey function to perform specific
						validation for each key: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Validate Key
selectcase $curkey
   case 1 ;perform validation for the primary key
   ...
   case 2 ;perform validation for candidate key #2
...
   case 4 ;perform validation for candidate key #4
...
   elsecase
      message "Error %%$procerror occurred at %%$procerrorcontext"
      message "Context: %%$dataerrorcontext"
endselectcase
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_curline">
				<title>$curline</title>
				<para>Return the line on which the cursor is positioned in the current field. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$curline</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Line number where the cursor is currently positioned in the Uniface field
						editor. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The $curline function enables you to refer to particular lines of a
						field. </para>
					<para>This function is valid only in a unifield; it has no effect in widgets.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses $curline to provide context-sensitive help. The
						user positions the cursor on a particular line in the field and activates
						the Help trigger for that line: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Help
help $text("%%$curline%%%_HLP")]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_curocc">
				<title>$curocc</title>
				<para>Return the sequence number of the current occurrence in the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para> $curocc {( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—name of the entity; can be a
						string, or field, variable, function, or parameter that evaluates to a
						string that contains the name of an entity. If omitted, the current entity
						is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Sequence number in the hitlist of the current occurrence.
								</para>
							</listitem>
							<listitem>
								<para>Empty string (""), if an error occurred, in which case
									$procerror contains a negative value that identifies the exact
									error. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$curocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> UPROCERR_ENTITY</entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The following events affect the value of $curocc: </para>
					<table>
						<title>Table 2. Events that change $curocc</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Event </entry>
									<entry> Action </entry>
									<entry> Discussion </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>discard </entry>
									<entry> No change. </entry>
									<entry> If there is an occurrence following the discarded
										occurrence. </entry>
								</row>
								<row>
									<entry> Subtracts 1 from $curocc. </entry>
									<entry> If there is no occurrence following the discarded
										occurrence. </entry>
								</row>
								<row>
									<entry> retrieve </entry>
									<entry> Sets $curocc to 1. </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> setocc </entry>
									<entry> Sets $curocc to specified occurrence. </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> ^ADD_OCC </entry>
									<entry> Adds 1 to $curocc. </entry>
									<entry> $totocc is increased by 1. </entry>
								</row>
								<row>
									<entry> ^INS_OCC </entry>
									<entry> No change. </entry>
									<entry> $totocc is increased by 1. </entry>
								</row>
								<row>
									<entry>^NEXT_OCC </entry>
									<entry> Adds 1 to $curocc. </entry>
									<entry> If there is a next occurrence present in the component.
									</entry>
								</row>
								<row>
									<entry> No change. </entry>
									<entry> If there is no next occurrence. </entry>
								</row>
								<row>
									<entry> ^PREV_OCC </entry>
									<entry> Subtracts 1 from $curocc. </entry>
									<entry> If there is a previous occurrence present in the
										component. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> No change. </entry>
									<entry> If there is no previous occurrence. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows Proc code in an Occurrence Gets Focus trigger
						which uses $curocc and $totocc to show the user the position of the current
						occurrence in relation to other occurrences in the component structure: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
message "Number %%$curocc of %%$totocc"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_curoccvideo">
				<title>$curoccvideo</title>
				<para> Introduced in: U9 </para>
				<para>Set or return the video properties for fields of the current occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>AttributeList = $curoccvideo ( Entity {, " Option "}) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—name of an entity; can be a literal name, string,
									variable, function or parameter. If Entity is "*", the video
									properties are applied to all entities in the form. If Entity is
									omitted, only the current entity is affected. </para>
							</listitem>
							<listitem>
								<para>Option—string containing the following options: <itemizedlist>
										<listitem>
											<para>inner—apply the video properties to all inner
												entities of the current occurrence, but not to the
												specified entity itself. </para>
										</listitem>
										<listitem>
											<para>up—apply the video properties only to inner
												entities that are drawn as up entities within the
												specified entity. </para>
										</listitem>
										<listitem>
											<para>off—turn off video highlighting for the current
												occurrence; AttributeList is ignored. If you specify
												inner,off, video highlighting is turned off for
												inner entities only. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>AttributeList—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string. The
									string should evaluate to one of: <itemizedlist>
										<listitem>
											<para>DEF, to set the default video attributes for the
												current occurrence. (The default video attributes
												are determined by the assignment setting
												$DEF_CUROCC_VIDEO.) </para>
										</listitem>
										<listitem>
											<para>NON, to set no special video attributes for the
												current occurrence. In character mode, this means
												that fields, which appear in inverse by default,
												appear in normal video; this can create a sort of
												highlighting effect. </para>
										</listitem>
										<listitem>
											<para>One or more video attributes, separated by GOLD
												semicolons ( <emphasis role="underline">;</emphasis>
												) or by commas (,). </para>
										</listitem>
									</itemizedlist></para>
								<para>If AttributeList is omitted, DEF is assumed. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Any video properties defined for the active field (with the assignment
						setting $ACTIVE_FIELD) override those defined for the current occurrence.
						This allows the active field to be visible within the active occurrence, if
						you have chosen appropriate video properties. Video properties set with
						$fieldvideo override the video properties for the active field as well as
						for the active occurrence. </para>
					<para>You can use the assignment setting $CUROCC_VIDEO to enable the
						highlighting of the active occurrence in all forms of the application, using
						the default video attributes defined with $DEF_CUROCC_VIDEO. </para>
				</sect2>
				<sect2>
					<title>Video Properties</title>
					<para> The $curoccvideo function sets or retrieves the video properties for the
						fields of the current occurrence. Used without an option, $curoccvideo
						applies these properties to fields of Entity. </para>
					<para>Using the inner or up option excludes the calling entity, so only inner or
						upper entities, respectively, are altered with these options. For example,
						the following statement affects only the inner entities of MyOuterEntity: </para>
					<programlisting role="uniface"><![CDATA[
$curoccvideo("MyOuterEntity", "inner") = "BRI"
]]></programlisting>
					<para>
						<emphasis role="bold"> Note:</emphasis> The $curoccvideo function does not
						affect an entity that is used as a single occurrence, unless that entity is
						an up entity and the outer entity is drawn with multiple occurrences. <table>
							<title>Table 1. Video attribute codes</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Code </entry>
										<entry> Description </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> BLI</entry>
										<entry> Blinking </entry>
									</row>
									<row>
										<entry> BOR</entry>
										<entry> Border </entry>
									</row>
									<row>
										<entry> BRI</entry>
										<entry> Bright </entry>
									</row>
									<row>
										<entry> HLT</entry>
										<entry> Use system highlight color</entry>
									</row>
									<row>
										<entry> INV</entry>
										<entry> Inverse </entry>
									</row>
									<row>
										<entry> UND</entry>
										<entry> Underline </entry>
									</row>
									<row>
										<entry> COL=<emphasis role="italic"> n </emphasis></entry>
										<entry> Set color to color code n, the sum of the color
											numbers for foreground and background. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example causes the fields of the current occurrences of all
						inner entities that are painted as up entities within the entity Customer to
						appear with white letters on a blue background. The color number is
						determined by adding 56 (black foreground) and 1 (blue background). </para>
					<programlisting role="uniface"><![CDATA[$curoccvideo ("CUSTOMER","up") = "COL=57"]]></programlisting>
					<para>The following example turns off highlighting of fields of the current
						occurrences of all inner entities within the entity ENT1, but not of ENT1
						itself.</para>
					<programlisting role="uniface"><![CDATA[$curoccvideo ("ENT1","inner,off")]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_curword">
				<title>$curword</title>
				<para>Return the word on which the cursor is positioned in the current field. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$curword</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Word on which the cursor is currently positioned. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The $curword allows you to refer to a particular word in a field. Note:
						This function is valid only in a unifield; it has no effect in
						widgets.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses $curword to provide context-sensitive help. The
						user positions the cursor on a particular word in the field and activates
						the Help trigger for that field: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Help
help $text("%%$curword%%%_HLP") ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_dataerrorcontext">
				<title>$dataerrorcontext</title>
				<para>Return the context of the last validation error. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$dataerrorcontext</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Associative list that describes the context in which the error
						occurred.</para>
					<table>
						<title>Table 1. Associative list items returned by $dataerrorcontext</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Item </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> CONTEXT=VALIDATION </entry>
									<entry> The error occurred during validation. </entry>
								</row>
								<row>
									<entry> TOPIC=FIELD </entry>
									<entry> Error occurred during a procedural check in a Validate
										Field trigger. </entry>
								</row>
								<row>
									<entry> TOPIC=KEY </entry>
									<entry> Error occurred during a procedural check in a Validate
										Key trigger. </entry>
								</row>
								<row>
									<entry> TOPIC=OCC </entry>
									<entry> Error occurred during a procedural check in a Validate
										Occurrence trigger. </entry>
								</row>
								<row>
									<entry> TOPIC=SYNTAX </entry>
									<entry> Error occurred during a declarative check. </entry>
								</row>
								<row>
									<entry> OCC= <emphasis role="italic">OccurrenceNumber
										</emphasis></entry>
									<entry> Occurrence number where error occurred. </entry>
								</row>
								<row>
									<entry> KEY= <emphasis role="italic">KeyNumber
										</emphasis></entry>
									<entry> When TOPIC=KEY, the key number that caused the error.
										Otherwise, omitted. </entry>
								</row>
								<row>
									<entry> OBJECT= <emphasis role="italic">Field </emphasis>.
											<emphasis role="italic">Entity </emphasis>. <emphasis
											role="italic">Model </emphasis></entry>
									<entry> When TOPIC=FIELD, the field, entity, and model at which
										the error occurred, in uppercase characters. When
										TOPIC=SYNTAX and the error occurred at field level, the
										field, entity, and model at which the error occurred, in
										uppercase characters. </entry>
								</row>
								<row>
									<entry> OBJECT= <emphasis role="italic">Entity </emphasis>.
											<emphasis role="italic">Model </emphasis></entry>
									<entry> When TOPIC=KEY or TOPIC=OCC, the entity and model at
										which the error occurred, in uppercase characters. When
										TOPIC=SYNTAX and the error occurred at entity level, the
										entity and model at which the error occurred, in uppercase
										characters. </entry>
								</row>
								<row>
									<entry> ERROR= <emphasis role="italic">ErrorValue
										</emphasis></entry>
									<entry> The value of $error. </entry>
								</row>
								<row>
									<entry> STATUS= <emphasis role="italic">StatusValue
										</emphasis></entry>
									<entry> The value of $status. Typically this is a negative
										value. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, session service, entity service, and service components
						(and in report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the $dataerrorcontext function: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Validate Field
; Example: non-contiguous range check
if (DISCOUNT = -100 | (DISCOUNT &gt;= 0 &amp; DISCOUNT &lt;= 100))
   return(0)
else
   return(-1)
endif
done]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_date">
				<title>$date</title>
				<para>Return the current date or convert the argument to the Date data type. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$date</command> {( Source )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Source </emphasis>—constant, field, variable, or
						function with a String value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The function $date returns the following: </para>
					<itemizedlist>
						<listitem>
							<para>If Source is omitted or is an empty string (""), $date returns the
								current system date. </para>
						</listitem>
						<listitem>
							<para>If Source is present, $date converts it to data type Date and
								returns that value. </para>
						</listitem>
						<listitem>
							<para>If Source cannot be converted to a Date value (for example,
								$date("abc")), $date returns an empty string (""). </para>
						</listitem>
						<listitem>
							<para>If a service or report component is running in a remote
								environment, the function $date returns the system time of the
								server (not of the client). </para>
						</listitem>
						<listitem>
							<para>If an error occurs during the evaluation of this function,
								$procerror contains a negative value that identifies the exact
								error. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>If Source has a different format from the default date format, you must
						convert it into one that Uniface can work with. In this case, you can either
						change the default so that the default reflects the data, or change the data
						so that the data reflects the default. </para>
					<para>To change the default, you need to change the $language and $variation
						codes to select a language setup with a default date format that is the same
						as the string argument. Then use $date to convert the value. </para>
					<para>To change the data, you can define a global or component variable with the
						appropriate display format. For example, if you have a default date format
						of <emphasis role="italic">dd </emphasis>- <emphasis role="italic">mmm
						</emphasis>- <emphasis role="italic">yyyy </emphasis>, and you have
						retrieved date information in the format <emphasis role="italic">mm
						</emphasis>/ <emphasis role="italic">dd </emphasis>/ <emphasis role="italic"
							>yyyy </emphasis>, you should define a global or component variable with
						a display format of DIS(mm/dd/yyyy); then copy the retrieved date to this
						variable. This ensures that Uniface correctly interprets the value of the
						retrieved date. (This also avoids the use of $date.) </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> With all date functions, the
						conversion process is governed by the format of the default date. This
						format is defined by <emphasis role="bold">Tools &gt; Language Setups &gt;
							Date-time Properties</emphasis> in the Deployment Workspace. The default
						language setup used by an application is governed by the values of $language
						and $variation. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following examples show the different values returned by $date. The
						value returned depends on the default date in the language setup. The first
						example has a default date format of <emphasis role="italic">dd-mmm-yyyy
						</emphasis>, and the example code was tested on the 21st of August, 1994: </para>
					<programlisting role="uniface"><![CDATA[clrmess
$1 = $date("1-2-94")
putmess "$1 = %%$1 on value of 1-2-94"
$2 = $date
putmess "$2 = %%$2 on value of null"]]></programlisting>
					<para>This produces the following message frame: </para>
					<programlisting role="uniface"><![CDATA[$1 = 01-feb-1994 on value of 1-2-94
$2 = 21-aug-1994 on value of null]]></programlisting>
					<para>When exactly the same code was run, but with a default language setting of
							<emphasis role="italic">mmm-dd-yyy</emphasis> , the following message
						frame was generated: </para>
					<programlisting role="uniface"><![CDATA[$1 = jan-02-1994 on value of 1-2-94
$2 = aug-21-1994 on value of null]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_datim">
				<title>$datim</title>
				<para>Return the system date and time or convert the argument to the Datetime data
					type. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$datim</command> {( Source )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Source—constant, field, variable, or function with a string value
						formatted as: dd-mmm-yyhh:nn:ss.tt </para>
					<itemizedlist>
						<listitem>
							<para>dd—date </para>
						</listitem>
						<listitem>
							<para>mmm—month </para>
						</listitem>
						<listitem>
							<para>yy—year </para>
						</listitem>
						<listitem>
							<para>hh—hour </para>
						</listitem>
						<listitem>
							<para>nn—minute </para>
						</listitem>
						<listitem>
							<para>ss—second </para>
						</listitem>
						<listitem>
							<para>tt—tick, that is hundredth of a second, prefixed by a separation
								character, a dot, or a semicolon </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Value with data type Datetime: </para>
					<itemizedlist>
						<listitem>
							<para>If Source is given, $datim converts Source to the corresponding
								date and time. </para>
							<para>Source should be formatted according to the Default Date-Time
								Format, which depends on the language setup that is current at run
								time. If the current language setup has no default Date-Time Format
								defined, dd-mmm-yy hh:nn:ss:tt is used. </para>
						</listitem>
						<listitem>
							<para>If Source is omitted, the function returns a string containing the
								system clock time as ccyymmddhhnnsstt, accurate to one hundredth of
								a second (1 tick). For example: 2007010512322478. </para>
						</listitem>
						<listitem>
							<para>If a service or report component is running in a remote
								environment, $datim returns the system time of the server (not of
								the client). </para>
						</listitem>
						<listitem>
							<para>If an error occurs, $procerror contains a negative value that
								identifies the exact error. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Examples of $datim Return Values with Date-Time
							Formats</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Field Layout Definition</entry>
									<entry>Value Returned by $datim </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> hh:nn:ss.tt </entry>
									<entry> 12:32:24.78 </entry>
								</row>
								<row>
									<entry> hh:nn:ss </entry>
									<entry> 12:32:24 </entry>
								</row>
								<row>
									<entry> dd-MMM-yyyy hh:nn:ss.tt </entry>
									<entry> 01-MAY-2007 23:30:43.67 </entry>
								</row>
								<row>
									<entry> dd-MMM-yyyy hh:nn:ss.tt and Source is "01-05-0723:30:43" </entry>
									<entry> 01-MAY-2007 23:30:43.00. Note that the 00 ticks are
										returned.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Used without Source, $datim returns the system date and time. You can use
						$datim in Proc code to assign the current date to fields in header or
						trailer frames, or to put a timestamp on occurrences. The time returned is
						accurate to one hundredth of a second (1 tick). </para>
					<para>Used with Source, $datim converts Source to a value with data type
						Datetime. </para>
					<para>With all date functions, the conversion process is governed by the format
						of the default date. This format is defined by <emphasis role="bold">Tools
							&gt; Language Setups &gt; Date-time Properties</emphasis> in the
						Deployment Workspace. The default language setup used by an application is
						governed by the values of $language and $variation. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example assigns the current system date and time to the
						field DATE.HEADER: </para>
					<programlisting role="uniface"><![CDATA[; entity: HEADER.USYS
; trigger: Occurrence Gets Focus
DATE.HEADER = $datim ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_dberror">
				<title>$dberror</title>
				<para>Return the error code reported by the DBMS. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$dberror</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Error number that was set when the DBMS or network driver encountered an
						error situation. The value is given by the DBMS or network to the driver, so
						it is DBMS- or network-specific. For more information, consult the
						documentation for your DBMS or network. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The error number returned by the DBMS is not the same as the error code
						returned to Uniface by the DBMS driver. Your driver can use $dberror to
						return internal driver errors as well as DBMS errors. </para>
					<para>To retrieve the associated error message, use $dberrortext.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example puts the value of $dberror into the message frame if
						an error occurs ($status is negative): </para>
					<programlisting role="uniface"><![CDATA[if ($status &lt; 0)
   putmess "DBMS / Network error %%$dberror: %%$dberrortext"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_dberrortext">
				<title>$dberrortext</title>
				<para> Introduced in: U9 </para>
				<para>Return the text of an error reported by the DBMS. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$dberrortext</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Error text issued by the DBMS or network to the driver when an error
						situation is encountered. The value is given by the DBMS or network to the
						driver, so it is DBMS- or network-specific. For more information, consult
						the documentation for your DBMS or network. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$dberrortext returns the message associated with the DBMS error returned
						by $dberror. If no text is available when $dberror is set, the $dberrortext
						message is: "Unknown error - no message available". </para>
					<para>If there is no $dberror (that is, $dberror=0), $dberrortext is empty.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example puts the value of $dberrortext into the message
						frame if an error occurs ($status is negative): </para>
					<programlisting role="uniface"><![CDATA[if ($status &lt; 0)
   putmess "DBMS / Network error %%$dberror: %%$dberrortext"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_dbocc">
				<title>$dbocc</title>
				<para>Returns the sequence number of the current occurrence within the set of
					occurrences that are connected to the database.</para>
				<sect2>
					<title>Syntax</title>
					<para> $dbocc{( <emphasis role="italic">Entity </emphasis>)} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<emphasis role="italic">Entity </emphasis>—name of the entity; can be a
						liternal name, a string, or a variable, function, parameter, or field
						reference. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values Returned by $dbocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &gt;0 </entry>
										<entry> The sequence number of the current or specified
												<emphasis role="italic">Entity </emphasis>in the
											database. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> The current occurrence has not been retrieved from
											the database (it has been entered by the user, but not
											stored yet). </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains a negative
											value that identifies the exact error.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$dbocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> UPROCERR_ENTITY </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $dbocc returns the sequence number of the current occurrence
						within the set of occurrences that are connected to the database. The
						following events affect the value of $dbocc: </para>
					<table>
						<title>Table 3. Statements and Events that Change $dbocc</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Event </entry>
									<entry> Action </entry>
									<entry> Discussion</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> discard </entry>
									<entry> Reduces $dbocc. </entry>
									<entry> By the number of discarded database occurrences.
									</entry>
								</row>
								<row>
									<entry> read </entry>
									<entry> Adds 1 to $dbocc. </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> retrieve </entry>
									<entry> Sets $dbocc to 1. </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>store </entry>
									<entry> Increases $dbocc. </entry>
									<entry> If non-database occurrences are stored. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If no non-database occurrences are stored. </entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> No change. </entry>
									<entry> Causes the Read trigger to be activated if the next
										occurrence is not yet in the component. </entry>
								</row>
								<row>
									<entry> ^PREV_OCC </entry>
									<entry> No change. </entry>
									<entry> Causes the Read trigger to be activated if the previous
										occurrence is not yet in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>After a store (and commit) any newly-created occurrences are connected to
						the database and considered to be database occurrences, so $dbocc adds the
						occurrence to the list and returns its sequence number in that list of
						connected occurrences. After a rollback, any new occurrences are not
						committed and therefore not connected to the database. </para>
					<para>Contrast this with the value returned by $curocc, that is, the sequence
						number of an occurrence in the component. The function $dbocc can be used to
						check whether an occurrence was retrieved from a database or entered by the
						user. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following example displays the sequence number in the database, if
						the occurrence is in the database:
						<programlisting role="uniface"><![CDATA[
; trigger: Occurrence Gets Focus
if ($dbocc &gt; 0)
message "On DBMS occurrence %%$dbocc"
endif
]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Example: $dbocc = 0 </title>
					<para>The following example logs information about which user updated or created
						a particular occurrence. The value of $dbocc is used to determine whether
						the occurrence is newly created, or has been retrieved from a database. </para>
					<programlisting role="uniface"><![CDATA[
; trigger: Write
if ($dbocc = 0)
CREATED_BY = $user
CREATED_DATE = $date
else
UPDATED_BY = $user
endif
write
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_decode">
				<title>$decode</title>
				<para> Introduced in: U9 </para>
				<para>Decode or decrypt the data.</para>
				<sect2>
					<title>Syntax</title>
					<para> $decode ( Algorithm , Source { , Key{ , Mode , InitializationVector}} )
					</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Algorithm—decoding or decryption algorithm; see <emphasis
										role="italic">Supported Algorithms</emphasis> below. </para>
							</listitem>
							<listitem>
								<para>Source—string, variable, or field containing the data to be
									decoded or decrypted. </para>
							</listitem>
							<listitem>
								<para>Key—secret key, required if Algorithm specifies a block
									cipher. The length of the key must be appropriate to the
									algorithm. </para>
							</listitem>
							<listitem>
								<para>Mode—block cipher modes of operation; one of: <itemizedlist>
										<listitem>
											<para>ECB—Electronic codebook (default) </para>
										</listitem>
										<listitem>
											<para>CBC—Cipher-block chaining </para>
										</listitem>
										<listitem>
											<para>CFB—Cipher feedback </para>
										</listitem>
										<listitem>
											<para>OFB—Output feedback </para>
										</listitem>
										<listitem>
											<para>CTR—Counter </para>
										</listitem>
										<listitem>
											<para>CBC_CTS—CBC cipher text stealing </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>InitializationVector—a unique data block, such as a time stamp
									or random number, used in combination with the key. Required for
									all modes except ECB </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns decoded or decrypted data in the Uniface raw data type. </para>
					<para>The returned data may contain the null byte (0x00), so the return value is
						in the Uniface raw data type, which is able to handle this. If you need to
						get the data in the string data type, then you can convert it from raw to
						string data using $encode with the USTRING algorithm. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. Some errors provide more detailed information in the
						ADDITIONAL list item in $procerrorcontext. </para>
					<table>
						<title>Table 1. Values of $procerror commonly returned by $decode </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1780 </entry>
									<entry> UENCERR_NO_ALGORITHM</entry>
									<entry> Algorithm not found.</entry>
								</row>
								<row>
									<entry> -1781 </entry>
									<entry> UENCERR_NO_SOURCE </entry>
									<entry> Source not found. </entry>
								</row>
								<row>
									<entry> -1782 </entry>
									<entry> UENCERR_NO_KEY </entry>
									<entry> Key not found. </entry>
								</row>
								<row>
									<entry> -1783 </entry>
									<entry> UENCERR_NO_IV</entry>
									<entry> IV not found. </entry>
								</row>
								<row>
									<entry> -1784 </entry>
									<entry> UENCERR_INVALID_ALGORITHM </entry>
									<entry> Invalid algorithm name. </entry>
								</row>
								<row>
									<entry> -1785 </entry>
									<entry> UENCERR_INVALID_MODE </entry>
									<entry> Invalid mode name. </entry>
								</row>
								<row>
									<entry> -1786 </entry>
									<entry> UENCERR_INVALID_KEY_LENGTH</entry>
									<entry> Invalid key length. The key must have a specific length
										that depends on the algorithm. </entry>
								</row>
								<row>
									<entry> -1787 </entry>
									<entry> UENCERR_INVALID_HEX_FORMAT </entry>
									<entry> Source is invalid HEX format. </entry>
								</row>
								<row>
									<entry> -1788 </entry>
									<entry> UENCERR_INVALID_BASE64_FORMAT</entry>
									<entry> Source is invalid BASE64 format. </entry>
								</row>
								<row>
									<entry> -1789 </entry>
									<entry> UENCERR_INVALID_URL_FORMAT </entry>
									<entry> Source is invalid URL format. </entry>
								</row>
								<row>
									<entry> -1790 </entry>
									<entry> UENCERR_INVALID_URAW_DATA </entry>
									<entry> Invalid Uniface raw data. </entry>
								</row>
								<row>
									<entry> -1791 </entry>
									<entry> UENCERR_GENERAL </entry>
									<entry> Encode/decode general error </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>$decode supports a variety of commonly-used encoding schemes and block
						ciphers to decode or decrypt data. For example, you can use $decode
						to:</para>
					<itemizedlist>
						<listitem>
							<para>Decrypt data retrieved from a database that contains encrypted
								data, using the same key as was used to encrypt the data </para>
						</listitem>
						<listitem>
							<para>Decode data that was encoded using Base64, hexadecimal, or URL
								encoding schemes </para>
						</listitem>
					</itemizedlist>
					<para>The Source, Key, and InitializationVector parameters can specify a string,
						variable, or field. If the data type of a variable or field is Raw, it is
						evaluated as data type raw. Otherwise, it is evaluated as data type string. </para>
					<para>To decrypt the data, you need to provide the same Key, Mode and
						InitializationVector as was used to encrypt the data. Otherwise you get an
						incorrect result or an error.</para>
				</sect2>
				<sect2>
					<title>Supported Algorithms</title>
					<para>The following tables list the values for the supported encryption and
						encoding algorithms.</para>
					<para>A block cipher takes a fixed-length block of data and uses a secret key to
						encrypt the data to a block of encrypted data of the same length. The data
						can be decrypted with the same key. </para>
					<table>
						<title>Table 2. Block Ciphers</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> AES </entry>
									<entry> Advanced Encryption Standard </entry>
								</row>
								<row>
									<entry> RIJNDAEL </entry>
									<entry> Same as AES </entry>
								</row>
								<row>
									<entry> DES </entry>
									<entry> Data Encryption Standard </entry>
								</row>
								<row>
									<entry> TDES </entry>
									<entry> Triple Data Encryption Algorithm (TDEA) as known as
										Triple DES </entry>
								</row>
								<row>
									<entry> DES_EDE3 </entry>
									<entry> Same as TDES </entry>
								</row>
								<row>
									<entry> DES_EDE2 </entry>
									<entry> Variant of TDES with 16 byte key length </entry>
								</row>
								<row>
									<entry> DESX </entry>
									<entry> Variant of DES by XORing extra keys </entry>
								</row>
								<row>
									<entry> DES_XEX3 </entry>
									<entry> Same as DESX </entry>
								</row>
								<row>
									<entry> BLOWFISH </entry>
									<entry> Blowfish </entry>
								</row>
								<row>
									<entry> TWOFISH </entry>
									<entry> Twofish </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Encoding Algorithms</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> BASE64 </entry>
									<entry> Base64 encoding scheme </entry>
								</row>
								<row>
									<entry> HEX </entry>
									<entry> Hexadecimal encoding scheme </entry>
								</row>
								<row>
									<entry> URL </entry>
									<entry> URL encoding scheme </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Block Ciphers</title>
					<para>A block cipher works on a fixed block size, but source data can be in a
						variety of lengths. Therefore, ECB and CBC mode require that the final block
						be padded before encryption. Uniface uses the PKCS7 padding scheme for ECB
						and CBC mode when the data is encrypted, so $decode expects the decrypted
						result to contain PKCS7-padded data. If this is not the case, Uniface issues
						a UENCERR_GENERAL error. </para>
				</sect2>
				<sect2>
					<title>Example: Encrypt and Decrypt Using Triple DES Block Cipher in ECB
						Mode</title>
					<programlisting role="uniface"><![CDATA[; Encrypt and decrypt the data by Triple DES in ECB mode.
; Output of $decode (vDec) should be the same as input of $encode (vRawSource).
vEnc = $encode("TDES", vRawSource, vKey2)
vDec = $decode("TDES", vEnc, vKey2)]]></programlisting>
					<sect3>
						<title>Example: Encrypt and Decrypt String Data</title>
						<para>$decode returns raw data, so you can use $encode with the USTRING
							algorithm to convert it to a string data type using Uniface internal
							encoding, UTF-8. </para>
						<programlisting role="uniface"><![CDATA[vEnc = $encode("BLOWFISH", "~home", "secret key")  ;encrypt the data
vRawData = $decode("BLOWFISH", vEnc, "secret key") ;decrypt the data
vStrgData = $encode("USTRING", vRawData)           ;convert the decrypted data from Raw to String ]]></programlisting>
					</sect3>
					<sect3>
						<title>Example: Create and Use an Initialization Vector</title>
						<programlisting role="uniface"><![CDATA[; Create an initialization vector.
vIv = $datim
; Encrypt the source data by AES in CBC mode.
vEnc = $encode("AES", vSource, vKey, "CBC", vIv)
; Decrypt the encrypted data.
; DECRYPT must be the same as SOURCE.
vDecrypt = $decode("AES", vEnc, vKey, "CBC", vIv)]]></programlisting>
					</sect3>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_detachedinstances">
				<title>$detachedinstances</title>
				<para>Return a list of detached instances. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$detachedinstances</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List of all instances that are not attached to another
									instance. </para>
							</listitem>
							<listitem>
								<para>For a remote component (that is, a service or report running
									on a server), returns the list of detached instances running on
									that server; it does not return the list from the client.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Instances that are not attached to another instance can either be
						explicitly or implicitly detached: </para>
					<para>An explicitly detached instance is one that is started by newinstance
						without the /attached switch and that has the Modality &amp; Attachment
						property set to Non-Modal, Detached. Each detached instance can be
						considered a child of the application screen. </para>
					<para>An implicitly detached instance is one that is defined as attached but has
						been created by Uniface as detached. This is true in the following cases: </para>
					<itemizedlist>
						<listitem>
							<para>The first form is always instantiated detached even when it is
								activated by the application. </para>
						</listitem>
						<listitem>
							<para>The first service which is activated on the server is always
								instantiated detached even when it is defined as attached. This is
								because there is nothing to which it can be attached while its
								parent is on the client. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> $detachedinstances can be used to build a ValRep list, as the following
						example demonstrates: </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger of a command button MORE_INFO
; FORMLIST is a drop-down list
; Note that the list produced by $detachedinstances could
; be processed with getlistitems and putlistitems
; to associate form names with representations meaningful
; to the end user.
if ($1 = "")
   $1 = 1
endif
newinstance "DETAILS", "DETAILS%%$1%%%"
$valrep("FORMLIST.CONTROLS") = $detachedinstances
activate "DETAILS%%$1%%%"
$1 = $1 + 1
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_direction">
				<title>$direction</title>
				<para>Return the structure editor mode (Next or Previous). </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$direction</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Return Values</title>
							<tgroup cols="2">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Structure editor is in Next mode</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Structure editor is in Previous mode</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para/>
					<para>The function $direction returns the structure editor mode. This mode is
						reset to Next by the following structure editor functions: </para>
					<itemizedlist>
						<listitem>
							<para>^DETAIL </para>
						</listitem>
						<listitem>
							<para>^FRAME </para>
						</listitem>
						<listitem>
							<para>^HELP </para>
						</listitem>
						<listitem>
							<para>^KEY_HELP </para>
						</listitem>
						<listitem>
							<para>^MENU </para>
						</listitem>
						<listitem>
							<para>^MESSAGE </para>
						</listitem>
						<listitem>
							<para>^NEXT </para>
						</listitem>
						<listitem>
							<para>^PRINT </para>
						</listitem>
						<listitem>
							<para>^PULLDOWN </para>
						</listitem>
						<listitem>
							<para>^RULER </para>
						</listitem>
					</itemizedlist>
					<para>Proc code in the corresponding triggers should not rely on the value of
						$direction, because it is always 0 (Next). </para>
					<para>It is usually preferable to use the Next Field or &lt;Previous Field&gt;
						triggers rather than the $direction function. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_dirlist">
				<title>$dirlist</title>
				<para> Introduced in: U9 </para>
				<para>Return the contents of the specified directory. </para>
				<sect2>
					<title>Syntax</title>
					<para> $dirlist ( DirPath {, Topic}) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>DirPath—directory path, that is, one that ends with a
									directory separator. The directory can be located inside a ZIP
									archive. The directory name (or its suffix) can contain the
									Uniface wildcard characters <emphasis role="underline"
										>?</emphasis> (GOLD ?) or <emphasis role="underline"
										>*</emphasis> (GOLD *). </para>
							</listitem>
							<listitem>
								<para>Topic—type of item to return; one of: <itemizedlist>
										<listitem>
											<para>FILE—list files in the specified path; default if
												Topic is omitted or an empty string, FILE is
												assumed. </para>
										</listitem>
										<listitem>
											<para>DIR—list subdirectories in the specified path
											</para>
										</listitem>
										<listitem>
											<para>DATASET—z/OS only; list datasets that have the
												specified path as prefix </para>
										</listitem>
										<listitem>
											<para>MEMBER—z/OS only; list PDS file members </para>
										</listitem>
									</itemizedlist><emphasis role="bold"> Note:</emphasis> Using
									DATASET or MEMBER makes your code platform-specific and
									non-portable. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List of files or subdirectories (depending on Topic) separated
									by GOLD ; ( <emphasis role="underline">;</emphasis> ). </para>
							</listitem>
							<listitem>
								<para>Empty list ("") if the directory is empty, does not exist, or
									an error occurred. $procerror contains the exact error. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values commonly returned by $procerror following
								$ldirlist and $dirlist</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
									<row>
										<entry> -1110</entry>
										<entry> &lt;UPROCERR_TOPIC&gt;</entry>
										<entry> Topic name not known. </entry>
									</row>
									<row>
										<entry> -1132</entry>
										<entry> &lt;UPROCERR_UNRESOLVED_TOPIC&gt;</entry>
										<entry> Topic could not be resolved. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $dirlist function returns the contents of the specified directory,
						taking file redirections in the assignment file into account. </para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On iSeries, DirPath can specify either a library, or a file in a library
							(<emphasis role="bold">library/.file</emphasis>, without a member name
						before the period). The objects returned depend on whether a library or file
						is specified, and the notation used, as well as the value of Topic. </para>
					<para>If you use IFS notation (DirPath contains the prefix <emphasis role="bold"
							>IFS:</emphasis> or <emphasis role="bold">!</emphasis>), libraries and
						files are considered to be directories. </para>
					<itemizedlist>
						<listitem>
							<para>If Topic is "file" $dirlist returns all objects except files in
								the library specified, postfixed with their object types, or returns
								all members in the file postfixed with <emphasis role="bold"
									>.MBR</emphasis>. </para>
						</listitem>
						<listitem>
							<para>If Topic is "dir", $dirlist returns only the file names in the
								library, postfixed with <emphasis role="bold">.FILE</emphasis>.
							</para>
						</listitem>
					</itemizedlist>
					<para>If the file specification does not use IFS notation, the following rules
						apply: </para>
					<itemizedlist>
						<listitem>
							<para>If DirPath is a library and: <itemizedlist>
									<listitem>
										<para>Topic is "file", all objects except files in the
											library are returned, postfixed with their object types,
											for example <emphasis role="bold"
											>PROGRAM.PGM</emphasis>; </para>
									</listitem>
									<listitem>
										<para>Topic is "dir", all file names in the library are
											returned, without postfixes; no other names (of object
											types) are returned; </para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>If DirPath is a file in a library (that is, <emphasis role="bold"
									>library/.file</emphasis>, without a member name before the
								period) and: <itemizedlist>
									<listitem>
										<para>Topic is "file", all member names of the file are
											returned, without postfixes; </para>
									</listitem>
									<listitem>
										<para>Topic is "dir", nothing is returned, because files
											cannot contain anything other than members. </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On z/OS, DirPath can return files or subdirectories in an HFS, datasets or
						prefixes, or PDS file members. The objects returned depend on the platform
						prefix specified in DIrPath, whether the notation indicates a partioned file
						system (PDS or PDSE), as well as the value of Topic. </para>
					<para>On HFS, $dirlist works as it does on other platforms. However, on
						datasets, its behavior is different. it is also possible to specify DATASET
						or MEMBER as the Topic parameter.</para>
					<para>For more information, see $dirlist and $ldirlist on z/OS </para>
				</sect2>
				<sect2>
					<title>Example: Retrieving and Displaying Directory Contents</title>
					<para> The following Proc code retrieves the files in the directory <emphasis
							role="bold">drinks\tea</emphasis> in the current working directory and
						displays the files in the message frame line-by-line: </para>
					<programlisting role="uniface"><![CDATA[variables
string vFilePath, vContent
numeric N
endvariables
$dir$ = "drinks\tea"
; or $dir$ = "drinks/tea"
; or $dir$ = "[drinks.tea]"
vContent = $dirlist($dir$,"File")
putmess "Files in directory '%%$dir$':"
N = 1
getitem vFilePath, vContent, N
while ($status &gt; 0)
putmess " %%vFilePath%%%"
N = N + 1
getitem vFilePath, vContent, N
endwhile
end
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_disable">
				<title>$disable</title>
				<para>Return or set the <emphasis role="italic">selectable</emphasis> status of a
					menu item. </para>
				<sect2>
					<title>Syntax</title>
					<para>$disable </para>
					<para>$disable = Expression </para>
					<para>set | reset $disable </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Return Values</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Menu item is selectable</entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> Menu item is currently not selectable</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Predisplay trigger of form components (and in service,
						session service, entity service, and report components that are not
						self-contained).</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $disable is used to make a menu item selectable or
						unselectable: </para>
					<itemizedlist>
						<listitem>
							<para>Set the value to 1 to make the menu item unselectable; the menu
								accelerator key is also disabled. An unselectable menu item appears
								dimmed when the menu is displayed. </para>
						</listitem>
						<listitem>
							<para>Set the value to 0 to make the menu item selectable. </para>
						</listitem>
					</itemizedlist>
					<para>You can also use $disable as the target in the left side of an assignment.
						For example: </para>
					<programlisting role="uniface"><![CDATA[$disable=!$disable ]]></programlisting>
					<para>Since $disable is essentially a Boolean function, when <emphasis
							role="italic">Expression </emphasis>evaluates to a nonzero value,
						$disable becomes 1. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example makes a menu item unselectable: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Predisplay
set $disable ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_display">
				<title>$display</title>
				<para>Return the name of the current display device translation table. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$display</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Name of the device translation table being used for display. </para>
					<table>
						<title>Table 1. Values commonly returned by $procerror following
							$display</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -33 </entry>
									<entry> &lt;UGENERR_BATCH_ONLY&gt; </entry>
									<entry> Statement not allowed in batch mode. Use a test on
										$batch to avoid this. </entry>
								</row>
								<row>
									<entry> -1401 </entry>
									<entry> &lt;UPROCERR_PROMPT&gt; </entry>
									<entry> Prompted field not valid. </entry>
								</row>
								<row>
									<entry> -1402 </entry>
									<entry> &lt;UPROCERR_STATEMENT&gt; </entry>
									<entry> Statement not allowed in this trigger. The display
										statement is not in an Execute trigger.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>For more information on how a device translation table is determined, see
						Device Translation Tables . </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_displaylength">
				<title>$displaylength</title>
				<para>Return the display length of a String when displayed in the system character
					set. </para>
				<para>Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$displaylength</command>(String)</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para> String—string, or a field (or indirect reference to a field), a variable,
						or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Display length of the String when displayed in the system character set,
						expressed in bytes.. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_e">
				<title>$e</title>
				<para> Introduced in: U8 </para>
				<para>Return the value of e. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$e</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Value of e.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $e function returns the mathematical value of e (2.718...). </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following shows an example using the function $e: </para>
					<programlisting role="uniface"><![CDATA[$EULER$=$e()
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_editmode">
				<title>$editmode</title>
				<para> Introduced in: U8 </para>
				<para>Return or set the edit mode of a form component. </para>
				<sect2>
					<title>Syntax</title>
					<para> $editmode {= EditType} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> EditType—values that determine the mode. See <emphasis role="italic"
							>Return Values</emphasis>. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Return Values</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Edit mode, that is, values can be retrieved and
											changed</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Query mode, that is, values can be entered as
											profile data, but retrieved values cannot be modified.
											This mode can also be set using a run/query statement or
											by setting the QUERY instance property when the form is
											created with the newinstance statement.</entry>
									</row>
									<row>
										<entry> 2 </entry>
										<entry> Display mode, that is, values cannot be entered by
											the user. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components. </para>
				</sect2>
				<sect2>
					<title>Initial Value</title>
					<para>The initial value for $editmode is determined by how the form was
						activated and displayed:</para>
					<itemizedlist>
						<listitem>
							<para>Form activated with an instance property of DISPLAY=TRUE,
								$editmode returns 2 (Display mode). </para>
						</listitem>
						<listitem>
							<para>Form activated with an instance property of QUERY=TRUE, $editmode
								returns 1 (Query mode). </para>
						</listitem>
						<listitem>
							<para>Form has component type behavior Limited (that is, it is query
								only), $editmode returns 1 (Query mode). </para>
						</listitem>
						<listitem>
							<para>Form has been set in idle mode by being started by the display
								statement, $editmode returns 2 (Display mode). </para>
						</listitem>
						<listitem>
							<para>Form has been set in idle mode in any other way, then $editmode
								returns 0 (Edit mode). </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Setting Form to Display Mode </title>
					<para>The following example starts a form in display mode: </para>
					<programlisting role="uniface"><![CDATA[operation displayCustomer
; Start display mode for this form.
$editmode = 2 ; DISPLAY
edit/modal
end]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Changing from Edit Mode to Display Mode </title>
					<para>The following example shows how to change from edit mode to display mode: </para>
					<programlisting role="uniface"><![CDATA[operation doStore
;- store the data and
;- keep the user from making any more changes.
store
;- TODO: error trapping ...
$editmode = 2 ; DISPLAY
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_empty">
				<title>$empty</title>
				<para>Return the empty frame status for an entity or named area frame. </para>
				<sect2>
					<title>Syntax</title>
					<para> $empty{( Frame )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Frame </emphasis>—name of a named area frame or
						entity; can be a literal name, string, variable, function, parameter. If
						omitted, the current entity or its named area frame is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values Returned by $empty</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 2 </entry>
										<entry> Frame contains only the empty default occurrence,
											and the printing property for Frame has Suppress Print
											if Empty turned on. </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Frame contains only the empty default occurrence,
											and the printing property for Frame has Suppress Print
											if Empty turned off. . </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> The Frame contains at least one occurrence with data
											in it. </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> The Frame does not exist. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service, session service,
						and entity service components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $empty allows you to determine whether the named area frame
						or entity specified by Frame is empty; that is, if it contains only the
						default empty occurrence and no data has been entered. If the default
						occurrence contains declarative initial values, it is still considered
						empty. An occurrence that was created with creocc is considered to be a user
						occurrence that contains data. </para>
					<para>You can use the $empty function to determine whether to print a break
						frame when there is no data in <emphasis role="italic">Frame </emphasis>.
						This is often preferable to printing an empty entity or named area frame. </para>
					<para>It makes most sense to test whether an entity has occurrences associated
						with it before you attempt to print it. For example, in the Occurrence Gets
						Focus trigger of an outer entity, you can test whether any (or all) inner
						entities have occurrences associated with them. </para>
				</sect2>
				<sect2>
					<title>Example: Printing Break Frames Based on $empty </title>
					<para>The following example prints the break frame NO_INVOICES if there are no
						occurrences of the inner entity INVOICES: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
; entity: CUSTOMERS (the outer entity)
if ($empty(INVOICES) = 2)
   printbreak "NO_INVOICES"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_encode">
				<title>$encode</title>
				<para> Introduced in: U9 </para>
				<para>Encode or encrypt the data.</para>
				<sect2>
					<title>Syntax</title>
					<para> $encode ( Algorithm, Source{ , Key{ , Mode , InitializationVector } })
					</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Algorithm—encoding or encryption algorithm; see <emphasis
										role="italic">Supported Algorithms</emphasis> below. </para>
							</listitem>
							<listitem>
								<para>Source—string, variable, or field containing the data to be
									encoded or encrypted. </para>
							</listitem>
							<listitem>
								<para>Key—secret key, required if Algorithm specifies a Hash Message
									Authentication Code (HMAC) or block cipher. The length of the
									key must be appropriate to the algorithm. </para>
							</listitem>
							<listitem>
								<para>Mode—block cipher modes of operation; one of: <itemizedlist>
										<listitem>
											<para>ECB—Electronic codebook (default) </para>
										</listitem>
										<listitem>
											<para>CBC—Cipher-block chaining </para>
										</listitem>
										<listitem>
											<para>CFB—Cipher feedback </para>
										</listitem>
										<listitem>
											<para>OFB—Output feedback </para>
										</listitem>
										<listitem>
											<para>CTR—Counter </para>
										</listitem>
										<listitem>
											<para>CBC_CTS—CBC cipher text stealing </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>InitializationVector—a unique data block, such as a time stamp
									or random number, used in combination with the key to produce
									unique output from the same key. Required for all modes except
									ECB </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns encoded or encrypted data in the Uniface raw data type, unless the
						Algorithm is BASE64, HEX, URL or USTRING, in which case a data is returned
						as a Uniface string data type. </para>
					<para>The returned data may contain the null byte (0x00), so the return value is
						in the Uniface Raw data type, which is able to handle this. If you need to
						get the data in the string data type, then you can convert it from raw to
						string data data type using $encode with the USTRING algorithm. </para>
					<para>Uniface's internal encoding is UTF-8, so if the input is a string, the
						converted data will be a conversion of the UTF8 representation of that
						string. If the output is a string, the input must be an encrypted or encoded
						form of UTF-8. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. Some errors provide more detailed information in the
						ADDITIONAL list item in $procerrorcontext. </para>
					<table>
						<title>Table 1. Values of $procerror commonly returned by $encode </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1780 </entry>
									<entry> UENCERR_NO_ALGORITHM</entry>
									<entry> Algorithm not found.</entry>
								</row>
								<row>
									<entry> -1781 </entry>
									<entry> UENCERR_NO_SOURCE </entry>
									<entry> Source not found. </entry>
								</row>
								<row>
									<entry> -1782 </entry>
									<entry> UENCERR_NO_KEY </entry>
									<entry> Key not found. </entry>
								</row>
								<row>
									<entry> -1783 </entry>
									<entry> UENCERR_NO_IV</entry>
									<entry> IV not found. </entry>
								</row>
								<row>
									<entry> -1784 </entry>
									<entry> UENCERR_INVALID_ALGORITHM </entry>
									<entry> Invalid algorithm name. </entry>
								</row>
								<row>
									<entry> -1785 </entry>
									<entry> UENCERR_INVALID_MODE </entry>
									<entry> Invalid mode name. </entry>
								</row>
								<row>
									<entry> -1786 </entry>
									<entry> UENCERR_INVALID_KEY_LENGTH</entry>
									<entry> Invalid key length. The key must have a specific length
										that depends on the algorithm. </entry>
								</row>
								<row>
									<entry> -1790 </entry>
									<entry> UENCERR_INVALID_URAW_DATA </entry>
									<entry> Invalid Uniface raw data. </entry>
								</row>
								<row>
									<entry> -1791 </entry>
									<entry> UENCERR_GENERAL </entry>
									<entry> Encode/decode general error </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$encode supports a variety of commonly used algorithms to encode and
						encrypt data, including cryptographic hash functions, hash message
						authentication codes (HMAC), and block ciphers. This can be useful in
						information security applications in which data integrity needs to be
						protected or data needs to be verified or authenticated. For example, you
						can use $encode to: </para>
					<itemizedlist>
						<listitem>
							<para>Encrypt data before storing it in a database. You can then use
								$decode when retrieving the information. </para>
						</listitem>
						<listitem>
							<para>Encode confidential data such as credit card numbers or passwords
								using hash functions such as MD5 to protect their data integrity and
								for authentication. </para>
						</listitem>
						<listitem>
							<para>Create digital signatures for authentication to verify data
								integrity and authenticity of data. </para>
						</listitem>
					</itemizedlist>
					<para>$encode also supports encoding schemes such as hexadecimal and Base64, so
						it can be used to convert data from one encoding scheme to another. It can
						also be used to convert data between Uniface raw and string data types using
						Uniface's internal encoding, which is UTF-8. </para>
					<para>The Source, Key, and InitializationVector parameters can specify a string,
						variable, or field. If the data type of a variable or field is Raw, it is
						evaluated as data type raw. Otherwise, it is evaluated as data type string .
						Optional parameters are ignored if they are irrelevant. </para>
				</sect2>
				<sect2>
					<title>Supported Algorithms</title>
					<para>The $encode supports the most commonly used cryptographic hash functions,
						hash message authentication codes (HMAC), block ciphers, and encoding
						schemes.</para>
					<para>Hash functions take a string of any length as input and produce a
						fixed-length hash value. This can be used to verify and authenticate data
						because any change to the source produces a very different hash value. They
						are used for information security applications, such as digital signatures
						and message authentication codes. </para>
					<table>
						<title>Table 2. Hash Functions</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> MD4 </entry>
									<entry> MD4 (Message Digest 4) </entry>
								</row>
								<row>
									<entry> MD5 </entry>
									<entry> MD5 (Message Digest 5) </entry>
								</row>
								<row>
									<entry> SHA1 </entry>
									<entry> SHA-1 (Secure Hash Algorithm 1) </entry>
								</row>
								<row>
									<entry> SHA224 </entry>
									<entry> SHA-224 (Secure Hash Algorithm 224 bit) </entry>
								</row>
								<row>
									<entry> SHA256 </entry>
									<entry> SHA-256 (Secure Hash Algorithm 256 bit) </entry>
								</row>
								<row>
									<entry> SHA384 </entry>
									<entry> SHA-384 (Secure Hash Algorithm 384 bit) </entry>
								</row>
								<row>
									<entry> SHA512 </entry>
									<entry> SHA-512 (Secure Hash Algorithm 512 bit) </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Hash Message Authentication Codes (HMAC) use a hash function in
						combination with a secret key to create a message authentication code that
						can be used to verify the data integrity and authenticity of data. Only
						systems that also possess the secret key can detect changes to the message
						content.</para>
					<table>
						<title>Table 3. Hash Message Authentication Codes</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> HMAC_MD5 </entry>
									<entry> HMAC using MD5 hash</entry>
								</row>
								<row>
									<entry> HMAC_SHA1 </entry>
									<entry> HMAC using SHA-1 hash</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>A block cipher takes a fixed-length block of data and uses a secret key to
						encrypt the data to a block of encrypted data of the same length. The data
						can be decrypted with the same key. </para>
					<table>
						<title>Table 4. Block Ciphers</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> AES </entry>
									<entry> Advanced Encryption Standard </entry>
								</row>
								<row>
									<entry> RIJNDAEL </entry>
									<entry> Same as AES </entry>
								</row>
								<row>
									<entry> DES </entry>
									<entry> Data Encryption Standard </entry>
								</row>
								<row>
									<entry> TDES </entry>
									<entry> Triple Data Encryption Algorithm (TDEA) as known as
										Triple DES </entry>
								</row>
								<row>
									<entry> DES_EDE3 </entry>
									<entry> Same as TDES </entry>
								</row>
								<row>
									<entry> DES_EDE2 </entry>
									<entry> Variant of TDES with 16 byte key length </entry>
								</row>
								<row>
									<entry> DESX </entry>
									<entry> Variant of DES by XORing extra keys </entry>
								</row>
								<row>
									<entry> DES_XEX3 </entry>
									<entry> Same as DESX </entry>
								</row>
								<row>
									<entry> BLOWFISH </entry>
									<entry> Blowfish </entry>
								</row>
								<row>
									<entry> TWOFISH </entry>
									<entry> Twofish </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The following encoding schemes can be useful </para>
					<table>
						<title>Table 5. Miscellaneous Encoding Schemes</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> BASE64 </entry>
									<entry> Base64 encoding scheme. </entry>
								</row>
								<row>
									<entry> HEX </entry>
									<entry> Hexadecimal encoding scheme. </entry>
								</row>
								<row>
									<entry> URL </entry>
									<entry> URL encoding scheme (also known as <emphasis
											role="italic">percent encoding</emphasis>). Used to
										represent characters which are otherwise not allowed in URIs
										using allowed characters. </entry>
								</row>
								<row>
									<entry> URAW </entry>
									<entry> Uniface raw data type conversion. Used to convert
										Uniface data type String to Uniface Raw data type. </entry>
								</row>
								<row>
									<entry> USTRING </entry>
									<entry> Uniface string data type conversion. Used to convert
										Uniface data type Raw to data type String </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Block Ciphers</title>
					<para>Except for the ECB mode, the Mode requires an initialization vector (IV).
						This need not be secret but it must never be reused with the same key.
						Otherwise it could break the security of the source data. For practical use,
						you can create an IV by a random scheme or a time stamp and store it
						together with the encrypted data, then use them when you decrypt the data.
						The IV can be any length but if it is longer than the block size, it will be
						truncated to the block size. The block size depends on the algorithm. </para>
					<table>
						<title>Table 6. Required Key length and Block Size for Block Ciphers</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Algorithm</entry>
									<entry> Key Length </entry>
									<entry> Effective Key Length </entry>
									<entry> Block size </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> AES (RIJNDAEL)</entry>
									<entry> 16, 24 or 32 bytes</entry>
									<entry> </entry>
									<entry> 16 bytes </entry>
								</row>
								<row>
									<entry> DES</entry>
									<entry> 8 bytes</entry>
									<entry> 56 bits</entry>
									<entry> 8 bytes </entry>
								</row>
								<row>
									<entry> TDES (DES_EDE3) </entry>
									<entry> 24 bytes </entry>
									<entry> 168 bits</entry>
									<entry> 8 bytes </entry>
								</row>
								<row>
									<entry> DES_EDE2 </entry>
									<entry> 16 bytes</entry>
									<entry> 112 bits</entry>
									<entry> 8 bytes </entry>
								</row>
								<row>
									<entry> DESX (DES_XEX3)</entry>
									<entry> 24 bytes </entry>
									<entry> maximum 119 bits </entry>
									<entry> 8 bytes </entry>
								</row>
								<row>
									<entry> BLOWFISH</entry>
									<entry>1 to 56 bytes<footnote>
											<para>Officially BLOWFISH supports only 4 to 56 bytes
												key length. A key shorter than 4 bytes is available
												for compatibility with other cryptographic
												modules.</para>
										</footnote></entry>
									<entry/>
									<entry> 8 bytes </entry>
								</row>
								<row>
									<entry> TWOFISH </entry>
									<entry> 1 to 32 bytes<footnote>
											<para>A key shorter than those lengths is padded with
												zeroes until the next larger effective key
												length.</para>
										</footnote>
									</entry>
									<entry> 16, 24, 32 bytes </entry>
									<entry> 16 bytes</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>A block cipher works on a fixed block size, but source data can be in a
						variety of lengths. ECB and CBC mode require that the final block be padded
						before encryption, so Uniface uses the PKCS7 padding scheme to do so. For
						CBC_CTS mode, the source data must be longer than the block size. </para>
				</sect2>
				<sect2>
					<title>Example: Encoding Using Hash Functions and HMAC</title>
					<programlisting role="uniface"><![CDATA[; Get the MD5 hash.
vHash = $encode("MD5", "abc")
; Get the SHA1 hash in the hexadecimal format.
vSha1 = $encode("SHA1", "abc")
vHexStr = $encode("HEX", vSha1)
; Get the HMAC with SHA1 hash.
vHmac = $encode("HMAC_SHA1", F1, "vKey1")]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Encrypt and Decrypt Using Triple DES Block Cipher in ECB
						Mode</title>
					<programlisting role="uniface"><![CDATA[; Encrypt and decrypt the data by Triple DES in ECB mode.
; Output of $decode (vDec) should be the same as input of $encode (vRawSource).
vEnc = $encode("TDES", vRawSource, vKey2)
vDec = $decode("TDES", vEnc, vKey2)]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Encrypt and Decrypt String Data</title>
					<para>$decode returns raw data, so you can use $encode with the USTRING
						algorithm to convert it to a string data type using Uniface internal
						encoding, UTF-8. </para>
					<programlisting role="uniface"><![CDATA[vEnc = $encode("BLOWFISH", "~home", "secret key")  ;encrypt the data
vRawData = $decode("BLOWFISH", vEnc, "secret key") ;decrypt the data
vStrgData = $encode("USTRING", vRawData)           ;convert the decrypted data from Raw to String ]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Create and Use an Initialization Vector</title>
					<programlisting role="uniface"><![CDATA[; Create an initialization vector.
vIv = $datim
; Encrypt the source data by AES in CBC mode.
vEnc = $encode("AES", vSource, vKey, "CBC", vIv)
; Decrypt the encrypted data.
; DECRYPT must be the same as SOURCE.
vDecrypt = $decode("AES", vEnc, vKey, "CBC", vIv)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_entinfo">
				<title>$entinfo</title>
				<para>Return information about an entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> $entinfo ( Entity , Topic ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. </para>
							</listitem>
							<listitem>
								<para><emphasis role="italic">Topic </emphasis>—valid topic name
									(see <emphasis role="italic">Return values</emphasis>); can be a
									string, or a field (or indirect reference to a field), a
									variable, or a function that evaluates to a string. The topic
									name is not case-sensitive; you can use uppercase or lowercase
									letters, or any combination of these, to increase
									readability.</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values Returned by $entinfo per Topic</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Topic </entry>
									<entry> Return value </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> DBMSPATH </entry>
									<entry> The three-letter path abbreviation for the DBMS path
										assigned to <emphasis role="italic">Entity </emphasis>in the
										application model (for example "ORA" or "IDF") or the string
										"Not in Database" if <emphasis role="italic">Entity
										</emphasis>is defined as Not in Database. </entry>
								</row>
								<row>
									<entry> INNER </entry>
									<entry> A list of entities painted directly inside <emphasis
											role="italic">Entity </emphasis>. An empty string ("")
										is returned if there are no inner entities. </entry>
								</row>
								<row>
									<entry> OBJECTSERVICE </entry>
									<entry> The entity service name defined for the requested object
										Entity. An empty string ("") is returned if Entity is not an
										object entity. </entry>
								</row>
								<row>
									<entry> OUTER </entry>
									<entry> The name of the outer entity. An empty string ("") is
										returned if <emphasis role="italic">Entity </emphasis>is the
										outer entity. This replaces the function $outer. </entry>
								</row>
								<row>
									<entry> PAINTEDFIELDS </entry>
									<entry> A list of fields painted within this entity. </entry>
								</row>
								<row>
									<entry> SUPERTYPE </entry>
									<entry> The name of the supertype entity for <emphasis
											role="italic">Entity </emphasis>. An empty string ("")
										is returned if there is no supertype (that is, <emphasis
											role="italic">Entity </emphasis>is the supertype.)
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>An empty string ("") is returned if an error occurred, in which case,
						$procerror contains a negative value that identifies the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$entinfo</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> UPROCERR_ENTITY</entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1110 </entry>
									<entry> UPROCERR_TOPIC</entry>
									<entry> Topic name not known. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $entinfo function is especially useful in writing generalized
						operations and global Procs where the information needs to be determined at
						run time rather than built into the component. </para>
				</sect2>
				<sect2>
					<title>Example: Setting Field Colors of the Current Entity </title>
					<para>The following example sets the color for all painted fields of the current
						entity to yellow letters on a purple background. (PaintedFields is a global
						constant whose value is "PAINTEDFIELDS" .) </para>
					<programlisting role="uniface"><![CDATA[operation MAKE_COLORFUL
variables
   string LIST_OF_FIELDS
   string FIELD
endvariables
LIST_OF_FIELDS = $entinfo($entname, PaintedFields)
while (LIST_OF_FIELDS != "")
   getitem FIELD, LIST_OF_FIELDS, -1
   ; give this field bright colors
   fieldvideo FIELD, "COL=53"
   delitem LIST_OF_FIELDS, -1
endwhile
end
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_entityproperties">
				<title>$entityproperties</title>
				<para> Introduced in: U8 </para>
				<para>Return or set the current grid widget properties of an entity. </para>
				<sect2>
					<title>Syntax</title>
					<para>$entityproperties ( Entity ) </para>
					<para>$entityproperties ( Entity ) = Properties </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity name; optional; can be a literal name, a string,
									a variable, function, parameter, or indirect reference to a
									field containing the name. It can optionally contain a qualified
									model name (for example, MYENT.MYMODEL). </para>
							</listitem>
							<listitem>
								<para>Properties—string or variable containing a GOLD-separated list
									of desired properties and their corresponding values, in the
									format: </para>
								<para>Property = Value { <emphasis role="underline">;</emphasis>
									Property n = Value n} </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>Empty string ("") if an error occurred or if the default
								properties have not been changed. </para>
						</listitem>
						<listitem>
							<para>Associative list containing the widget properties that have been
								changed from the default widget properties for the specified entity.
								Widget properties can be changed in Define Widget Properties form or
								by the $entityproperties function itself. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> If an error occurs, $procerror does
						not return a value to indicate the exact error. For example, if Entity does
						not exist on the form, you will receive a compiler warning, but not a
						run-time error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The properties set with $entityproperties: </para>
					<itemizedlist>
						<listitem>
							<para>Override <emphasis role="italic">all</emphasis> the properties
								that have been set in the Define Widget Properties form or with a
								previous $entityproperties assignment. Omitting a property causes
								that property to be reset. </para>
						</listitem>
						<listitem>
							<para>Are reset to the compiled values (that is, the default properties
								plus the properties set n the Define Widget Properties form) each
								time that a component is restarted (the Keep Data in Memory property
								is set <emphasis role="italic">off</emphasis>). </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Default Widget Properties</title>
					<para>Each widget has its own set of default properties that define its
						appearance and behavior; these default properties can vary depending on the
						GUI platform being used. The GUI's default widget properties can be
						overridden by definitions in the system initialization file, for example, in
						the [WIDGETS] section of an <emphasis role="bold">.ini</emphasis> file. </para>
					<para>The GUI's default widget properties, along with the properties defined in
						the system initialization file, determine the widget's default properties.
						If no further properties are defined on the Define Widget Properties form
						(that is, if all fields are left empty, undetermined, or with the value
						Default), the default properties determine the behavior and appearance of
						the widget at run time. (In this case, $entityproperties returns an empty
						("") string). </para>
				</sect2>
				<sect2>
					<title>Changing the Default Widget Properties</title>
					<para>If a widget's default properties are changed in the Define Widget
						Properties form, the altered properties are returned in $entityproperties.
						Only the properties that have been changed in the Define Widget Properties,
						including properties that cannot be set dynamically, are returned; the
						default properties are not available. </para>
					<para>At run time, all the properties associated with a widget can be changed,
						up until the time that the form is presented to the user (with edit or
						display). After this, only the widget's <emphasis role="italic">dynamic
						</emphasis>properties can be changed. (For more information, see the widget
						descriptions.)</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following statement turns row headers and numbering off and makes
						field borders visible around each cell in the grid.</para>
					<programlisting role="uniface"><![CDATA[;Execute trigger
...
$entityproperties = "RowHeadersVisible= F<emphasis role="underline">;</emphasis>RowNumbering = F<emphasis role="underline">;</emphasis>FieldBorders = T"
edit]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_entname">
				<title>$entname</title>
				<para>Return the name of the current entity or check for the existence of an entity
					in the component. </para>
				<sect2>
					<title>Syntax</title>
					<para> $entname {( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—name of an entity; can be a string, or field, variable, function,
						or parameter that evaluates to a string that contains the name of an entity.
						If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>If Entity is not present, $entname returns the name of the
									current entity (in uppercase). If there is no current entity
									(that is, if the last node of the active path is not a field or
									entity), $entname returns an empty string (""). </para>
							</listitem>
							<listitem>
								<para>If Entity is present, $entname returns the name of the entity
									if it is present in the component, otherwise $entname returns an
									empty string (""). </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The $entname function is useful when you are writing global Procs,
						because it allows you to generalize your code. It is also useful to examine
						this function when you are using the Proc debugger to step through Proc
						statements. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows a global Proc that can be used in the
						Add/Insert Occurrence trigger to insert a new occurrence before the first
						occurrence or to add a new occurrence after the last occurrence: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Add/Insert Occurrence
call AI_OCC()
if ($rettype = 65)
   creocc $entname, -1
else
   creocc $entname, 1
endif
done]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_error">
				<title>$error</title>
				<para>Return the Uniface message number for the error. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$error</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Uniface message number for the current field or entity data input error
						error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para/>
					<para>Allowed only in On Error trigger (entity-level or field-level) in form,
						service, session service, entity service, and report components. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>Depending on the error code, you may choose to implement functionality
						above that of providing a meaningful error message. In the following
						example, a form listing all the valid codes is displayed if the user enters
						a code that is not allowed: </para>
					<programlisting role="uniface"><![CDATA[; trigger: On Error
if ($error = 0126)
   message "Incorrect code. Select one from list with ^ACCEPT."
   run "CODES" ;start other form
   if ($status = 1) ;user did ^ACCEPT
      TYPECD = $1 ;copy selected value back&amp;#SPACE;down
      return (0) ;allow the user to continue
   else
      message "No code selected."
      return (-1) ;still wrong, so prevent leaving
   endif
else
   message $text("%%$error")&amp;#SPACE;;catch all other errors
   return (-1)
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_exp">
				<title>$exp</title>
				<para> Introduced in: U8 </para>
				<para>Return the exponential of X (e X ). </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$exp</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. </para>
					<para>The result must be in the range 10 -9999 through 10 9999 , which means
						that X must be in the range (approximately) -23,025.85 through +23,025.85.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Exponential value of X. </para>
					<para> If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following $exp and
							$exp10</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1207 </entry>
									<entry> &lt;UPROCERR_UNDERFLOW&gt; </entry>
									<entry> Underflow. </entry>
								</row>
								<row>
									<entry> -1208 </entry>
									<entry> &lt;UPROCERR_OVERFLOW&gt; </entry>
									<entry> Overflow. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $exp returns the exponential of X, that is, e raised to the
						power X. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the exponential of the given expression: </para>
					<programlisting role="uniface"><![CDATA[; is &gt; nth root of n for all positive n
$EXPOF$ = $exp(1 / e())]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_exp10">
				<title>$exp10</title>
				<para> Introduced in: U8 </para>
				<para>Return the base 10 exponential of X (10X).</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$exp10</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> X—numeric constant from -9999 through +9999, or a field (or indirect
						reference to a field), variable, function, or expression that evaluates to a
						numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Base 10 exponential of X (10 raised to the power X). </para>
					<para> If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following $exp and
							$exp10</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1207 </entry>
									<entry> &lt;UPROCERR_UNDERFLOW&gt; </entry>
									<entry> Underflow. </entry>
								</row>
								<row>
									<entry> -1208 </entry>
									<entry> &lt;UPROCERR_OVERFLOW&gt; </entry>
									<entry> Overflow. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The result of $exp10 must be in the range 10-9999 through 109999, which
						means that X must be in the range -9999 through +9999. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_expression">
				<title>$expression</title>
				<para> Introduced in: U8</para>
				<para>Return the result of evaluating a nonconditional expression. </para>
				<sect2>
					<title>Syntax</title>
					<para>$expression ( Expression {, DataList}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Expression—any legal non-conditional Proc expression or
									compiled non-conditional expression; can be a string, or a field
									(or indirect reference to a field), a variable, or a function
									that evaluates to a string. <itemizedlist>
										<listitem>
											<para>Only Proc allowed in the current component type
												can be used. For example, an expression that
												includes $fieldendmod cannot be used in a report or
												service. </para>
										</listitem>
										<listitem>
											<para>Each operand in the expression must evaluate
												directly to a numeric value, so an operand cannot
												contain yet another expression. </para>
										</listitem>
										<listitem>
											<para>Any field referred to must be included in the
												field list for the component entity. </para>
										</listitem>
										<listitem>
											<para>Variables included in Expression must be in scope.
											</para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>DataList—optional associative list used to substitute
									variables (or fields) in the expression with data. This works
									just like the string substitution. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> $expression returns the result of evaluating Expression. </para>
					<para> If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following $condition
							and $expression</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1301 </entry>
									<entry> &lt;UPROCERR_SYNTAX&gt; </entry>
									<entry> Syntax error. </entry>
								</row>
								<row>
									<entry> -1302 </entry>
									<entry> &lt;UPROCERR_SERVICE&gt; </entry>
									<entry> Function not allowed in service. </entry>
								</row>
								<row>
									<entry> -1303 </entry>
									<entry> &lt;UPROCERR_REPORT&gt; </entry>
									<entry> Function not allowed in report. </entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
									<entry> Function not allowed, unknown context. </entry>
								</row>
								<row>
									<entry> -1305 </entry>
									<entry> &lt;UPROCERR_EXPRESSION&gt; </entry>
									<entry> Expression not allowed. </entry>
								</row>
								<row>
									<entry> -1306 </entry>
									<entry> &lt;UPROCERR_CONDITION&gt; </entry>
									<entry> Condition not allowed. </entry>
								</row>
								<row>
									<entry> -1307 </entry>
									<entry> &lt;UPROCERR_EXTRACTION_EXPR&gt; </entry>
									<entry> Extraction expression is a condition. </entry>
								</row>
								<row>
									<entry> -1308 </entry>
									<entry> &lt;UPROCERR_INDIRECTION&gt; </entry>
									<entry> Indirection followed by brackets. </entry>
								</row>
								<row>
									<entry> -1309 </entry>
									<entry> &lt;UPROCERR_PARENTHESES&gt; </entry>
									<entry> Operand followed by parentheses. </entry>
								</row>
								<row>
									<entry> -1310 </entry>
									<entry> &lt;UPROCERR_BRACKETS&gt; </entry>
									<entry> Operand followed by square brackets. </entry>
								</row>
								<row>
									<entry> -1311 </entry>
									<entry> &lt;UPROCERR_UNRESOLVED_OPERAND&gt; </entry>
									<entry> A field, parameter, or variable could not be found in
										current context. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $expression function evaluates a non-conditional expression. The
						expression is parsed at run time and evaluated as if it were a compiled
						expression; in other words, the expression is <emphasis role="italic"
							>interpreted </emphasis>. </para>
				</sect2>
				<sect2>
					<title>Example: Optional Argument List for $expression</title>
					<para>The following example explains the use of the optional argument DataList
						for expression: </para>
					<programlisting role="uniface"><![CDATA[$2="one=1;two=2;three=3"
$1=$expression("one+two+three", $2)]]></programlisting>
					<para> $1 evaluates to the value 6. </para>
				</sect2>
				<sect2>
					<title>Example: Compiling Proc at Runtime</title>
					<para>The following example demonstrates the use of proccompile, $condition, and
						$expression. proccompile is used to check the entered business rules in the
						DO_DISCOUNT and DISCOUNT fields, $condition is used to evaluate DO_DISCOUNT,
						and $expression is used to return the result of DISCOUNT. </para>
					<para>The field DO_DISCOUNT contains the condition for a discount and DISCOUNT
						contains the actual expression for the discount. At run time, values can be
						entered for both fields that will determine whether a discount should be
						given, and the actual amount of the discount. </para>
					<para>For example, the following line should be entered in the field DO_DISCOUNT
						if a discount should be given when more then 100 articles are ordered (where
						the field AMOUNT contains the number of ordered articles): </para>
					<programlisting role="uniface"><![CDATA[AMOUNT&gt;100]]></programlisting>
					<para>And the following line should be entered in the field DISCOUNT if the
						actual discount is 10 percent of the total cost of the articles (where the
						field PRICE contains the unit price of the ordered article): </para>
					<programlisting role="uniface"><![CDATA[0.1*AMOUNT*PRICE]]></programlisting>
					<para>The following Proc code checks the entered business rules and executes
						them accordingly: </para>
					<programlisting role="uniface"><![CDATA[entry total_cost
variables
   numeric vDiscount
endvariables
; This Proc entry calculates total cost of ordered article including discount
; Check syntax of discount condition in field DO_DISCOUNT
proccompile/condition DO_DISCOUNT, "FIELDS=AMOUNT"
if ($procerror &lt; 0)
   message/error "Incorrect syntax for discount condition (%%$procerror)"
   putmess $procerrorcontext
   return -1
endif
; Check discount condition
if ($condition($result)) ; Use compiled Proc in $result
; A discount should be given
; Check syntax of discount expression in field DISCOUNT
   proccompile/expression DISCOUNT, "FIELDS=AMOUNT<emphasis role="underline">!;</emphasis>PRICE"
   if ($procerror &lt; 0)
      message/error "Incorrect syntax for discount expression (%%$procerror)"
      putmess $procerrorcontext
      return -1
   endif
; Execute discount
; Use compiled Proc in $result
   vDiscount = $expression($result)
; Or, use uncompiled expression
; vDiscount = $expression(DISCOUNT)
else
; No discount should be given
; Set discount to 0
   vDiscount = 0
endif
COST = AMOUNT * PRICE - vDiscount
return 0
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fact">
				<title>$fact</title>
				<para> Introduced in: U8 </para>
				<para>Calculate the factorial of X (X!). </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$fact</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—positive integer constant, or a field (or indirect reference to a
						field), a variable, or a function or expression that can be converted to a
						positive, whole (integer) number. </para>
					<para>The result of $fact must be less than 1 * 10 9999 , which means that X
						must be positive and less than 3249. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Calculated factorial of X. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$fact</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1204 </entry>
									<entry> &lt;UPROCERR_NEGATIVE&gt; </entry>
									<entry> Negative value not allowed. </entry>
								</row>
								<row>
									<entry> -1206 </entry>
									<entry> &lt;UPROCERR_INTEGER&gt; </entry>
									<entry> Not an integer. </entry>
								</row>
								<row>
									<entry> -1208 </entry>
									<entry> &lt;UPROCERR_OVERFLOW&gt; </entry>
									<entry> Overflow. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the factorial of 13: </para>
					<programlisting role="uniface"><![CDATA[$FACTOR$ = $fact(13)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldcheck">
				<title>$fieldcheck</title>
				<para>Return or set the requirement for field checking. </para>
				<sect2>
					<title>Syntax</title>
					<para>$fieldcheck{( Field )} </para>
					<para>$fieldcheck{( Field )} = Expression </para>
					<para>set | reset $fieldcheck{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field name;optional;can be a literal name, string, variable,
						functions, parameter or reference to a field. It can optionally contain a
						qualified field name, for example MYFLD.MYENT. If omitted, the current field
						is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $fieldcheck</title>
							<tgroup cols="2">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> 0, if field checking is <emphasis role="italic">not
											</emphasis>currently enabled. </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> 1, if field checking is currently enabled. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
					<para>When $fieldcheck is used as the target of an assignment, $status is set: </para>
					<table>
						<title>Table 2. Values returned in $status </title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "" </entry>
									<entry> Field checking could not be enabled. This usually means
										that Field is not present, or does not exist. </entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> Field checking was successfully enabled. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 3. Values of $procerror Commonly Returned Following Field-Level
							Proc Functions</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$fieldcheck returns a value that indicates whether validation should be
						carried out for Field the next time it occurs. </para>
					<para>If $fieldcheck indicates that validation is demanded, validation is
						performed regardless of whether validation is actually required. (Validation
						is required when both $fieldmod and $fieldvalidation are 1, indicating that
						the field has been modified, but has not yet been validated). </para>
					<para>Validation can occur when the user leaves the field (for example, with
						^NEXT_FIELD, ^PREV_FIELD, or a mouse click); when an explicit validation
						statement is encountered (for example, validatefield); or when a store
						statement is encountered. It includes syntax checks, the activation of the
						Validate Field trigger, and, in forms only, the activation of the Leave
						Field trigger. After validation completes, $fieldcheck is set to 0. </para>
				</sect2>
				<sect2>
					<title>Changing the Value of $fieldcheck</title>
					<para>You can also use $fieldcheck as the target in the left-hand side of an
						assignment. Set $fieldcheck to 1 to require syntax checks for the specified
						field; set it to 0 to let Uniface take responsibility for validation. For
						example: </para>
					<programlisting role="uniface"><![CDATA[$fieldcheck=!$fieldcheck ]]></programlisting>
					<para>Since $fieldcheck is essentially a Boolean function, when Expression
						evaluates to a nonzero value, $fieldcheck becomes 1. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows this function being used in the Occurrence
						Gets Focus trigger: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
set $fieldcheck(CUST_NUMBER.CUSTOMER)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fielddbmod">
				<title>$fielddbmod</title>
				<para>Return the modification status of a database field. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fielddbmod{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field name; optional; can be a literal name, or a string, variable,
						function, parameter or indirect reference to a field containing the name. It
						can optionally contain a qualified field name, for example MYFLD.MYENT. If
						omitted, the current field is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $fielddbmod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 1 </entry>
										<entry> Modified. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> Not modified, not a database field, or a read-only
											field. </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
					<para>If an error occurs $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following Field-Level
							Proc Functions</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $fielddbmod function is set to 0 in the following
						circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>Each time a component is restarted (except when the component has
								Keep Data in Memory clicked <emphasis role="italic">on </emphasis>).
								I </para>
						</listitem>
						<listitem>
							<para>The following Proc statements <itemizedlist>
									<listitem>
										<para>clear </para>
									</listitem>
									<listitem>
										<para>erase </para>
									</listitem>
									<listitem>
										<para>release </para>
									</listitem>
									<listitem>
										<para>reload </para>
									</listitem>
									<listitem>
										<para>retrieve </para>
									</listitem>
									<listitem>
										<para>store </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Events that Modify a Field</title>
					<para>Events that cause a field to be recognized as modified include such things
						as: </para>
					<itemizedlist>
						<listitem>
							<para>The user entering a retrieve profile in an empty field. (This
								means that $fieldmod can be set to 1 <emphasis role="italic">before
								</emphasis>a retrieve has been performed.) </para>
						</listitem>
						<listitem>
							<para>The user changing the value of data that has been retrieved.
							</para>
						</listitem>
						<listitem>
							<para>Modification of a non-database occurrence made by a Proc
								assignment (=) without the /init switch. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example checks the value of $fielddbmod for the field
						DISCOUNT. If the value has been modified, the field TOTAL_PRICE is
						recalculated. The processing takes place in the Leave Modified Occurrence
						trigger, as the value of TOTAL_PRICE depends on several fields. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Modified Occurrence
if ($fielddbmod(DISCOUNT) = 1)
   TOTAL_PRICE = DISCOUNT * ORDER_SIZE * UNIT_PRICE
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fielddbvalue">
				<title>$fielddbvalue</title>
				<para>Return the original value of a field as it was retrieved from the database. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fielddbvalue{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field in the current occurrence of the current entity; optional;
						can be a literal name, or a string, variable, function, parameter, or
						indirect reference to a field. It can optionally contain a qualified field
						name, for example MYFLD.MYENT. If omitted, the current field is used.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Original field value as retrieved from the database. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") if an error occurs; $procerror contains a
									negative value that identifies the exact error. However, if the
									original field value is empty, $procerror is also empty. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$fielddbvalue</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1101 </entry>
										<entry> UPROCERR_FIELD</entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> UPROCERR_ENTITY</entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $fielddbvalue function is successful only if the occurrence was
						retrieved from a database and Field is a valid database field. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example can be used in the Validate Field trigger in an
						entity service: </para>
					<programlisting role="uniface"><![CDATA[$oldF1$ = $fielddbvalue(F1)
if (!$oldF1$ &amp;&amp; !$procerror)
   if (abs(F1 - $oldF1$)/F1 &gt; 10)
      return (-1) ;too big a change
   endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldendmod">
				<title>$fieldendmod</title>
				<para>Return the modification status of a field when the field is exited. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$fieldendmod</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Return Values</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> field has not been modified</entry>
									</row>
									<row>
										<entry> 1</entry>
										<entry> field has been modified or if $fieldendmod has been
											set for the current field.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Leave Field trigger of form components, .</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $fieldendmod indicates whether the user has modified data in the
						field. It is set to 0 in the following circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>When the user enters the field. </para>
						</listitem>
						<listitem>
							<para>By resetting the $fieldcheck function. </para>
						</listitem>
						<listitem>
							<para>When data of a field is modified in Proc. </para>
						</listitem>
						<listitem>
							<para>Each time a component is restarted (except when the component has
								Keep Data in Memory clicked <emphasis role="italic">on</emphasis>).
							</para>
						</listitem>
						<listitem>
							<para>By the following Proc statements <itemizedlist>
									<listitem>
										<para>clear </para>
									</listitem>
									<listitem>
										<para>erase </para>
									</listitem>
									<listitem>
										<para>release </para>
									</listitem>
									<listitem>
										<para>reload </para>
									</listitem>
									<listitem>
										<para>retrieve </para>
									</listitem>
									<listitem>
										<para>store </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
					<para>In contrast, the function $fieldmod indicates whether data has been
						modified during its lifetime in the component. For example, if the user
						modifies a field and leaves it, $fieldendmod is 1 (in the Leave Field
						trigger); $fieldmod is also 1. If the user then returns to the field and
						leaves it again without changing it, $fieldendmod is 0, while $fieldmod
						remains 1. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example checks the value of $fieldendmod , then checks to
						make sure that the value of the field is less than 120: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Field (of field AGE)
if ($fieldendmod = 1)
   if (AGE &gt;= 120)
      message "That is far too old!"
      return -1
   endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldindb">
				<title>$fieldindb</title>
				<para>Return an indication if a field is a database field. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fieldindb{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field name; optional; can be a literal nam, a string, or a
						variable, function, parameter or indirect reference to a field. It can
						optionally contain a qualified field name, for example MYFLD.MYENT. If
						omitted, the current field is used; in this case, $fieldindb can be used
						only in field-level triggers. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $fieldindb</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 1 </entry>
										<entry> The field is a database field (TRUE). </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> The field is not a database field (FALSE). </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$fieldindb</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $fieldindb returns an indication if a field is a database
						field, that is, if the Characteristics property of the component field is
						Database. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc code causes MYFIELD to blink if it is a database field: </para>
					<programlisting role="uniface"><![CDATA[if ($fieldindb(MYFIELD.MYENTITY))
   fieldvideo MYFIELD.MYENTITY, "BLI"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldinfo">
				<title>$fieldinfo</title>
				<para>Return information about a field. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fieldinfo ( Field , Topic ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—field name; can be a literal name, a string, or a field
									(or indirect reference to a field), a variable, or a function
									that evaluates to a string. Fieldcan optionally contain a
									qualified field name, for example MYFLD.MYENT. </para>
							</listitem>
							<listitem>
								<para>Topic—valid topic name (see <emphasis role="italic">Return
										Values</emphasis>); can be a string, or a field (or indirect
									reference to a field), a variable, or a function that evaluates
									to a string. The topic name is not case-sensitive; you can use
									uppercase or lowercase letters, or any combination of these, to
									increase readability. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values Returned by $fieldinfo per Topic</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Topic </entry>
									<entry> Return Value </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> CHARACTERISTICS </entry>
									<entry> One of the following strings, as appropriate:
										"Database", "Non-database", "Control", or "Boilerplate"
									</entry>
								</row>
								<row>
									<entry> PAINTED </entry>
									<entry> 1, if Field is painted (TRUE) 0, if Field is not painted
										(FALSE) </entry>
								</row>
								<row>
									<entry> DATATYPE </entry>
									<entry> One of the following strings, as appropriate: "Boolean",
										"Date", "Datetime", "Float", "Image", "LinearDate",
										"LinearDatetime", "LinearTime", "Numeric", "Raw", "String",
										or "Time" </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>An empty string ("") is returned if an error occurred, in which case,
						$procerror contains a negative value that identifies the exact error.</para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$fieldinfo</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
								<row>
									<entry> -1110 </entry>
									<entry> UPROCERR_TOPIC</entry>
									<entry> Topic name not known. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>This function is especially useful in writing generalized operations and
						global Procs where the information needs to be determined at run time rather
						than built into the component. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, the initial value for a field is removed before
						retrieving, whenever that field is not painted: </para>
					<programlisting role="uniface"><![CDATA[; CUS_TYPE.CUSTOMER has initial value "Normal"
; If field is not painted, remove the initial value before retrieving
if ($dbocc = 0) ; not a db occurrence
   if ($fieldinfo(CUS_TYPE.CUSTOMER, "PAINTED") != 0)
      CUS_TYPE.CUSTOMER/init = ""
   endif
endif
retrieve]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldmod">
				<title>$fieldmod</title>
				<para>Return the modification status of a field. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fieldmod{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field name; optional; can be a literal name, or a string, variable,
						functiona, paraterm or indierct reference to a field. it can optionally
						contain a qualified field name, for example MYFLD.MYENT. If omitted, the
						current field is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values Returned by $fieldmod</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> Modified. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Not modified. </entry>
								</row>
								<row>
									<entry> "" </entry>
									<entry> An error occurred. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$fieldmod</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para> The function $fieldmod is set to 0 in the following circumstances: </para>
					<itemizedlist>
						<listitem>
							<para>Each time a component is restarted (except when the component has
								Keep Data in Memory clicked <emphasis role="italic">on </emphasis>).
							</para>
						</listitem>
						<listitem>
							<para>By the following events <itemizedlist>
									<listitem>
										<para>clear </para>
									</listitem>
									<listitem>
										<para>erase </para>
									</listitem>
									<listitem>
										<para>release </para>
									</listitem>
									<listitem>
										<para>reload </para>
									</listitem>
									<listitem>
										<para>retrieve </para>
									</listitem>
									<listitem>
										<para>store </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Events that cause a field to be recognized as modified include such things
						as: </para>
					<itemizedlist>
						<listitem>
							<para>The user entering a retrieve profile in an empty field. (This
								means that $fieldmod can be set to 1 <emphasis role="italic"
									>before</emphasis> a retrieve has been performed.) </para>
						</listitem>
						<listitem>
							<para>The user changing the value of data that has been retrieved.
							</para>
						</listitem>
						<listitem>
							<para>Modification of a non-database occurrence made by a Proc
								assignment (=) without the /init switch. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Calculating Total Price</title>
					<para>The following example checks the value of $fieldmod for the field
						DISCOUNT. If the value has been modified, the field TOTAL_PRICE is
						recalculated. The processing takes place in the Leave Modified Occurrence
						trigger, as the value of TOTAL_PRICE depends on several fields. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Modified Occurrence
if ($fieldmod(DISCOUNT) = 1)
  TOTAL_PRICE = DISCOUNT * ORDER_SIZE * UNIT_PRICE
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldname">
				<title>$fieldname</title>
				<para>Return the name of the current field or check for the presence of a specified
					field in the component. </para>
				<sect2>
					<title>Syntax</title>
					<para>$fieldname {( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—name of a field; can be a string, variable, function, or parameter
						that evaluates to a string that contains the name of a field. If omitted,
						the current field is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> $fieldname returns: </para>
					<itemizedlist>
						<listitem>
							<para>Name of the current field if Field is not specified. If there is
								no current field (that is, if the last node of the active path is
								not a field), $fieldname sets $procerror to -1101. </para>
						</listitem>
						<listitem>
							<para>Name of the field, if Field is specified and the field is present
								in the component. </para>
						</listitem>
					</itemizedlist>
					<para> If an error occurs $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following Field-Level
							Proc Functions</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in forms Note: In server pages, services, and reports fields the
						last node of the active path is never a field (the field never has focus).
						This means that $fieldname always sets $procerror to -1101. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $fieldname function is useful for writing global Proc that performs
						field-level actions. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>If you use a help message naming convention of FieldName_HLP, you can use
						the following Proc statement in the model definition of the Help trigger for
						the field: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Help
help $text("%%$fieldname%%%_HLP")]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldprofile">
				<title>$fieldprofile</title>
				<para>Return a value that indicates whether the user has entered a profile character
					in the current field. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fieldprofile ( Field ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Field—field name; cane be a literal name, or a string, variable, function,
						parameter, or indirect reference to a field. It can optionally contain a
						qualified field name, for example MYFLD.MYENT. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values Returned by $fieldprofile</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> A profile character has been entered. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> No profile character has been entered. </entry>
								</row>
								<row>
									<entry> "" </entry>
									<entry> An error occurred. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$fieldprofile</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $fieldprofile function does not have a value until the structure
						editor has regained control, for example, after the user leaves the field
						with ^NEXT_FIELD. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> In this example, $fieldprofile is used to call either a search Proc
						module or a retrieve Proc module. The command button's field characteristics
						must be set to Boilerplate. This allows the command button to receive focus
						and reactivate the structure editor. </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger of SEARCH command button.
; PROFILE is a non-database field used for
; entering search profiles.
if ($fieldprofile("PROFILE") = 0)
   call lp_fetch
elseif ($fieldprofile("PROFILE") = 1)
   call lp_search
else
   call lp_error
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldproperties">
				<title>$fieldproperties</title>
				<para>Return or set the current widget properties of an instance of a field. </para>
				<sect2>
					<title>Syntax</title>
					<para>$fieldproperties {( Field {, PropertyList})} </para>
					<para>$fieldproperties {( Field {, PropertyList})} {=} PropertyValuesList
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—field name; optional; can be a literal name, or a
									string, variable function, parameter, or indirect reference to a
									field containing the name. It can optionally contain a qualified
									field name, for example MYFLD.MYENT. If omitted, the current
									field is used. </para>
							</listitem>
							<listitem>
								<para>PropertyList—list of widget property names, separated by GOLD
									; ( <emphasis role="underline">;</emphasis> ); can be a string,
									or a variable, function, or parameter that evaluates to a
									string, or a field (or indirect reference to a field) </para>
							</listitem>
							<listitem>
								<para>PropertyValuesList—associative list of Property=PropertyValue
									pairs (separated by GOLD ; ), where PropertyValue is the value
									to be assigned to the property identified by Property. If
									PropertyList is present, only those properties in
									PropertyValuesList that are present in PropertyList are
									affected. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>Associative list of widget properties for the specified field in
								the current occurrence. Only properties that have been specified in
								PropertyList are returned. </para>
						</listitem>
						<listitem>
							<para>Empty string ("") if no widget properties have been specified in
								PropertyList or if the field cannot be found. </para>
						</listitem>
					</itemizedlist>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned by
							$fieldproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained), and in Uniface Server Pages. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $fieldproperties returns or sets the dynamic widget
						properties for the specified field <emphasis role="italic">in the current
							occurrence</emphasis>. Only this single instance of the specified field
						is affected, and the properties remain in effect even when this occurrence
						is no longer the current occurrence. </para>
					<para>Only properties that can be set dynamically can be defined with
						$fieldproperties. (For more information about these properties, see the
						widget descriptions). The properties set with $fieldproperties: </para>
					<itemizedlist>
						<listitem>
							<para>Override <emphasis role="italic">all</emphasis> the widget
								properties that are defined with the function $properties or in the
								Define Widget Properties form. Omitting a property causes that
								property to be reset. </para>
						</listitem>
						<listitem>
							<para>Remain in effect until they are explicitly reset with another
								$fieldproperties reference or until all the properties in the
								component are reset with by actions such as clear and retrieve.
							</para>
						</listitem>
						<listitem>
							<para>Are not reset by actions such as ^NEXT_FIELD or ^PREV_OCC. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Boilerplate Fields and $fieldproperties</title>
					<para>The behavior of $fieldproperties for a field that is defined as
						boilerplate needs to be carefully considered. A boilerplate field is not a
							<emphasis role="italic">dynamic</emphasis> field that belongs to a
						particular occurrence in the component. Instead it should be considered as a
							<emphasis role="italic">static</emphasis> graphical object that belongs
						to a position on the form where an occurrence can appear. Consider the
						following example: </para>
					<para>Four occurrences of an entity are painted on a form. Each occurrence
						contains a boilerplate field, PIC1. PIC1 is a picture widget with Frame
						defined as Off. When the second occurrence has focus, the following
						statement places a frame around the image in the second occurrence: </para>
					<programlisting role="uniface"><![CDATA[$fieldproperties(PIC1)="Frame=True"]]></programlisting>
					<para>As you scroll through multiple occurrences, the second occurrence
							<emphasis role="italic">on the screen </emphasis>always has the frame.
						Even after you clear data from the form, the frame definition remains for
						the second occurrence. </para>
					<para>If PIC1 were not defined as boilerplate, setting the field properties
						affects only the current occurrence. As you scroll through multiple
						occurrences, the framed picture scrolls with the occurrence that was in the
						second position on the screen. After you clear data from the form, there is
						no longer a frame defined for the second occurrence. </para>
				</sect2>
				<sect2>
					<title>$fieldproperties in a Web application</title>
					<para>Style references are stored as property values in the Repository, and can
						be manipulated with $fieldproperties and $properties. For dynamic changes to
						the look and feel of style attributes, use the subclass field-level
						property, which is checked at runtime and propagated through the generated
						HTML. The subclass property uses predefined style references from the
						Cascading Style Sheet (CSS) used by the Web application. </para>
					<para>You can use subclass to provide visual clues for errors, and errormsg is
						used to provide detailed information on the nature of the error in a server
						page. To use $fieldproperties for this purpose, place it in the field-level
						On Error trigger. </para>
					<para>subclass=MyClass can be substituted by, or used with, a specific error
						message using errormsg=My Error Message </para>
					<para>For example, when used together, the syntax is: </para>
					<para>$fieldproperties Field )="subclass= MyClass <emphasis role="underline"
							>;</emphasis>errormsg=My error message" </para>
					<itemizedlist>
						<listitem>
							<para>MyClass—predefined style class in the application’s CSS. </para>
						</listitem>
						<listitem>
							<para>MyErrorMessage—message such as "Error in occurrence". </para>
						</listitem>
					</itemizedlist>
					<para>The syntax of $fieldproperties must not include spaces. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If the On Error trigger is empty,
						Uniface changes the default code from $text("%%$error") to
						$fieldproperties(Field)="errormsg=$text(%%$error), but only if the trigger
						has been fired due to a validation error for a field or key. </para>
				</sect2>
				<sect2>
					<title>Restoring Default Property Values in DSPs</title>
					<para>In dynamic server pages (DSPs), it is possible to restore the default
						value of a property by preceding it with an exclamation mark: </para>
					<para> $fieldproperties ( Field , ! Property ) </para>
					<para>For example: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Field
$fieldproperties(COUNTRY) = "Frame=F" "!style:background-color"]]></programlisting>
					<para>The default value is the value that the property had the first time
						webdefinitions was called. Thereafter, the default value is remembered by
						the browser and can no longer be changed. </para>
				</sect2>
				<sect2>
					<title>Example: Highlighting the Field With Focus</title>
					<para>The following sets properties for GENDER in the current occurrence when
						that field has focus. If more than one occurrence of the entity is drawn,
						only the field in the current occurrences has a frame around it and the text
						color set to blue. The frame and color are turned on in the Field Gets Focus
						trigger and turned off in the Leave Field trigger. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Field Gets Focus
$fieldproperties(GENDER) = "Frame=T<emphasis role="underline">;</emphasis>forecolor=blue"
						]]></programlisting>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Field
$fieldproperties(GENDER) = "Frame=F<emphasis role="underline">;</emphasis>forecolor=black"
						]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldsyntax">
				<title>$fieldsyntax</title>
				<para>Return or set the syntax attributes of the specified field. 
				</para>
				<sect2>
					<title>Syntax</title>
					<para>AttributeList = $fieldsyntax (Field)</para>
					<para>$fieldsyntax (Field ) = AttributeList </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>
									Field—literal field name or a string, variable, function, or parameter that evaluates to a string containing the field name 
								</para>
							</listitem>
		
							<listitem>
								<para>
									AttributeList—string, or field (or indirect reference to a field), variable, or function that evaluates to an empty string 
									or a GOLD semi-colon (:) list of field syntax attributes. Although commas can be used when setting attributes, the 
									retrieved list is always GOLD; separated. 
								</para>
							</listitem>	
						</itemizedlist>
					</para>
				</sect2>				
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use the $fieldsyntax function to retrieve or set the syntax attributes of
						Field for the currently active occurrence. </para>
					<para>When setting the field syntax, if AttributeList contains an empty string,
						the syntax of Field is reset. The structure editor function ^CLEAR also
						resets the field syntax. Since the structure editor function ^RETRIEVE
						carries out an implicit ^CLEAR, this also resets field syntax. </para>
				</sect2>
				<sect2>
					<title>Specifying the Arguments</title>
					<para>
						<table border="1"
							xml:id="CWNL-C2037-200672191217__incltable-CWNL-C2037-200672115025">
							<caption>Table 1. Field Syntax Attributes for fieldsyntax and
								$fieldsyntax</caption>
							<thead align="left" valign="bottom">
								<tr>
									<th rowspan="1" colspan="1" align="left" valign="top"> Code </th>
									<th rowspan="1" colspan="1" align="left" valign="top">
										Description </th>
								</tr>
							</thead>
							<tbody valign="top">
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> NDI </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Do not
										display this field. </td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> NED </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Do not
										allow this field to be edited. </td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> NPR </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Do not
										prompt this field. Not available in the Web environment.
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> HID </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Do not
										display, allow editing or prompt this field. (Equivalent to
										NDI, NED, and NPR.) Not valid in character mode ($GUI =$CHR
										). </td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> DIM </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Do not
										allow editing or prompt this field. In GUI mode, the field
										is dimmed; in character mode, it is equivalent to NED and
										NPR. </td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> YDI </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Display
										this field. </td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> YED </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Allow
										this field to be edited. </td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1" align="left" valign="top"> YPR </td>
									<td rowspan="1" colspan="1" align="left" valign="top"> Prompt
										this field. </td>
								</tr>
							</tbody>
						</table>
					</para>
					<para/>
					<para>Field can be one of the following: </para>
					<para>
						<itemizedlist>
							<listitem>
								<para>Literal name of a field painted on the component. For example,
									INV_NBR. </para>
							</listitem>
							<listitem>
								<para>String that evaluates to the name of a field. For example,
									"INV_NBR". </para>
							</listitem>
							<listitem>
								<para>Variable, function, or parameter that evaluates to a string
									that contains the name of a field. For example: </para>
							</listitem>
							<listitem>
								<para>
									<itemizedlist>
										<listitem>
											<para>$1, where $1 contains "INV_NBR". </para>
										</listitem>
										<listitem>
											<para>PARAM1, where PARAM1 contains "INV_NBR". </para>
										</listitem>
										<listitem>
											<para>$fieldname, where
												$fieldname contains "INV_NBR". </para>
										</listitem>
									</itemizedlist>
								</para>
							</listitem>
							<listitem>
								<para>An indirect reference to a field, where the target field
									evaluates to a string that contains the name of a field. For
									example, @$1, where $1 contains "FLD1" and FLD1 contains
									"INV_NBR". </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example sets the field syntax for field DISCOUNT_2 to No
						Edit and No Prompt, if the value in the field DISCOUNT_1 is not zero: </para>
<programlisting role="uniface"><![CDATA[
if (DISCOUNT_1 != 0)
$fieldsyntax (DISCOUNT_2) = "NED<gold>;NPR"
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Related Information</title>
					<para>Field Syntax</para>
					<para>fieldsyntax</para>
				</sect2>
				
			</sect1>
			<sect1 xml:id="langref.dollar_fieldvalidation">
				<title>$fieldvalidation</title>
				<para>Identify whether a field requires validation. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fieldvalidation{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>If the Field—field name; optional; can be a literal field name, a string,
						or a variable, function, parameter, or indirect reference to a field
						containing the name. It can optionally contain a qualified field name, for
						example MYFLD.MYENT. If omitted, the current field is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Return Values</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> Field does not require validation because it has not
											been modified or it has already been successfully
											validated. Check the value of $fieldmod to determine
											which of these situations applies. </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Field requires validation. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$fieldvalidation</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>All fields of an entity can be validated. Data in a field needs validation
						in the following circumstances: </para>
					<itemizedlist>
						<listitem>
							<para>Data in the field has been modified ($fieldmod is 1), but has not
								yet been successfully validated ($fieldvalidation is also 1).
							</para>
						</listitem>
						<listitem>
							<para>Validation has been demanded by Proc code ($fieldcheck is 1),
								regardless of the value of $fieldvalidation. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$MYFIELD$ = "CUSTID.CUST"
if ( $fieldvalidation($MYFIELD$))
...
endif
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldvalrep">
				<title>$fieldvalrep</title>
				<para>Return or set the associative (ValRep) list for an instance of a field. </para>
				<sect2>
					<title>Syntax</title>
					<para>Get ValRep: $fieldvalrep{( Field )} </para>
					<para>Set ValRep: $fieldvalrep{( Field )} = List </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—field name; optional; can be a literal name, a string,
									or a variable, function, parameter, or indirect reference to a
									field containing the name. For example: It can optionally
									contain a qualified field name, for example MYFLD.MYENT. If
									omitted, the current field is used. </para>
							</listitem>
							<listitem>
								<para>List—associative list that contains the desired ValRep items
									for this field instance </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Associative list (ValRep) list used by a widget for the
									specified field in the current occurrence only. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") if no list has been declared for the field
									with $fieldvalrep or if the field cannot be found. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $fieldvalrep returns or sets the ValRep list for the
						specified field <emphasis role="italic">in the current
						occurrence</emphasis>. Only this single instance of the specified field is
						affected, and the ValRep list remains in effect even when the occurrence is
						no longer the current occurrence. </para>
					<para>When a ValRep list is defined for a field (in the Define Widget Properties
						dialog, or with $valrep or $fieldvalrep), this list determines the values
						that are allowed in that field. For example, defining a ValRep list for a
						unifield or an edit box limits the values that the user may enter. This can
						be considered an extra layer of syntax checking for the field. </para>
				</sect2>
				<sect2>
					<title>Updating Tree Widget ValReps</title>
					<para> When used in tree widget fields, $fieldvalrep functionality is extended
						to manipulate the contents of ValRep list, enabling you to reorder,
						partically update, or delete the contents of the tree widget. For more
						information, see Defining and Updating ValRep Lists for the Tree Widget.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, the underlined semicolon ( <emphasis
							role="underline">;</emphasis> ) represents the Uniface subfield
						separator (by default, GOLD ;). </para>
					<para>The example sets the ValRep for the drop-down list for the TITLE in each
						occurrence depending on the person's gender: </para>
					<programlisting role="uniface"><![CDATA[if (GENDER.PERSON = "M")
   $fieldvalrep(TITLE.PERSON) = "Mr.<emphasis role="underline">;</emphasis>Dr.<emphasis role="underline">;</emphasis>Prof."
else
   if (GENDER.PERSON = "F")
      $fieldvalrep(TITLE.PERSON) = "Ms.<emphasis role="underline">;</emphasis>Mrs.<emphasis role="underline">;</emphasis>Miss<emphasis role="underline">;</emphasis>Dr.<emphasis role="underline">;</emphasis>Prof."
   endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fieldvideo">
				<title>$fieldvideo</title>
				<para> Introduced in: U9 </para>
				<para>Return or set the video attributes of the specified field. </para>
				<sect2>
					<title>Syntax</title>
					<para>$fieldvideo ( Field ) = AttributeList </para>
					<para>AttributeList = $fieldvideo ( Field ) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—literal name of the field where the video properties are
									set, or a string, variable, function or parameter that evaluates
									to the name. If omitted, the current field is used. </para>
							</listitem>
							<listitem>
								<para>AttributeList—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string. The
									string should evaluate to one of: <itemizedlist>
										<listitem>
											<para>DEF—set the default video attributes for the
												current occurrence. (The default video attributes
												are determined by the assignment setting
												$DEF_CUROCC_VIDEO.) </para>
										</listitem>
										<listitem>
											<para>NON—set no special video attributes for the
												current occurrence. (In character mode, this means
												that fields, which appear in inverse by default,
												appear in normal video; this can create a sort of
												highlighting effect.) </para>
										</listitem>
										<listitem>
											<para>One or more video attributes, separated by GOLD
												semi-colon (<emphasis role="underline"
												>;</emphasis>). </para>
										</listitem>
									</itemizedlist></para>
								<para>If AttributeList is omitted, DEF is assumed. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>You can use $fieldvideo to dynamically set the video attributes of Field
						for the current occurrence. You can use color coding to highlight dangerous
						or slow choices, or to highlight fields which contain data that requires
						urgent processing. </para>
					<para>To set the video properties as data is read, place the $fieldvideo
						statement for the field after the read statement in the Read trigger. </para>
					<para>The structure editor function ^CLEAR also resets the field video
						attributes. Since the structure editor function ^RETRIEVE carries out an
						implicit ^CLEAR, this also resets field video attributes. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Video attributes set with the
						$fieldvideo instruction override the attributes set by the $ACTIVE_FIELD
						assignment setting. </para>
				</sect2>
				<sect2>
					<title>Specifying the Field</title>
					<para> If Field is supplied, it should be one of the following: </para>
					<itemizedlist>
						<listitem>
							<para>The literal name of a field painted on the component. For example,
								INV_NBR. </para>
						</listitem>
						<listitem>
							<para>A string that evaluates to the name of a field. For example,
								"INV_NBR". </para>
						</listitem>
						<listitem>
							<para>A variable, function, or parameter that evaluates to a string that
								contains the name of a field. For example: <itemizedlist>
									<listitem>
										<para>$1, where $1 contains "INV_NBR". </para>
									</listitem>
									<listitem>
										<para>PARAM1, where PARAM1 contains "INV_NBR". </para>
									</listitem>
									<listitem>
										<para>$fieldname, where $fieldname contains "INV_NBR".
										</para>
									</listitem>
								</itemizedlist></para>
						</listitem>
						<listitem>
							<para>An indirect reference to a field, where the target field evaluates
								to a string that contains the name of a field. For example, @$1,
								where $1 contains "FLD1" and FLD1 contains "INV_NBR". </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Video Attributes</title>
					<para>
						<table>
							<title>Table 1. Video attribute codes</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Code </entry>
										<entry> Description </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> BLI </entry>
										<entry> Blinking </entry>
									</row>
									<row>
										<entry> BOR </entry>
										<entry> Border </entry>
									</row>
									<row>
										<entry> BRI </entry>
										<entry> Bright </entry>
									</row>
									<row>
										<entry> HLT </entry>
										<entry> Use system highlight color</entry>
									</row>
									<row>
										<entry> INV </entry>
										<entry> Inverse </entry>
									</row>
									<row>
										<entry> UND </entry>
										<entry> Underline </entry>
									</row>
									<row>
										<entry> COL= <emphasis role="italic">n </emphasis></entry>
										<entry> Set color to color code n, the sum of the color
											numbers for foreground and background. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example loops through all the occurrences to find whether
						the name the user entered exists. If it does not, the $fieldvideo function
						is used to highlight the incorrect name. F2. E1 is a character string field
						containing a name. </para>
					<programlisting role="uniface"><![CDATA[; field : NAMEDUMMY.E1
;trigger Detail
if (F2.E1 != NAMEDUMMY)
   $curOcc$ = $curocc
   $name$ = NAMEDUMMY
   $counter$ = 1
   repeat
      setocc "E1",$counter$
      $counter$ = ($counter$ + 1)
   until ((F2.E1 = $name$) | ($status &lt; 0))
   if ($status &lt; 0)
      message "%%$name$ not available."
      setocc "E1",$curOcc$
      $fieldvideo (NAMEDUMMY) =  "BRI<emphasis role="underline">;</emphasis>UND<emphasis role="underline">;</emphasis>BLI"
      $prompt = NAMEDUMMY.E1
      return (0)
   endif
endif
$prompt = F2.E2
; end trigger]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fileexists">
				<title>$fileexists</title>
				<para> Introduced in: U9 </para>
				<para>Returns a value that indicates whether the specified file or directory
					exists.</para>
				<sect2>
					<title>Syntax</title>
					<para> $fileexists ( FilePath | DirPath ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...<itemizedlist>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
							<listitem>
								<para>DirPath—directory name, optionally preceded by the path to the
									directory. Must end with a directory separator </para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned on all systems except AS/400</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> File or directory does not exist</entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> File exists</entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry> Directory exists</entry>
								</row>
								<row>
									<entry> 4</entry>
									<entry> File exists in a ZIP archive </entry>
								</row>
								<row>
									<entry> 5</entry>
									<entry> Directory exists in a ZIP archive</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values returned on AS/400</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> File or directory does not exist</entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> File member, or another object in a library,
										exists</entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry> File containing zero or more members</entry>
								</row>
								<row>
									<entry> 3</entry>
									<entry> Library exists</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Specifying File and Directory Paths</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>VMS</title>
					<para>On VMS, $lfileexists first checks for file, then for directory. </para>
				</sect2>
				<sect2>
					<title>Example: Checking if a File Exists</title>
					<para>The following example checks whether the file <emphasis role="bold"
							>test.txt</emphasis> exists in the directory <emphasis role="bold"
							>sub1dir</emphasis> and, if so, loads it:</para>
					<programlisting role="uniface"><![CDATA[$file$ = "sub1dir\test.txt"
; or $file$ = "sub1dir/test.txt"
; or $file$ = "[.sub1dir]test.txt"
; or $file$ = "[.sub1dir]test.txt;5" ; (VMS specific)
if ($lfileexists($file$) = 1) lfileload $file$, $content$
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_fileproperties">
				<title>$fileproperties</title>
				<para> Introduced in: U9</para>
				<para>Return the properties of the specified file, directory, or zip archive, taking
					file redirections in the assignment file into account. </para>
				<sect2>
					<title>Syntax</title>
					<para> $fileproperties ( FilePath | DirPath {, Topic}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>FilePath—file name, optionally preceded by the path to the file.
								Must <emphasis role="italic">not</emphasis> end with a directory
								separator. </para>
						</listitem>
						<listitem>
							<para>DirPath—directory name, optionally preceded by the path to the
								directory. Must end with a directory separator. </para>
						</listitem>
						<listitem>
							<para>Topic—associative list of attributes, separated by GOLD ; (
									<emphasis role="underline">;</emphasis> ). If omitted, all the
								available properties are returned. </para>
						</listitem>
					</itemizedlist>
					<para> For more information, see Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>$fileproperties returns a list of properties applicable to the file. The
						properties returned depend on the type of file. </para>
					<itemizedlist>
						<listitem>
							<para>Associative list of Topic=Value pairs, separated by GOLD ; (
									<emphasis role="underline">;</emphasis> ). </para>
						</listitem>
						<listitem>
							<para>Empty list ("") if the file or directory does not exist, or an
								error occurred. $procerror contains the precise error. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Properties that can be returned by $lfileproperties and
							$fileproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Topic</entry>
									<entry> Returned value</entry>
									<entry> Normal FIles</entry>
									<entry> Zip Files</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> FILETYPE </entry>
									<entry> On MS Windows, Unix, VMS, or z/OS—DIR or FILE On
										iSeries—DIR if it is an IFS directory (DIR or DDIR); FILE if
										the object is an IFS stream file (STMF or DSTMF) or a file
										in a library (*FILE); for other object types, the type
										returned by the OS, without the '*,' for example MBR, LIB,
										PGM, SRVPGM, USRSPC etc.</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> FILESIZE </entry>
									<entry> Size, in bytes, of the file or object. Not supported on
										z/OS datasets.</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> FULLPATH </entry>
									<entry> Full path to the file, or the file in a zip archive.
										When using relative paths, the path includes the working
										directory. If the file is in a zip archive, the zip file and
										path are specified by ZIPFILENAME </entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> CREATIONDATE </entry>
									<entry> Date the file was created. String in the format
										yyyymmddhhmmsstt, where the ticks (tt) is always 00. For
										VMS, see MODIFICATIONDATE. Not supported on z/OS datasets,
										except for PDS members with ISPF statistic
										information.</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> MODIFICATIONDATE </entry>
									<entry> Last time the file was modified, in the same format as
										CREATIONDATE. Files located in zip archives have the
										modification date set rather than the creation date. On VMS,
										modifying the content of a file creates a new file version,
										which causes both the creation date and the modification
										date to be set. The modification date is different only when
										file attributes are changed, not when the content changes.
										Not supported on z/OS datasets, except for PDS members with
										ISPF statistic information.</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> ACCESSDATE </entry>
									<entry> Last time the file was accessed, in the same format as
										for CREATIONDATE. Not supported on VMS or z/OS
										datasets.</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FILEATTRIBUTES </entry>
									<entry>
										<para>String containing the file attributes. </para>
										<itemizedlist>
											<listitem>
												<para>MS Windows—zero or more of the letters
												RHSACET, where R=read-only, H=hidden, S=system,
												A=archive, C=compressed, E=encypted. </para>
												<para>For files located in zip archives— T=text file
												or ""=other (binary) files </para>
											</listitem>
											<listitem>
												<para>UNIX—string is rw[x|s]rw[x|s]rwx. Granted
												permissions are represented by the respective
												letter in the string: </para>
												<para>r=read; w=write; x=execute; s=execute plus set
												user/group ID permission. This format resembles
												the format of ls -l. </para>
												<para>Absence of a permission is represented by a
												dash (-). </para>
											</listitem>
											<listitem>
												<para>iSeries—string is rw[x|s]rw[x|s]rwx. </para>
												<para>It is equivalent to what the QSH command ls -l
												File produces. If the file is an object in the
												library system, it is followed by a comma and
												RAUDE,OMEAR. </para>
												<para>This additonal string refers to the
												permissions for the object of the current process
												only; group or public authorities are not included
												(unlike the Unix-like part, which represents user,
												group and world privileges). </para>
												<para>RAUDE represents the data permissions: R:
												read; A: add; U: update; D: delete; E: execute </para>
												<para>OMEAR represents the object permissions: O:
												operation; M: management; E: existence; A: alter;
												R: reference. </para>
												<para>Absence of a particular privilege is
												represented by a dash -. </para>
												<para>For more information, refer to the iSeries
												documentation, such as the documentation of
												EDTOBJAUT. </para>
											</listitem>
											<listitem>
												<para>VMS—string is RWED,RWED,RWED,RWED </para>
											</listitem>
											<listitem>
												<para>z/OS—for HFS, same as for Unix; for dataset,
												RWX for read/write/execute </para>
											</listitem>
										</itemizedlist>
									</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> COMPRESSEDSIZE </entry>
									<entry> Size, in bytes, of the compressed file or object in a
										zip archive.</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> CHECKSUM </entry>
									<entry> 32-bit number used to determine whether a file in a zip
										archive has been modified or corrupted.</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> METHOD </entry>
									<entry>
										<para> Method used to store the file or object; either: </para>
										<itemizedlist>
											<listitem>
												<para>0—file or object is stored without compression
												</para>
											</listitem>
											<listitem>
												<para>8—file or object is stored and compressed in a
												zip archive </para>
											</listitem>
										</itemizedlist>
									</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> ZIPFILENAME </entry>
									<entry> Full path to the zip archive that contains the file or
										directory. When using relative paths, the path includes the
										working directory.</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							$lfileproperties and $fileproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
								<row>
									<entry> -1110</entry>
									<entry> &lt;UPROCERR_TOPIC&gt;</entry>
									<entry> Topic name not known. </entry>
								</row>
								<row>
									<entry> -1132</entry>
									<entry> &lt;UPROCERR_UNRESOLVED_TOPIC&gt;</entry>
									<entry> Topic could not be resolved. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $fileproperties function returns an associative list of the properties
						of the specified file or directory, taking file redirections in the
						assignment file into account. The file or directory can be located in a zip
						archive. </para>
				</sect2>
				<sect2>
					<title>Specifying File and Directory Paths</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para> File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>OpenVMS</title>
					<para>When querying creation times of files, each change made to the content of
						a file causes a new version of that file to be created, with a new creation
						date. The creation date and modification date of the new file version are
						the same. This differs from other systems, where a modification to the file
						content does not change the creation date. </para>
					<para>OpenVMS 7.2 and earlier versions do not have the concept of access date,
						but actually return the modification date. OpenVMS 7.3 and higher do know of
						it, but do not consistently set it. The output for Accessed: is always
						&lt;None specified&gt;, no matter how many times you edit, type, change
						properties, or otherwise attempt to modify this file. Therefore the
						ACCESSDATE property is not supported on VMS and returns -13 when specified. </para>
					<para>On OpenVMS 7.2., $fileproperties does not work for [000000] root
						directories. On OpenVMS 7.3. and higher, it works partially—the
						FILEATTRIBUTES option does not work for [000000]. </para>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On the z/OS, if a file on the HFS system is specified, the standard
						properties are returned. </para>
					<para>However, on the dataset system, some standard properties are not returned
						and dataset-specific properties are returned. </para>
					<table>
						<title>Table 3. Properties Returned on z/OS</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Property</entry>
									<entry> HFS</entry>
									<entry> Datasets</entry>
									<entry> PDS members* </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> ACCESSDATE</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> CREATIONDATE</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> FILEATTRIBUTES</entry>
									<entry> X Same as Unix</entry>
									<entry> X "RWX" for read/write/execute </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FILESIZE</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FILETYPE</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FULLPATH </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> MODIFICATIONDATE </entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> BLKSIZE</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DATACLAS</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DDNAME </entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DSNTYPE</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DSORG </entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> LRECL</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> MGMTCLAS</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> RECFM</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> STORCLAS</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para> * only for PDS members with ISPF statistic information </para>
				</sect2>
				<sect2>
					<title>Example: Checking if a File Exists</title>
					<para>The following example checks whether the file <emphasis role="bold"
							>test.txt</emphasis> exists in the directory <emphasis role="bold"
							>sub1dir</emphasis> and, if so, loads it: </para>
					<programlisting role="uniface"><![CDATA[$file$ = "sub1dir\test.txt"
; or $file$ = "sub1dir/test.txt"
; or $file$ = "[.sub1dir]test.txt"
; or $file$ = "[.sub1dir]test.txt;5" ; (VMS specific)
if ($fileproperties($file$,"Filetype") = "FILETYPE=FILE") fileload $file$, $content$
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Extracting a File's Modification Date and Time</title>
					<para>This example extracts the modifcation date and time of the file <emphasis
							role="bold">grid1.xml</emphasis> residing in <emphasis role="bold"
							>grid1.zip</emphasis> file of the <emphasis role="bold"
							>\samples</emphasis> directory, assuming the current working directory
						is <emphasis role="bold">d:\usys\project</emphasis>, and assuming the return
						value of the function is:</para>
					<programlisting role="uniface"><![CDATA[FILETYPE=FILE·;MODIFICATIONDATE=2006061414351600·;COMPRESSEDSIZE=24344·;FILESIZE=272113·;
CHECKSUM=351677385·;FULLPATH=GRID1.XML·;METHOD=8·;FILEATTRIBUTES=T·;ZIPFILENAME=..\samples\grid1.zip
]]></programlisting>
					<programlisting role="uniface"><![CDATA[FIELD1.MYENTITY = $fileproperties("..\samples\grid1.zip:grid1.xml")
; Extract the modification date:
getitem/id $1,FIELD1.MYENTITY,"MODIFICATIONDATE"
$2 = $date($1) ; gives $2 = "20060614"
; Extract the modification time:
$3 = $clock($1) ; gives $3 = "0000000014351600"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_foreign">
				<title>$foreign</title>
				<para>Return a value that indicates whether the entity is painted as an up entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> $foreign{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> ... Entity—entity name; optional; can be a literal name, a string, or a
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $foreign</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry>
										<emphasis role="italic">Entity </emphasis>is painted as an
										up (foreign) entity. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry>
										<emphasis role="italic">Entity </emphasis>is not painted as
										an up entity. </entry>
								</row>
								<row>
									<entry> "" </entry>
									<entry> An error occurred </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$foreign</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $foreign function returns an indication if the specified entity is
						painted as an up (or foreign) entity. </para>
					<para>It is useful in the application model definition for the Read trigger of
						an entity, since it allows you to determine at run time how the entity is
						painted on the current form. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The $foreign function can be used in application model Read triggers to
						specify different actions depending on how the entity was painted on the
						form. In the following example, if the entity is not painted as an up
						entity, the u_where clause ensures that all the occurrences where
						EXPIRATION_DATE is today or later are read. If the entity is painted as an
						up entity, the unqualified read statement ensures that only the single
						matching occurrence is read. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read
if ($foreign = 0)
   read u_where (EXPIRATION_DATE &gt;= $date)
else
   read
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_format">
				<title>$format</title>
				<para>Return or set data for formatting. </para>
				<sect2>
					<title>Syntax</title>
					<para>$format </para>
					<para>$format = FormattedData </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>FormattedData—can be a string, or a field (or indirect reference to a
						field), a variable, or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Field data, formatted according to the display format (DIS) of the field.
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> You can use $format to change formatted data using the FormattedData
						argument. </para>
					<para>Use $format only in the field-level Format and Deformat triggers. When the
						Format trigger is activated, $format initially returns the field data,
						formatted according to the display (DIS) template of the field. If a display
						template is not defined for the field, the default formats shown in the
						table below are used: </para>
					<table>
						<title>Table 1. Default display templates used by $format</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Data type </entry>
									<entry> Displayed format </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> String</entry>
									<entry> As is </entry>
								</row>
								<row>
									<entry> Numeric </entry>
									<entry> {-}nnn{.} </entry>
								</row>
								<row>
									<entry> Float </entry>
									<entry> {-}nnn{.}e nnn </entry>
								</row>
								<row>
									<entry> Date, Linear Date </entry>
									<entry>
										<emphasis role="italic">ccyymmdd </emphasis></entry>
								</row>
								<row>
									<entry> Time, Linear Time </entry>
									<entry>
										<emphasis role="italic">hhnnsstt </emphasis></entry>
								</row>
								<row>
									<entry> Datetime, Linear Datetime </entry>
									<entry>
										<emphasis role="italic">ccyymmddhhnnsstt </emphasis></entry>
								</row>
								<row>
									<entry> Boolean </entry>
									<entry> T or F </entry>
								</row>
								<row>
									<entry> Image, Raw </entry>
									<entry> TRX-coded data </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>When the Deformat trigger is activated, $format initially returns the raw
						data for the field, as entered by the user. Proc code in the Deformat
						trigger should convert this raw data into a format acceptable by Uniface.
						The converted data should be written to $format when the Deformat trigger
						completes. </para>
					<para> In the debugger, $format can be accessed directly or as variable $103.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example adds a sterling symbol in front of a number if the
						currency is British: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Format
if (CURRENCY = "POUNDSTG")
$format = "STG %%$format"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formdb">
				<title>$formdb</title>
				<para>Return a value that indicates whether data in the current form has been
					retrieved from a database. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$formdb</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $formdb</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry>
											<para>In the following cases:</para>
											<itemizedlist>
												<listitem>
												<para>No entities have been retrieved from a
												database </para>
												</listitem>
												<listitem>
												<para>$formdb has been reset to 0 by a Proc
												statement </para>
												</listitem>
												<listitem>
												<para>No entities are painted on the form </para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> An entity in the form has been retrieved from a
											database </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $formdb function is used to test whether <emphasis role="italic">any
						</emphasis>occurrence in the form (started with run) or form instance
						(started with newinstance or activate) has been retrieved from a database. </para>
					<para>Statements that affect the value of $formdb are the same as those that
						affect $instancedb: </para>
					<table>
						<title>Table 2. Statements that change $instancedb (or $formdb)</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Statement </entry>
									<entry> Action </entry>
									<entry> Discussion </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> clear </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>clear/e </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the
										cleared entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the cleared
										entity. </entry>
								</row>
								<row>
									<entry> erase </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>erase/e </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the erased
										entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the erased
										entity. </entry>
								</row>
								<row>
									<entry> release </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>release/e </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the
										released entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the released
										entity. </entry>
								</row>
								<row>
									<entry> release/mod </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>release/e/mod </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the
										released entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the released
										entity. </entry>
								</row>
								<row>
									<entry> retrieve </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> ^RETRIEVE causes the first outermost entity to be
										retrieved with its related entities. Any unrelated entities
										are not automatically retrieved. Internally, the
										entity-level flags for database origin are set. This affects
										the value that $instancedb becomes when any unrelated
										entities use Proc statements that modify $instancedb.
									</entry>
								</row>
								<row>
									<entry> retrieve/e </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> The specified entity is retrieved with its related
										entities. Any unrelated entities are not automatically
										retrieved. Internally, the entity-level flags for database
										origin are set. This affects the value $instancedb becomes
										when any unrelated entities use Proc statements that modify
										$instancedb. </entry>
								</row>
								<row>
									<entry> store </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> store/e </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> Internally, the entity-level flags for database origin
										are set for the entity and related entities stored. This
										affects the value $instancedb becomes when any unrelated
										entities use Proc statements that reset $instancedb.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>(You could consider $formdb to be an inclusive OR of all the entity-level
						flags indicating database origin.) </para>
				</sect2>
				<sect2>
					<title>: Specifying the Behavior of the ^Clear Function </title>
					<para>The following example shows how to use $formdb to determine the behavior
						of the ^CLEAR function: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Clear
if ($formdb &gt; 0)
release
message "Controls released; data available as default for new input"
else
clear
endif
]]></programlisting>
					<para>In the example, the first time the ^CLEAR function is used, the Proc code
						releases the controls on primary key fields and marks retrieved data as
						being entered by the user. The second time that ^CLEAR is used, the data is
						removed from the form (but <emphasis role="italic">not </emphasis>from the
						database). </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formdbmod">
				<title>$formdbmod</title>
				<para>Return the modification status of database fields in the current form. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$formdbmod</command>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $formdbmod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry>
											<para>Field has not been modified; this can be because: </para>
											<itemizedlist>
												<listitem>
												<para>No database field has been modified </para>
												</listitem>
												<listitem>
												<para>No database occurrences have been added or
												removed </para>
												</listitem>
												<listitem>
												<para>No entities are painted on the form </para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry>
											<para> Field has been modified; this can be due to: </para>
											<itemizedlist>
												<listitem>
												<para>A database field in a database entity has
												been modified </para>
												</listitem>
												<listitem>
												<para>An database occurrence has been added to or
												removed from the component </para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$formdbmod is a form-level function that tests whether any field that is
						defined as a database field has been modified. Other fields, such as dummy
						fields, do not affect $formdbmod. </para>
					<para>Statements that affect the value of $formdbmod are the same as those that
						affect $instancedbmod. </para>
					<para>The value returned by the function $formdbmod is determined in the same
						way as the value of $instancedbmod. (You could consider $formdbmod to be the
						inclusive OR of the values of the $fieldmod function for all database fields
						in the form.) </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>This example uses $formdbmod to test whether database fields have been
						modified before allowing a form to be exited: </para>
					<programlisting role="uniface"><![CDATA[; Quit trigger
selectcase $formdbmod
case 0
exit
case 1
askmess "Some data has not been saved.%%^%\
Do you wish to exit?"
if ($status = 0)
return -1
else
exit
endif
endselectcase]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formfocus">
				<title>$formfocus</title>
				<para>Return the name of the form instance that has focus.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$formfocus</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String that contains the name of the form instance (or form in a sequence
						of modal forms) that currently has focus. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $formfocus function is particularly useful in (local) services and
						global Procs. </para>
				</sect2>
				<sect2>
					<title>Example: Reporting the Instance that has </title>
					<para>The following example reports the name of the instance that currently has
						focus in the message frame: </para>
					<programlisting role="uniface"><![CDATA[putmess "The form instance %%$formfocus has focus."]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formmod">
				<title>$formmod</title>
				<para>Return the modification status of data in the current form. </para>
				<sect2>
					<title>Syntax</title>
					<para>$formmod </para>
					<para>$formmod = Expression </para>
					<para>set | reset $formmod </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $formmod</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry>
										<para>In the following cases: </para>
										<itemizedlist>
											<listitem>
												<para>No field has been modified </para>
											</listitem>
											<listitem>
												<para>No occurrences have been added or removed
												</para>
											</listitem>
											<listitem>
												<para>No entities are painted on the form </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry>
										<para> In the following cases: </para>
										<itemizedlist>
											<listitem>
												<para>Any field in the component has been modified
												</para>
											</listitem>
											<listitem>
												<para>An occurrence has been added to or removed
												from the component </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$formmod is a form-level function that tests the modification status of
						data in the form. </para>
					<para>Statements that affect the value of $formmod are the same as those that
						affect $instancemod. </para>
					<para>You can also use $formmod as the target in the left-hand side of an
						assignment, for example: </para>
					<programlisting role="uniface"><![CDATA[$formmod=!$formmod ]]></programlisting>
					<para>The value of $formmod is actually the inclusive OR of the values of the
						$occmod function for all the occurrences in the form.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, a Quit Proc code examines $formmod to determine
						if any modifications have been made on the form. If there have been
						modifications, the user is asked to confirm before the modifications are
						lost. </para>
					<para>If the user does not want to ^QUIT, the Proc code ends with a status code
						that prevents the form from ending; that is, the form remains displayed, and
						the user is able to ^ACCEPT the modifications. If the user does want to
						^QUIT, the Proc code ends normally, allowing the form to end. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Quit
if ($formmod = 0)
return (0)
else
askmess "Please confirm QUIT (Y/N)"
if ($status = 1)
return (0)
else
; -1 prevents end of edit session
return (-1)
endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formmodality">
				<title>$formmodality</title>
				<para>Return an indication of the form modality for the requested form instance. </para>
				<sect2>
					<title>Syntax</title>
					<para> $formmodality{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>InstName—component instance name; optional; can be a literal name, string,
						variable, function, parameter or indirect reference to a field containing
						the name. If omitted, the modality of the current form instance is returned.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $formmodality</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry>
										<emphasis role="italic">InstName </emphasis>is a modal form.
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry>
										<emphasis role="italic">InstName </emphasis>is a non-modal
										form. </entry>
								</row>
								<row>
									<entry> "" </entry>
									<entry> An error occurred. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$formmodality</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -57 </entry>
									<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
									<entry> The named instance cannot be found in the component
										pool. </entry>
								</row>
								<row>
									<entry> -1105 </entry>
									<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
									<entry> The instance name provided is not valid (For more
										information, see the new_instance Proc statement); for
										example, the argument contains incorrect characters.
									</entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
									<entry> Function not allowed, unknown context. For example,
										$formmodality was used without the <emphasis role="italic"
											>InstName </emphasis>argument and no instance is
										current. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example puts a message in the message frame that indicates
						if the current instance was started as a modal or non-modal form: </para>
					<programlisting role="uniface"><![CDATA[if ($formmodality = 1)
putmess "%%$instancename is modal."
else
putmess "%%$instancename is non-modal"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formname">
				<title>$formname [DEPRECATED]</title>
				<para> Use $componentname instead </para>
				<para> </para>
			</sect1>
			<sect1 xml:id="langref.dollar_frac">
				<title>$frac</title>
				<para> Introduced in: U8 </para>
				<para>Return the fractional part of X. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$frac</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—a numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Fractional part of X. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the fractional part of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$fracOf$ = $frac(ANUMBER / 100)]]></programlisting>
					<para>If the value of ANUMBER is 234, the result stored in $fracOf$ is 0.34.
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_formtitle">
				<title>$formtitle</title>
				<para>Return or set the window title bar of a form. </para>
				<sect2>
					<title>Syntax</title>
					<para>$formtitle </para>
					<para>$formtitle = FormTitle </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>FormTitle—new title for the form; can be a string, or a field (or indirect
						reference to a field), a variable, or a function that evaluates to a string.
						The maximum number of characters that can be assigned is 127. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Title of the current form or form instance.</para>
					<para>Initially, $formtitle returns the title of the form as defined in the form
						properties, or the instance name, if no title has been set. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $formtitle function has effect only when an application is using a GUI
						driver. Changing $formtitle overrides the value defined in the GUI-specific
						settings. </para>
					<para>You can use $formtitle to set the window title bar of a form by specifying
						FormTitle. </para>
				</sect2>
				<sect2>
					<title>Example: Naming Forms </title>
					<para>The following example uses $formtitle to name the form window after the
						race season the user is accessing: </para>
					<programlisting role="uniface"><![CDATA[; FORMULA 1 Application
; form: W_RACE
; trigger: Execute
$valrep(RACE_DLIST.RACE) = $$list
$formtitle = "Races window - %%$$season season"
call lp_clearvars
edit]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_framedepth">
				<title>$framedepth</title>
				<para>Return the number of lines needed to print a frame as drawn on the component,
					without allowing for expansion</para>
				<sect2>
					<title>Syntax</title>
					<para> $framedepth{( Frame )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Frame—frame name; optional; can be a literal name, a string, or a
						variable, function, parameter or indirect reference to a field containing
						the name. If omitted, the current frame is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Number of lines painted for the specified frame. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in presentation components (and in service components that are not
						self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $framedepth allows you to determine how many lines are needed
						to print a frame. The function cannot take into consideration any vertical
						expansion that might occur when the frame is printed at run time; the value
						returned is the number of lines that have been painted on the component. </para>
					<para>When you add $totlines, $framedepth(HEADER), and $framedepth(TRAILER), the
						result is the full page depth, excluding top and bottom margins. </para>
					<para>It is usually easier to set the Print Frame on Same Page property of an
						entity or named area frame. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how a page feed can be produced when the depth
						of a frame is greater than the lines remaining on the page: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
; entity : CUSTOMER
if ($lines &lt; $framedepth(INVOICE))
   eject
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_gui">
				<title>$gui</title>
				<para>Return the mnemonic for the user interface. </para>
				<sect2>
					<title>Syntax</title>
					<para><command>$gui</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $gui</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> User interface </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> CHR </entry>
										<entry> Character mode </entry>
									</row>
									<row>
										<entry> MSW </entry>
										<entry> Microsoft Windows </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The value returned by$gui is the same as that specified by the assignment
						file setting $GUI. </para>
					<para>Note: You cannot use $gui to determine the 'mode' of Microsoft Windows XP
						(classic or XP) under which the Uniface application is running. Use $oprsys
						to determine the operating system mnemonic. </para>
				</sect2>
				<sect2>
					<title>Example: Dynamically Setting Command Button Appearance</title>
					<para>The following example uses $gui to determine whether to load an image file
						into a command button, or to display text instead: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
; In character mode ?
; Yes, so display text only
; No, so load picture
if ($gui = "CHR")
BUTTON1 = "Picture of Jim"
else
BUTTON = "@jim"
endif
edit]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_hide">
				<title>$hide</title>
				<para>Return or set the display status of a menu item. </para>
				<sect2>
					<title>Syntax</title>
					<para>$hide </para>
					<para>$hide = Expression </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $hide</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Menu item is displayed</entry>
									</row>
									<row>
										<entry> 1</entry>
										<entry> Menu item is hidden and the menu accelerator for the
											item is disabled.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Predisplay trigger of form components (and in service
						and report components that are not self-contained), . </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $hide controls whether the current menu item is displayed: </para>
					<para>You can also use $hide as the target in the left-hand side of an
						assignment, for example: </para>
					<programlisting role="uniface"><![CDATA[$hide=!$hide ]]></programlisting>
					<para>Since $hide is essentially a Boolean function, when Expression evaluates
						to a nonzero value, $hide becomes 1. </para>
				</sect2>
				<sect2>
					<title>Example: Temporarily Hiding a Menu Item </title>
					<para>The following example temporarily removes a menu item from the menu: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Predisplay
set $hide ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_hits">
				<title>$hits</title>
				<para>Return the number of occurrences in the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para> $hits{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity name; optional; can be a literal name, a string, or a
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Total number of occurrences in the hitlist. </para>
							</listitem>
							<listitem>
								<para>An empty string ("") if an error occurred. $procerror contains
									a negative value that identifies the exact error. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$hits</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>If the DBMS you are accessing supports a stepped hitlist, any performance
						benefits derived from use of the stepped hitlist are lost when you use
						$hits, since building the complete hitlist can be quite time-consuming. </para>
					<table>
						<title>Table 2. Statements that change $hits</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Event </entry>
									<entry> Action </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> clear </entry>
									<entry> Sets $hits to 0. </entry>
								</row>
								<row>
									<entry> release </entry>
									<entry> Sets $hits to 0. </entry>
								</row>
								<row>
									<entry> discard </entry>
									<entry> Reduces $hits by the number of discarded occurrences.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows an Execute Proc code for an index type of
						form. This Proc code copies a value into the form which defines a profile,
						then retrieves all the companies which match that profile. The assignment
						statement copies the total number of hits which match the profile to a dummy
						field in the trailer frame on the form: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
COMPNAME = $1
retrieve
if ($status &lt; 0)
   message "Retrieve error"
   exit (0)
endif
TOTSEL.TRAILER = $hits(COMPANY)
display COMPNAME
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_idpart">
				<title>$idpart</title>
				<para> Introduced in: U8 </para>
				<para>Return the ID part of an associative list item. </para>
				<sect2>
					<title>Syntax</title>
					<para> $idpart ( AssociativeListItem ) </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>ID part of an associative list item. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>For more information on the structure of lists, see Lists and Sublists.
					</para>
				</sect2>
				<sect2>
					<title>Example: Extracting the ID and Value of an Associative List Item</title>
					<para>The following example shows how the $valuepart function can be used to
						extract the value part of an associative list item: </para>
					<programlisting role="uniface"><![CDATA[$1 = $idpart("Key=TheData")
$2 = $valuepart("Key=TheData")
; results:
; $1 = "Key"
; $2 = "TheData"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_inlinemenu">
				<title>$inlinemenu</title>
				<para> Introduced in: U9 </para>
				<para> Insert or retrieve one or more menu items at the location of a dynamic menu
					placeholder </para>
				<sect2>
					<title>Syntax</title>
					<para>Setting menu items: $inlinemenu = MenuItemList </para>
					<para>Getting menu items: MenuItemList = $inlinemenu </para>
					<para>where:</para>
					<para>MenuItemList is MenuItem { <emphasis role="underline">;
						</emphasis>MenuItem n}</para>
					<para>MenuItem is MenuItemId=Type <emphasis role="underline">;</emphasis>
							Text{<emphasis role="underline">;</emphasis> Accelerator}{<emphasis
							role="underline">;</emphasis> HintText}{<emphasis role="underline"
							>;</emphasis> Checked}{<emphasis role="underline">;</emphasis>
							Disabled}{<emphasis role="underline">;</emphasis>
						ReferencedMenu|NestedMenu} </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>MenuItemList—associative list containing one or more menu item
									definitions in a dynamic menu or dynamic cascading menu. The
									subfield separator is GOLD ; (<emphasis role="underline"
										>;</emphasis>) </para>
							</listitem>
							<listitem>
								<para>MenuItem—associative list defining the type and properties of
									a menu item. The properties that can be specified depend on the
									type of menu item. </para>
							</listitem>
							<listitem>
								<para>MenuItemId—string specifying the type of menu item; mandatory.
									Format is: </para>
								<para>Type = "Separator" | "Option" | "Cascaded Menu" | "Included
									Menu" </para>
								<para>If the Type specifies a cascading or included menu, the
									MenuType definition also needs to specify a ReferencedMenu or
									NestedMenu. The item type strings are case insensitive. </para>
							</listitem>
							<listitem>
								<para>MenuItemId—string identifying the menu item so that it can be
									used to detect whether this item was selected by the user later
									on. </para>
							</listitem>
							<listitem>
								<para>Text—ValRep string specifying the option text displayed in the
									menu. Mandatory if Type = "Option" or "Cascading Menu". Format
									is: </para>
								<para>Text = String </para>
							</listitem>
							<listitem>
								<para>Accelerator—ValRep pair specifying the accelerator definition
									for the item. Empty by default. Format is: </para>
								<para>Accelerator = String </para>
							</listitem>
							<listitem>
								<para>HintText—ValRep string specifying the hint text for the menu
									item. Empty by default. </para>
								<para>HintText = String </para>
							</listitem>
							<listitem>
								<para>Checked—ValRep pair specifying whether the menu item is
									checked, which displays a check mark beside the item. False by
									default. Format is: </para>
								<para>Checked = Boolean </para>
							</listitem>
							<listitem>
								<para>Disabled—ValRep pair specifying whether the item is disabled.
									False by default.. Format is: </para>
								<para>Checked = Boolean </para>
							</listitem>
							<listitem>
								<para>ReferencedMenu—ValRep string specifying an existing menu.
									Format is: </para>
								<para>Referenced_Menu = MenuName </para>
							</listitem>
							<listitem>
								<para>NestedMenu—ValRep string specifying another dynamic menu.
									Format is: </para>
								<para>Nested_Menu = MenuItemList </para>
								<para><emphasis role="bold"> Note:</emphasis> It is not possible to
									nest one nested menu into another nested menu.</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns error code in $procerror and error description in
						$procerrorcontext </para>
					<table>
						<title>Table 1. Values returned by $procerror after $inlinemenu</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> Success</entry>
								</row>
								<row>
									<entry> -1</entry>
									<entry> An error occurred. </entry>
								</row>
								<row>
									<entry> -1600</entry>
									<entry> The function has been used outside the scope of the
										current Predisplay context</entry>
								</row>
								<row>
									<entry> -1601</entry>
									<entry> The function has been used in a component. It is allowed
										only in a Predisplay trigger</entry>
								</row>
								<row>
									<entry> -1602</entry>
									<entry> The menu item list has been incorrectly defined.</entry>
								</row>
								<row>
									<entry> -1603</entry>
									<entry> Referenced menu in cascading menu does not exist</entry>
								</row>
								<row>
									<entry> -1604</entry>
									<entry> Menu item identifier is not unique</entry>
								</row>
								<row>
									<entry> -1605</entry>
									<entry> Invalid menu item type</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>The scope of the function is limited to the Predisplay trigger of the
						dynamic menu for which the trigger was fired.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $inlinemenu function contains the most recent menu items set for the
						dynamic menu for which the Predisplay trigger was fired. This means that if
						$inlinemenu is not set, the last known menu content for the dynamic menu is
						used. </para>
					<para>The function is empty until a valid menu item definition list is assigned
						to that function. It is therefore not possible to set the content of a
						dynamic menu except in the Predisplay trigger used to fire it. </para>
				</sect2>
				<sect2>
					<title>Example: Defining Dynamic Menu Items</title>
					<para>The following example builds a dynamic menu. It uses putitem to construct
						a menu item definition in a variable and then inserts the value of the
						variable as an item in the current dynamic menu.</para>
					<programlisting role="uniface"><![CDATA[;PreDisplay trigger
variables
   string strMenuItem
endvariables
; ----------- Insert first menu item in a dynamic menu --------------
;Initialize one menu item in list
  StrMenuItem = ""
;Define menu item "Option A"
  putitem/id strMenuItem, "TYPE", "Option"
  putitem/id strMenuItem, "TEXT", "Option A"
  putitem/id strMenuItem, "Checked", "True"
 
;Insert this item with id "A" into the dynamic menu.
  putitem/id $inlinemenu, "A", strMenuItem
; ----------- Insert second menu item in a dynamic menu
;Initialize one menu item in list.
  StrMenuItem = ""
;Define menu item "Option B"
  putitem/id strMenuItem, "TYPE", "Option"
  putitem/id strMenuItem, "TEXT", "Option B"
;Insert this item with id "B" into the dynamic menu.
  putitem/id $inlinemenu, "B", strMenuItem
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Defining Nested Dynamic Menus</title>
					<para>
						<emphasis role="bold"> Caution:</emphasis> Use caution when defining nested
						dynamic menus because it is possible to create looping menus where a nested
						menu refers to a generated parent menu. </para>
					<para>The following example creates a dynamic menu that references an existing
						menu and includes a submenu containing a list of attached component
						instances. </para>
					<programlisting role="uniface"><![CDATA[;PreDisplay trigger
variables
string strMenuItem
string strSubMenu
string strInstance
endvariables
;Clear $inlinemenu to ensure that an existing dynamic menu definition is not used.
$inlinemenu = ""
;Define a cascading menu that references an existing file menu.
strMenuItem = ""
putitem/id strMenuItem, "TYPE", "CASCADED_MENU"
putitem/id strMenuItem, "TEXT", "File"
putitem/id strMenuItem, "REFERENCED_MENU", "FILE_MENU"
;Insert the cascading file menu item with id "ID_FILE" into the dynamic menu.
putitem/id $inlinemenu, "ID_FILE", strMenuItem
;Initialize the dynamic submenu definition including all available attached instances.
strSubMenu = ""
;Insert menu items for all "attached instances"
$1 = 1
getitem strInstance, $instancechildren, $1 
while ($status &gt; 0)
putitem/id strSubMenu, strInstance, "TYPE=Option<emphasis role="underline">;</emphasis>TEXT=%%strInstance%%%"
; Get next instance
$1 = $1 + 1
getitem strInstance, $instancechildren, $1 
endwhile
;Define a cascading menu containing a nested dynamic menu with all attached instances of this component.
strMenuItem = ""
putitem/id strMenuItem, "TYPE", "CASCADED_MENU"
putitem/id strMenuItem, "TEXT", "Attached instances"
putitem/id strMenuItem, "NESTED_MENU", strSubMenu
;Insert the cascading menu (id "ID_INSTANCES") with attached instances
;into the dynamic menu.
putitem/id $inlinemenu, "ID_INSTANCES", strMenuItem
]]></programlisting>
					<para>When the user selects one of the items attached to the instances, that
						instance is made active with the setformfocus statement. </para>
					<programlisting role="uniface"><![CDATA[;Option trigger
params
string strId : IN
endparams
;Check if our id is one of our attached instances.
if (IsAttachedInstance(strId))
;Yes our selected menu item has an id which matches
;one of our attached instances so we can make this one
;current.
setformfocus strId
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancechildren">
				<title>$instancechildren</title>
				<para>Return a list of instances attached to an instance. </para>
				<sect2>
					<title>Syntax</title>
					<para> $instancechildren{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>InstName—component instance name; optional; can be a literal name, string,
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current instance (started with newinstance or
						activate) is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List of the child instances attached to the specified
									instance. The list includes instances that are running remotely;
									it does not include forms that were started with the run
									statement. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") in the following cases: <itemizedlist>
										<listitem>
											<para>InstName has no child instances. </para>
										</listitem>
										<listitem>
											<para>InstName was omitted and the current instance is a
												form started with run. </para>
										</listitem>
										<listitem>
											<para>No instance named InstName can be found in the
												component pool. </para>
										</listitem>
										<listitem>
											<para>InstName is not correct; that is, the field or
												variable is not found or the string is not a valid
												instance name. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>An instance is attached to InstName if one of these statements is true: </para>
					<itemizedlist>
						<listitem>
							<para>It was created by a newinstance/attached statement. </para>
						</listitem>
						<listitem>
							<para>It was created by a newinstance statement (or by an activate
								statement that did an implicit newinstance) and the Modality &amp;
								Attachment property is set to Non-Modal, Attached. </para>
						</listitem>
					</itemizedlist>
					<para>The list returned by $instancechildren can be manipulated with Proc
						statements such as getitem, getlistitems, and so on. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example fills the field LISTBOX with a list of the child
						instances of the current instance: </para>
					<programlisting role="uniface"><![CDATA[$valrep(LISTBOX) = $instancechildren ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancedb">
				<title>$instancedb</title>
				<para>Return an indication whether data in the current instance has been retrieved
					from a database. </para>
				<sect2>
					<title>Syntax</title>
					<para> $instancedb{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>InstName—component instance name; optional; can be a literal name, string,
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current instance (started with newinstance or
						activate) is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $instancedb</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "" </entry>
									<entry>
										<itemizedlist>
											<listitem>
												<para>InstName omitted and there is no current
												instance, for example, in the Application Execute
												trigger. </para>
											</listitem>
											<listitem>
												<para>InstName omitted and current instance is a
												form started with run. </para>
											</listitem>
											<listitem>
												<para>No instance named InstName can be found in the
												component pool. </para>
											</listitem>
											<listitem>
												<para>InstName is not correct; that is, the field or
												variable is not found or the string is not a valid
												instance name (see newinstance). </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry>
										<itemizedlist>
											<listitem>
												<para>No entities have been retrieved from a
												database, for example, the user has not retrieved
												data, only entered it </para>
											</listitem>
											<listitem>
												<para>$instancedb has been reset to 0 by a Proc
												statement </para>
											</listitem>
											<listitem>
												<para>No entities are painted on the component
												</para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> &gt;0 </entry>
									<entry> An entity in the instance has been retrieved from a
										database</entry>
								</row>
							</tbody>
						</tgroup>
					</table>

				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $instancedb function is used to test whether <emphasis role="italic"
							>any </emphasis>occurrence in InstName has been retrieved from a
						database. The $instancedb function is evaluated as an inclusive OR of all
						the entity-level flags indicating database origin. </para>
					<para>The following statements affect the value of $instancedb: </para>
					<table>
						<title>Table 2. Statements that change $instancedb (or $formdb)</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Statement </entry>
									<entry> Action </entry>
									<entry> Discussion </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> clear </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>clear/e </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the
										cleared entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the cleared
										entity. </entry>
								</row>
								<row>
									<entry> erase </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>erase/e </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the erased
										entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the erased
										entity. </entry>
								</row>
								<row>
									<entry> release </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>release/e </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the
										released entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the released
										entity. </entry>
								</row>
								<row>
									<entry> release/mod </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>release/e/mod </entry>
									<entry> Sets $instancedb to 0 </entry>
									<entry> If the only entities retrieved are related to the
										released entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only entities retrieved are <emphasis
											role="italic">not </emphasis>related to the released
										entity. </entry>
								</row>
								<row>
									<entry> retrieve </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> ^RETRIEVE causes the first outermost entity to be
										retrieved with its related entities. Any unrelated entities
										are not automatically retrieved. Internally, the
										entity-level flags for database origin are set. This affects
										the value that $instancedb becomes when any unrelated
										entities use Proc statements that modify $instancedb.
									</entry>
								</row>
								<row>
									<entry> retrieve/e </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> The specified entity is retrieved with its related
										entities. Any unrelated entities are not automatically
										retrieved. Internally, the entity-level flags for database
										origin are set. This affects the value $instancedb becomes
										when any unrelated entities use Proc statements that modify
										$instancedb. </entry>
								</row>
								<row>
									<entry> store </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> store/e </entry>
									<entry> Sets $instancedb to 1 </entry>
									<entry> Internally, the entity-level flags for database origin
										are set for the entity and related entities stored. This
										affects the value $instancedb becomes when any unrelated
										entities use Proc statements that reset $instancedb.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>For more information, see Effects of Proc Statements on Instance-Level
						Proc Functions.</para>
					<para>When an entity that is painted as an up (or foreign) entity has empty
						Write Up and Delete Up triggers, for the purposes of $instancedb, that
						entity is <emphasis role="italic">not </emphasis>considered to be a DBMS
						entity. Even if data for the up entity has been retrieved as a result of a
						retrieve/e, the value of $instancedb is not affected. </para>
				</sect2>
				<sect2>
					<title>Example: Using $instancedb to Determine the Behavior of ^CLEAR</title>
					<para>The following example shows how to use $instancedb to determine the
						behavior of the ^CLEAR function: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Clear
if ( $instancedb &gt; 0 &amp; $componenttype = "F")
   release
   message "Controls released; data available as default for new input"
else
   clear
endif]]></programlisting>
					<para>In the example, the first time the ^CLEAR function is used, the Proc code
						releases the controls on primary key fields and marks retrieved data as
						being entered by the user. The second time that ^CLEAR is used, the data is
						removed from the instance (but <emphasis role="italic">not </emphasis>the
						database). </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancedbmod">
				<title>$instancedbmod</title>
				<para>Return the modification status of database fields in the current component
					instance.</para>
				<sect2>
					<title>Syntax</title>
					<para> $instancedbmod{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> InstName—name of component instance; optional; can be a literal name, a
						string, or a variable, function, parameter or indirect reference to a field
						containing the name. If omitted, the current instance is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $instancedbmod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry>
											<itemizedlist>
												<listitem>
												<para>No modifications have been made to database
												fields. </para>
												</listitem>
												<listitem>
												<para>No entities are painted on the component.
												</para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Any field in the component instance that is defined
											as being a database field has been modified.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$instancedbmod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1105 </entry>
										<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
										<entry> The instance name provided is not valid (For more
											information, see the new_instance Proc statement); for
											example, the argument contains incorrect characters.
										</entry>
									</row>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. The InstName
											argument was omitted and one of the following occurred:
											There is no current instance, for example, in the
											Application Execute trigger. The current instance is a
											form started with run. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$instancedbmod is an instance-level function that tests whether any field
						in the specified instance that is defined as a database field has been
						modified. Other fields, such as dummy fields, do not affect $instancedbmod. </para>
					<para>(You could consider $instancedbmod to be the inclusive OR of the values of
						the $fieldmod function for all database fields in the instance. </para>
				</sect2>
				<sect2>
					<title>Events Affecting $instancedbmod</title>
					<para>Events that cause a field to be recognized as modified include such things
						as: </para>
					<itemizedlist>
						<listitem>
							<para>The user entering a retrieve profile in an empty field. (This
								means that $instancedbmod can be set to 1 <emphasis role="italic"
									>before</emphasis> a retrieve has been performed.) </para>
						</listitem>
						<listitem>
							<para>The user changing the value of data that has been retrieved.
							</para>
						</listitem>
						<listitem>
							<para>Modification of a non-database field made by a Proc assignment (=)
								without the /init switch. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 3. Statements that change $instancedbmod (or
							$formdbmod)</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Statement </entry>
									<entry> Action </entry>
									<entry> Discussion </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> clear </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>clear/e </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> If the only database fields modified are in entities
										related to the cleared entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only database fields modified are <emphasis
											role="italic">not </emphasis>in entities related to the
										cleared entity. </entry>
								</row>
								<row>
									<entry> erase </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>erase/e </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> If the only database fields modified are in entities
										related to the erased entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only database fields modified are <emphasis
											role="italic">not </emphasis>in entities related to the
										erased entity. </entry>
								</row>
								<row>
									<entry> release/e/mod </entry>
									<entry> Sets $instancedbmod to 1 </entry>
									<entry> The modification status is set only for the specified
										entity and related entities. Consequently, Proc statements
										that reset the modification status for unrelated entities do
										not cause $instancedbmod to be set to 0. (Remember that
										$instancedbmod is evaluated as an inclusive OR for all
										entities in the instance.) </entry>
								</row>
								<row>
									<entry> release/mod </entry>
									<entry> Sets $instancedbmod to 1 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>remocc </entry>
									<entry> Sets $instancedbmod to 1 </entry>
									<entry> If the removed occurrence is in the database.
										Entity-level indicators are set only for the entity and its
										related entities. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the removed occurrence was added by the user and has
										not been stored. </entry>
								</row>
								<row>
									<entry>retrieve </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> If the only database fields that have been modified are
										in entities related to the retrieved entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only database fields that have been modified are
											<emphasis role="italic">not </emphasis>in entities
										related to the retrieved entity. </entry>
								</row>
								<row>
									<entry>retrieve/e </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> If the only database fields that have been modified are
										in inner entities related to the retrieved entity or in the
										retrieved entity itself. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only database fields that have been modified are
											<emphasis role="italic">not </emphasis>in entities
										related to the retrieved entity. </entry>
								</row>
								<row>
									<entry> store </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>store/e </entry>
									<entry> Sets $instancedbmod to 0 </entry>
									<entry> If the only modified database fields are in entities
										related to the stored entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only modified database fields are <emphasis
											role="italic">not </emphasis>in entities related to the
										stored entity. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>For more information, see Effects of Proc Statements on Instance-Level
						Proc Functions.</para>
				</sect2>
				<sect2>
					<title>Example: Exit Application Menu Item</title>
					<para>The following example is for an "Exit Application" menu item or command
						button of a parent form which may have any number of child forms. The module
						enables central checking of the modification status of all child forms.
						Without this module, each child form with unsaved data would produce a
						dialog box when the parent form is exited. The module also generates a list
						of unsaved instances to enable one-click saving of all the forms. </para>
					<programlisting role="uniface"><![CDATA[variables
   string unsaved
   string children
   string current_child
endvariables
unsaved = ""
children = ""
current_child = ""
; list all the children of the current form
children = $instancechildren
message "%%children%%%"
while (children != "")
   getitem current_child, children, 1
   delitem children, 1
   selectcase $instancedbmod(current_child)
      case 0
      ; The child"s data is stored in the database
      ; Insert some code to shut the form
      case 1
         putitem unsaved, -1, current_child
   endselectcase
endwhile
; Check if the parent form is saved
if ($instancedbmod != 0)
   putitem unsaved, -1, $instancename
endif
; are any items unsaved?
if (unsaved !="")
   askmess "Data has not been saved on forms:%%^%\
   %%unsaved%%% %%^Do you wish to exit?"
   if ($status = 0)
      return -1
   else
      apexit
   endif
else
   apexit
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancehandle">
				<title>$instancehandle</title>
				<para>Return the handle of the requested instance. </para>
				<sect2>
					<title>Syntax</title>
					<para>$instancehandle {(InstName)} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
					<para>InstName—component instance name; optional; can be a literal name, string,
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current instance is returned. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...<itemizedlist>
							<listitem>
								<para>Handle of the instance with the name InstName. </para>
							</listitem>
							<listitem>
								<para>NULL handle in the following circumstances: <itemizedlist>
										<listitem>
											<para>An error occurred. $procerror contains a negative
												value that identifies the exact error </para>
										</listitem>
										<listitem>
											<para>InstName is an incorrect instance name. </para>
										</listitem>
										<listitem>
											<para>The instance with the name InstName has been
												deleted. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$instancehandle</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -57 </entry>
										<entry> UACTERR_NO_INSTANCE </entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> UPROCERR_FIELD</entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following example obtains the handle myHandle which is a handle to
						the current component instance:
						<programlisting role="uniface"><![CDATA[variables
   handle myHandle
endvariables
myHandle = $instancehandle()]]></programlisting></para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancemod">
				<title>$instancemod</title>
				<para>Return the modification status of data in the current component instance. </para>
				<sect2>
					<title>Syntax</title>
					<para>$instancemod{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>InstName—component instance name; optional; can be a literal name, string,
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current instance is returned. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $instancemod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 1 </entry>
										<entry> At least one field has been modified. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry>
											<itemizedlist>
												<listitem>
												<para>No field meeting the criteria above has been
												modified </para>
												</listitem>
												<listitem>
												<para>No entities are painted on the component
												</para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$instancemod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1105 </entry>
										<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
										<entry> The instance name provided is not valid (For more
											information, see the newinstance Proc statement); for
											example, the argument contains incorrect characters.
										</entry>
									</row>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. The InstName
											argument was omitted and one of the following occurred:
											There is no current instance, for example, in the
											Application Execute trigger. The current instance is a
											form started with run. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$instancemod is an instance-level function that tests the modification
						status of data in the component instance. </para>
					<para>The value of $instancemod is actually the inclusive OR of the values of
						the $occmod function for all the occurrences in the instance. </para>
				</sect2>
				<sect2>
					<title>Events Affecting $instancemod</title>
					<para>Events that cause a field to be recognized as modified include such things
						as: </para>
					<itemizedlist>
						<listitem>
							<para>The user entering a retrieve profile in an empty field. (This
								means that $instancemod can be set to 1 before a retrieve has been
								performed.) </para>
						</listitem>
						<listitem>
							<para>The user changing the value of data that has been retrieved.
							</para>
						</listitem>
						<listitem>
							<para>Modification of a non-database field made by a Proc assignment (=)
								without the /init switch. </para>
						</listitem>
					</itemizedlist>
					<para> The following statements affect the value of $instancemod: </para>
					<table>
						<title>Table 3. Statements that change $instancemod (or $formmod)</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Statement </entry>
									<entry> Action </entry>
									<entry> Discussion </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> clear </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>clear/e </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> If the only fields modified are in entities related to
										the cleared entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only fields modified are <emphasis role="italic"
											>not </emphasis>in entities related to the cleared
										entity. </entry>
								</row>
								<row>
									<entry> creocc </entry>
									<entry> Sets $instancemod to 1 </entry>
									<entry> Entity-level indicators are set for the created
										occurrence and its related entities. </entry>
								</row>
								<row>
									<entry> erase </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>erase/e </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> If the only fields modified are in entities related to
										the erased entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only fields modified are <emphasis role="italic"
											>not </emphasis>in entities related to the erased
										entity. </entry>
								</row>
								<row>
									<entry> release </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>release/e </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> If the only fields modified are in entities related to
										the released entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only fields modified are <emphasis role="italic"
											>not </emphasis>in entities related to the released
										entity. </entry>
								</row>
								<row>
									<entry> release/e/mod </entry>
									<entry> Sets $instancemod to 1 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> release/mod </entry>
									<entry> Sets $instancemod to 1 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> remocc </entry>
									<entry> Sets $instancemod to 1 </entry>
									<entry> Entity-level indicators are set only for the entity and
										its related entities. </entry>
								</row>
								<row>
									<entry>retrieve </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> If the only fields that have been modified are in
										entities related to the retrieved entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only fields that have been modified are <emphasis
											role="italic">not </emphasis>in entities related to the
										retrieved entity. </entry>
								</row>
								<row>
									<entry>retrieve/e </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> If the only fields that have been modified are in inner
										entities related to the retrieved entity or in the retrieved
										entity itself. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only fields that have been modified are <emphasis
											role="italic">not </emphasis>in entities related to the
										retrieved entity. </entry>
								</row>
								<row>
									<entry> store </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> </entry>
								</row>
								<row>
									<entry>store/e </entry>
									<entry> Sets $instancemod to 0 </entry>
									<entry> If the only modified fields are in entities related to
										the stored entity. </entry>
								</row>
								<row>
									<entry> No change </entry>
									<entry> If the only modified fields are <emphasis role="italic"
											>not </emphasis>in entities related to the stored
										entity. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para> For more information, see Effects of Proc Statements on Instance-Level
						Proc Functions. </para>
				</sect2>
				<sect2>
					<title>Example: Checking for Form Modifications</title>
					<para>In the following example, a Quit Proc code examines $instancemod to
						determine if any modifications have been made in the form instance. If there
						have been modifications, the user is asked to confirm before the
						modifications are lost. </para>
					<para>If the user does not want to ^QUIT, the Proc code ends with a status code
						that prevents the form from ending; that is, the form remains displayed, and
						the user is able to ^ACCEPT the modifications. If the user does want to
						^QUIT, the Proc code ends normally, allowing the form to end. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Quit
; test for modifications
; -1 prevents end of edit session
if ($instancemod = 0)
return 0
else
askmess "Please confirm QUIT (Y/N)"
if ($status = 1)
return 0
else
return -1
endif
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancename">
				<title>$instancename</title>
				<para>Return the name of the current component instance. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$instancename</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Name of current component instance in uppercase. </para>
							</listitem>
							<listitem>
								<para>Name of the current form in uppercase, if the form was started
									with run. </para>
							</listitem>
							<listitem>
								<para>Name of the startup shell, if no form is current (for example,
									in the Application Execute trigger). </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if an error occurred. $procerror contains a
									negative value that identifies the exact error </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$instancename</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. For example,
											there is no current instance in the Application Execute
											trigger. The current instance is a form started with
											run. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Tracing Application Execution </title>
					<para> You can use the value in $instancename to help trace an application's
						execution. For example: </para>
					<programlisting role="uniface"><![CDATA[trigger _EXEC
putmess "Started instance %%$instancename at %%$clock"
edit
putmess "Terminated instance %%$instancename at %%$clock"
end ; end trigger]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instanceparent">
				<title>$instanceparent</title>
				<para>Return the name of the parent instance of the requested instance. </para>
				<sect2>
					<title>Syntax</title>
					<para>$instanceparent{( InstName )}</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> InstName—component instance name; optional; can be a literal name,
						string, variable, function, parameter, or indirect reference to a field
						containing the name. If omitted, the current instance (started with
						newinstance or activate) is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...<itemizedlist>
							<listitem>
								<para>Name of the parent instance of InstName when: <itemizedlist>
										<listitem>
											<para>InstName is a modal form instance that is not
												started from the Application Execute trigger.
											</para>
										</listitem>
										<listitem>
											<para>InstName is an attached, non-modal component
												instance. (A detached, non-modal component instance
												has no parent.) </para>
										</listitem>
									</itemizedlist>
								</para>
							</listitem>
							<listitem>
								<para>Empty string (""), in the following circumstances: <itemizedlist>
										<listitem>
											<para>InstName is a child of the application screen. For
												example, InstName is a detached, non-modal form
												instance or is a modal form instance started from
												the Application Execute trigger. </para>
										</listitem>
										<listitem>
											<para>InstName is running on a server and its parent is
												running on the client. In this case, InstName is
												considered to be a child of the application screen
												that belongs to the Application Server application.
											</para>
										</listitem>
										<listitem>
											<para>An error occurred. $procerror contains a negative
												value that identifies the exact error. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$instanceparent</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1105 </entry>
										<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
										<entry> The instance name provided is not valid (For more
											information, see the new_instance Proc statement); for
											example, the argument contains incorrect characters.
										</entry>
									</row>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. The InstName
											argument was omitted and one of the following occurred:
											There is no current instance, for example, in the
											Application Execute trigger. The current instance is a
											form started with run. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Reporting the Parent of the Current Instance </title>
					<para>...</para>
					<para>The following example reports the current instance's parent in the message
						frame: </para>
					<programlisting role="uniface"><![CDATA[putmess "%%$instanceparent%%% is the parent of %%$instancename%%%" ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancepath">
				<title>$instancepath</title>
				<para>Return the path with which the current instance is registered. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$instancepath</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...<itemizedlist>
							<listitem>
								<para>Name of the path for the current instance in uppercase.
								</para>
							</listitem>
							<listitem>
								<para>Empty string (""), if the current application did not register
									with the Uniface Router when it started. </para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $instancepath function can be useful to pass addressing information to
						another component instance. </para>
				</sect2>
				<sect2>
					<title>Example: Starting a Component and Passing Data to an Operation</title>
					<para>The Detail trigger of a field in the form COMP1 contains the following
						code. It starts a new instance of the component COMP2, prepares data for the
						operation TELL_ME_LATER, then hands the data to the operation. </para>
					<programlisting role="uniface"><![CDATA[; Trigger: Detail of field DO_IT
; prepare the data for TELL_ME_LATER
; prepare the my return address
variables
   string MYADRESS
endvariables
newinstance/async "COMP2", "INST2"
DATA = ...
MYADDRESS = "%%$instancepath:%%$instancename"
activate "INST2".TELL_ME_LATER (MYADDRESS, DATA)
]]></programlisting>
					<para>The operation TELL_ME_LATER does what is required, then sends the result
						back to the calling instance: </para>
					<programlisting role="uniface"><![CDATA[; Trigger: Operations of component COMP2
; prepare data to be returned
operation TELL_ME_LATER
params
   string RETURN_ADDRESS : IN
   string DATA : IN
endparams
variables
   string DATAOUT
endvariables
...
DATAOUT = ...
postmessage "%%RETURN_ADDRESS", "RESULT", "%%DATAOUT"
end
]]></programlisting>
					<para>The message is received by the Asynchronous Interrupt trigger of COMP1: </para>
					<programlisting role="uniface"><![CDATA[; Trigger: Asynchronous Interrupt of component COMP1
selectcase $msgid
   case "RESULT"
      askmess "Result from %%$msginfo("INSTANCENAME") available in message frame."
      putmess "Received the following result from %%$msginfo("SRC") :"
      putmess "%%$msginfo("DATA")"
   case ...
...
endselectcse
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instances">
				<title>$instances</title>
				<para>Return a list of instances that belong to a specified component. </para>
				<sect2>
					<title>Syntax</title>
					<para>$instances ( CompName , Filter ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...<itemizedlist>
							<listitem>
								<para>CompName—component name; can be a literal name, a string, a
									variable, function, parameter or indirect reference to a field
									containing the name. If CompName is empty (""), a list of
									instances that belong to the current component is returned.
								</para>
							</listitem>
							<listitem>
								<para>Filter—returns a list of instances that belong to the current
									transaction; Filter can be an empty string ("") or
									"IN_CURRENT_TRANS". </para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Indexed list of instances belonging to the specified
									component. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") if If no instances are found. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Example: Activating all Instances of an Entity Service </title>
					<para> The following example activates all instances of the entity service
						defined for ENT1: </para>
					<programlisting role="uniface"><![CDATA[$ObjSvc$ = $entinfo(ENT1, "OBJECTSERVICE")
if ($ObjSvc$)
$ObjSvcInstance$ = $instances($ObjSvc$,"")
if (!$status)
activate $ObjSvcInstance$.MyOperation()
endif
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Listing Instances </title>
					<para> The following example provides a message with a list of all instances of
						$instlist$ = $instances("MyService", "") </para>
					<programlisting role="uniface"><![CDATA[
message "The instances of MyService are %%$instlist$"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_instancevalidation">
				<title>$instancevalidation</title>
				<para>Identify whether data in the component instance requires validation. </para>
				<sect2>
					<title>Syntax</title>
					<para>$instancevalidation{( InstName )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>InstName—component instance name; optional; can be a literal name, string,
						variable, function, parameter, or indirect reference to a field containing
						the name. If omitted, the current instance is returned. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $instancevalidation</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "" </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry>
										<itemizedlist>
											<listitem>
												<para>No data has been modified. </para>
											</listitem>
											<listitem>
												<para>All the data has already been successfully
												validated. </para>
											</listitem>
										</itemizedlist>
										<para> You can check the value of $instancemod to determine
											which of these situations applies. </para>
									</entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> Data requires validation. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$instancevalidation</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -57 </entry>
									<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
									<entry> The named instance cannot be found in the component
										pool. </entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
								<row>
									<entry> -1105 </entry>
									<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
									<entry> The instance name provided is not valid. (See the
										new_instance Proc statement for more information.) For
										example, the argument contains incorrect characters.
									</entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
									<entry> Function not allowed, unknown context. The InstName
										argument was omitted and one of the following occurred:
										There is no current instance, for example, in the
										Application Execute trigger. The current instance is a form
										started with run. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $instancevalidation checks if any occurrence in the current
						component instance requires validation. This can be viewed as an inclusive
						OR of $occvalidation for all occurrences in the instance. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses $instancevalidation to check the validation
						status of the current form: </para>
					<programlisting role="uniface"><![CDATA[if ($instancevalidation = 1)
   message/info "Some data has not been validated."
endif
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_int">
				<title>$int</title>
				<para> Introduced in: U8 </para>
				<para>Return the integer part of X. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$int</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
					<para>X—numeric constant, or a field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
					<para>Calculated value. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...</para>
					<para>The following example returns the integer part of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$intpart$ = $int(ANUMBER / 1000)
]]></programlisting>
					<para>If the value of ANUMBER is 3456, the value stored in $intpart$ is 3.
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_interactive">
				<title>$interactive</title>
				<para>Return a status indicating whether the current form component is in
					interactive state. </para>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$interactive</command>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $interactive</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Form component is not in an interactive state.
										</entry>
									</row>
									<row>
										<entry> 1</entry>
										<entry> Form component is in an interactive state. </entry>
									</row>
									<row>
										<entry> 2 </entry>
										<entry> User interface of the form component is starting (an
											edit/deferred statement has just been executed).
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
					<para>The $interactive function allows you to test whether the current form
						component is in interactive state. Interactive state is started with either
						edit/modal or edit/nonmodal. It is terminated by executing either the Accept
						or Quit trigger. </para>
				</sect2>
				<sect2>
					<title>Example: Starting an Edit session if Application is not in Interactive
						Mode </title>
					<para>The following example shows how to start an edit session only if the
						application is not already in interactive mode: </para>
					<programlisting role="uniface"><![CDATA[operation editCustomer
;- do an edit only if not already in interactive mode -
if ( !$interactive )
   edit/nonmodal
endif
end ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_ioprint">
				<title>$ioprint</title>
				<para> Return or set the message level in the message frame. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$ioprint</command> = Expression </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Value indicating the types of I/O message sent to the message frame. The
						value is the sum of the codes shown in the following table: </para>
					<table>
						<title>Table 1. I/O Message Codes </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Code </entry>
									<entry> Description </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> Store sequence messages. See Message Level 1: Store
										Sequence Messages </entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry> Connector requests. See Message Level 2: DBMS Connector
										Requests </entry>
								</row>
								<row>
									<entry> 4 </entry>
									<entry> Return values from Fetch and Select connector requests.
										See Message Level 4: Return Values from Fetch and Select
										Connector Requests </entry>
								</row>
								<row>
									<entry> 8 </entry>
									<entry> Description from Open connector request. See Message
										Level 8: Description Block from Open Connector Request
									</entry>
								</row>
								<row>
									<entry> 16 </entry>
									<entry> Descriptions from where and order by clauses. See
										Message Level 16: Descriptions From where and order by
										Clauses </entry>
								</row>
								<row>
									<entry> 32 </entry>
									<entry> Generated SQL (if available). See Message Level 32:
										Generated SQL </entry>
								</row>
								<row>
									<entry> 64 </entry>
									<entry> All system calls Uniface sends to operating system. See
										Message Level 64: All System Calls Uniface Sends to
										Operating System </entry>
								</row>
								<row>
									<entry> 128 </entry>
									<entry> All calls to global objects and descriptors. See Message
										Level 128: All Calls to Global Objects and Descriptors
									</entry>
								</row>
								<row>
									<entry> 512 </entry>
									<entry> All activate calls.</entry>
								</row>
								<row>
									<entry> 1024 </entry>
									<entry> Network messages </entry>
								</row>
								<row>
									<entry> 2048 </entry>
									<entry> Image loader information </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If the sum of the codes is 0, no information is placed in the message
						frame. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>If $ioprint is used to set the message level, Expression must evaluate to
						a numeric value representing the sum of the codes for the desired messages.
					</para>
				</sect2>
				<sect2>
					<title>Example: Checking for Information in the Message Frame </title>
					<para>The following example shows how you can use $ioprint to determine whether
						there is any information in the message frame. If there is information, you
						can refer the user to it. If there is not, you can display an appropriate
						message. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Retrieve
; $$MESSAGE is a specific message for when $status = -2
; retrieve failed, see message frame
; specific retrieve error message
; retrieve I/O error, see message frame
; retrieve error %%$entname not found
retrieve
if ($status)
if ($status = -2)
if ($ioprint)
if ($$message)
message $text(1572)
endif
else
message $$message
endif
else
if ($status = -3)
if ($ioprint)
message $text(1501)
else
message $text(1760)
endif
endif
endif
endif
return ($status)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_italic">
				<title>$italic</title>
				<para> Apply the italic character attribute to a string.</para>
				<para>Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$italic</command> ( <parameter>String</parameter>) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>String—string, or a field (or indirect reference to a field), a variable,
						or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the result of applying the italic character attribute to String
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types but is only applicable to unifields.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $italic returns the result of applying the italic character
						attribute to String. The result is visible only in a displayed
						unifield.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[MY_UNIFIELD = $italic("aaabbb")]]></programlisting> Afterwards,
						MY_UNIFIELD contains <emphasis role="italic">aaabbb</emphasis>. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_item">
				<title>$item</title>
				<para> Introduced in: U8 </para>
				<para>Return the value that corresponds to a given ID in an associative list. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$item</command> ( <parameter>ID, AssociativeList</parameter>)
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Value that corresponds to the given ID in an associative list.
								</para>
							</listitem>
							<listitem>
								<para>NULL (""), if ID is not found in AssociativeList; $procerror
									is set to UPROCERR_ITEM (-1129). </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $item function acts in the same way as the getitem/id Proc statement,
						but can also be used as part of an expression. </para>
					<para>For more information on the structure of lists, see Lists and Sublists.
					</para>
				</sect2>
				<sect2>
					<title>Example: Find and Pass Associative List Items</title>
					<para>The following example shows how to find and directly pass an associative
						list item to a Proc module: </para>
					<programlisting role="uniface"><![CDATA[if ($item("MEDIUM", myList) = "Book")
   call selectBook($item("ISBN_NR", myList)
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_itemcount">
				<title>$itemcount</title>
				<para> Introduced in: U9 </para>
				<para>Return the number of items in a list.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$itemcount</command> ( <parameter>List</parameter>) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>List—string containing the list to be checked.</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Number of items in a list</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $itemcount function enables you to determine how many items are in a
						list before processing each item.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$1 = 0
$2 = $itemcount ("$mylist$")
while $1 &lt;= $2
		$1 += 1
endwhile ]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_itemnr">
				<title>$itemnr</title>
				<para> Introduced in: U8 </para>
				<para>Return the list item that corresponds to a given sequence number in a list. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$itemnr</command> ( <parameter>N, List</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>N—sequence number </para>
						</listitem>
						<listitem>
							<para>List—list from which to extract an item </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> If the Nth item is not found in List, the $itemnr function returns NULL.
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $itemnr function acts in the same way as the getitem Proc statement,
						but can also be used as part of an expression. </para>
					<para>For more information on the structure of lists, see Lists and Sublists.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_keyboard">
				<title>$keyboard</title>
				<para>Return or set the current keyboard translation table. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$keyboard</command> = <parameter>Table</parameter>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
					<para>Table—a string, or a field (or indirect reference to a field), a variable,
						or a function that evaluates to a string; the string should contain the name
						of the desired keyboard translation table. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Name of the keyboard table currently in use. The values returned by
						default for each GUI are shown in the following table: </para>
					<table>
						<title>Table 1. Default values of $keyboard</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> GUI </entry>
									<entry> Default value of $keyboard </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Character mode </entry>
									<entry> USYSTERM </entry>
								</row>
								<row>
									<entry> Microsoft Windows </entry>
									<entry> MSWINX </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The $keyboard function can return or set the current keyboard translation
						table. </para>
					<para>The Switch Keyboard trigger on the startup shell object is often used to
						assign a new value to the $keyboard function. This trigger is activated at
						any time in the application when the user enters ^SWITCH_KEY. The default
						value (if UKEYB or $keyboard have not been set) is determined by the GUI in
						use. </para>
				</sect2>
				<sect2>
					<title>Example: Switching Keyboard Layouts</title>
					<para>The Proc code in the example below switches between a keyboard layout with
						numeric keys, and a keyboard layout without numeric keys on a VT200
						terminal. When VTNUM is in use, the <emphasis role="italic">9</emphasis> key
						means 9; when VT200 is in use, the <emphasis role="italic">9</emphasis> key
						means CLEAR. The VT200 table is the USYS standard layout. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Switch Keyboard
if ($keyboard = "VTNUM")
   $keyboard = "VT200"
else
   $keyboard = "VTNUM"
endif]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Switchin Keyboard Layouts for a Field </title>
					<para>The following example switches to a keyboard with numeric keys for one
						field only. When the user enters a particular numeric field with NEXT_FIELD,
						the keyboard layout is switched to the alternate layout. When they leave the
						field with NEXT_FIELD, the default keyboard layout is restored: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Next Field (of field before numeric field)
; switch to VTNUM keyboard
; trigger: Next Field (of numeric field)
; switch to VT200 keyboard
$keyboard = "VTNUM"
$keyboard = "VT200"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_keycheck">
				<title>$keycheck</title>
				<para>Return or set the requirement for checking a key. </para>
				<sect2>
					<title>Syntax</title>
					<para>$keycheck ( Entity , KeyNumber ) </para>
					<para>$keycheck ( Entity , KeyNumber ) = Expression </para>
					<para>set | reset $keycheck ( Entity , KeyNumber ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity name; can be a literal name, string, variable,
									function, parameter, or indirect reference to a field. </para>
							</listitem>
							<listitem>
								<para>KeyNumber—key that is to be located; can be a constant, or a
									field (or indirect reference to a field), a variable, or a
									function that can be converted to a whole (integer) number; the
									value will be truncated to form an integer. <itemizedlist>
										<listitem>
											<para>1, the primary key. </para>
										</listitem>
										<listitem>
											<para>2, 3, 4, and so on, the number that identifies a
												candidate key that has been defined for Entity on
												the Define Key form. (Indexes are not allowed.)
											</para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $keycheck</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Key checking is <emphasis role="italic">not
										</emphasis>enabled. </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> Key checking is currently enabled. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para> If an error occurs, $procerror$procerror contains a negative value that
						identifies the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following $keycheck </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1104 </entry>
									<entry> &lt;UPROCERR_KEY&gt; </entry>
									<entry> The key number provided is not valid; for example, the
										key number was out of range. </entry>
								</row>
								<row>
									<entry> -1128 </entry>
									<entry> &lt;UPROCERR_NOT_A_KEY&gt; </entry>
									<entry> The key number specified is an index. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Values returned in $status when $keycheck is used as the
							target of an assignment: </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> ""</entry>
									<entry> Kkey checking could not be enabled because an error
										occurred. </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> key checking was successfully enabled. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $keycheck returns a value that indicates whether the
						developer intends for validation to be carried out for the specified key the
						next time that it can occur. If $keycheck indicates that validation is
						demanded, the validation is performed regardless of whether validation is
						actually required. (Validation is required when both $keymod and
						$keyvalidation are 1, indicating that the key has been modified, but has not
						yet been validated.) </para>
					<para>Validation can occur when the user leaves all fields of the key (for
						example, with ^NEXT_FIELD, ^PREV_FIELD, or a mouse click); when an explicit
						validation statement is encountered (for example, validatekey); or when a
						store statement is encountered. It includes syntax checks on the fields
						comprising the key, activation of the Validate Key trigger, and, in forms
						only, activation of the Leave Modified Key trigger. After validation
						completes, $keycheck is set to 0. </para>
					<para>You can also use $keycheck as the target in the left-hand side of an
						assignment. Set $keycheck to 1 to require checking for the specified key;
						set it to 0 to let Uniface take responsibility for validation. For example: </para>
					<programlisting role="uniface"><![CDATA[$keycheck = !$keycheck ]]></programlisting>
					<para>Because $keycheck is essentially a Boolean function, when Expression
						evaluates to a nonzero value, $keycheck becomes 1. </para>
				</sect2>
				<sect2>
					<title>Example: Checking for Keys </title>
					<para> The following example shows this function being used in the Occurrence
						Gets Focus trigger: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus:
; check of primary key needed
; check of candidate key needed
set $keycheck(CUST_NUMBER.CUSTOMER, 1)
set $keycheck(CUST_NUMBER.CUSTOMER, 2) ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_keyfields">
				<title>$keyfields</title>
				<para>Return a list of the fields that make up a key or index. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$keyfields</command> ( <parameter>Entity, Keynumber</parameter>)
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity name; can be a literal name, string, variable,
									function, parameter, or indirect reference to a field. </para>
							</listitem>
							<listitem>
								<para>KeyNumber—key that is to be located; can be a constant, or a
									field (or indirect reference to a field), a variable, or a
									function that can be converted to a whole (integer) number; the
									value will be truncated to form an integer. <itemizedlist>
										<listitem>
											<para>1, the primary key. </para>
										</listitem>
										<listitem>
											<para>2, 3, 4, and so on, the number that identifies a
												candidate key that has been defined for Entity on
												the Define Key form. (Indexes are not allowed.)
											</para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>String that contains an indexed list of the fields that make up
								the specified key or index. </para>
						</listitem>
						<listitem>
							<para>An empty string ("") is returned if an error occurred. $procerror
								contains a negative value that identifies the exact error. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$keyfields</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1104 </entry>
									<entry> &lt;UPROCERR_KEY&gt; </entry>
									<entry> The key number provided is not valid; for example, the
										key number was out of range. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> The following example use the $keyfields statement:
						<programlisting role="uniface"><![CDATA[$MAXKEYS$ = $totkeys
$KEYNBR$ = 1
while ($KEYNBR$ &lt;= $MAXKEYS$)
putmess "Keyfields = %%$keyfields($entname, $KEYNBR$)%%%"
$KEYNBR$ = $KEYNBR$ + 1
endwhile ]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_keymod">
				<title>$keymod</title>
				<para>Return an indication if the specified key has been modified. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$keymod</command> ( <parameter>Entity, Keynumber</parameter>)
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity name; can be a literal name, string, variable,
									function, parameter, or indirect reference to a field. </para>
							</listitem>
							<listitem>
								<para>KeyNumber—key that is to be located; can be a constant, or a
									field (or indirect reference to a field), a variable, or a
									function that can be converted to a whole (integer) number; the
									value will be truncated to form an integer. <itemizedlist>
										<listitem>
											<para>1, the primary key. </para>
										</listitem>
										<listitem>
											<para>2, 3, 4, and so on, the number that identifies a
												candidate key that has been defined for Entity on
												the Define Key form. (Indexes are not allowed.)
											</para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $keymod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Specified key has not been modified. </entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Specified key has been modified. </entry>
									</row>
									<row>
										<entry> ""</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$keymod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
									<row>
										<entry> -1104 </entry>
										<entry> &lt;UPROCERR_KEY&gt; </entry>
										<entry> The key number provided is not valid; for example,
											the key number was out of range. </entry>
									</row>
									<row>
										<entry> -1128 </entry>
										<entry> &lt;UPROCERR_NOT_A_KEY&gt; </entry>
										<entry> The key number specified is an index. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the $keymod function: </para>
					<programlisting role="uniface"><![CDATA[if ( $keymod("CUST", 2) &amp; !$keyvalidation("CUST", 2) )
message "The modification of the second key of CUST has been validated."
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_keytype">
				<title>$keytype</title>
				<para>Return the type of the specified key. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$keytype</command> ( <parameter>Entity, KeyNumber</parameter>)
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity name; can be a literal name, string, variable,
									function, parameter, or indirect reference to a field. </para>
							</listitem>
							<listitem>
								<para>KeyNumber—key that is to be located; can be a constant, or a
									field (or indirect reference to a field), a variable, or a
									function that can be converted to a whole (integer) number; the
									value will be truncated to form an integer. <itemizedlist>
										<listitem>
											<para>1, the primary key. </para>
										</listitem>
										<listitem>
											<para>2, 3, 4, and so on, the number that identifies a
												candidate key that has been defined for Entity on
												the Define Key form. (Indexes are not allowed.)
											</para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> "P" </entry>
										<entry>
											<emphasis role="italic">KeyNumber </emphasis>indicates a
											primary key (that is, <emphasis role="italic">KeyNumber
											</emphasis>is 1). </entry>
									</row>
									<row>
										<entry> "C"</entry>
										<entry>
											<emphasis role="italic">KeyNumber </emphasis>indicates a
											candidate key. </entry>
									</row>
									<row>
										<entry> "I"</entry>
										<entry>
											<emphasis role="italic">KeyNumber </emphasis>indicates
											an index. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$keytype</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
									<row>
										<entry> -1104 </entry>
										<entry> &lt;UPROCERR_KEY&gt; </entry>
										<entry> The key number provided is not valid; for example,
											the key number was out of range. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Defining the Validation for Specific Keys </title>
					<para>The following example uses the $keytype function to define the validation
						for specific keys in the Validate Key trigger. (The Validate Key trigger is
						activated only for primary and candidate keys.) </para>
					<programlisting role="uniface"><![CDATA[; trigger: Validate Key
; perform validation for the primary key
; perform validation for all candidate keys
; oops
selectcase $keytype("MYENTITY", $curkey)
   case "P"
      ...
   case "C"
      ...
   elsecase
      message "Cannot validate this key"
      message "Context: %%$dataerrorcontext"
endselectcase ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_keyvalidation">
				<title>$keyvalidation</title>
				<para>Identify whether a key requires validation. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$keyvalidation</command> ( <parameter>Entity,
						KeyNumber</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity name; can be a literal name, string, variable,
									function, parameter, or indirect reference to a field. </para>
							</listitem>
							<listitem>
								<para>KeyNumber—key that is to be located; can be a constant, or a
									field (or indirect reference to a field), a variable, or a
									function that can be converted to a whole (integer) number; the
									value will be truncated to form an integer. <itemizedlist>
										<listitem>
											<para>1, the primary key. </para>
										</listitem>
										<listitem>
											<para>2, 3, 4, and so on, the number that identifies a
												candidate key that has been defined for Entity.
												(Indexes are not allowed.) </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $keyvalidation</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> ""</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> No validation is required. </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Key requires validation. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$keyvalidation</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
									<row>
										<entry> -1104 </entry>
										<entry> &lt;UPROCERR_KEY&gt; </entry>
										<entry> The key number provided is not valid; for example,
											the key number was out of range. </entry>
									</row>
									<row>
										<entry> -1128 </entry>
										<entry> &lt;UPROCERR_NOT_A_KEY&gt; </entry>
										<entry> The key number specified is an index. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> A key needs validation in either of the following circumstances: <itemizedlist>
							<listitem>
								<para>Validation is required because data in one of the fields that
									makes up the key has been modified ($keymod is 1), but has not
									yet been successfully validated ($keyvalidation is also 1).
								</para>
							</listitem>
							<listitem>
								<para>Validation has been demanded by Proc code ($keycheck is 1),
									regardless of the value of $keyvalidation. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Example: Validating Keys </title>
					<para>The following example uses the $keyvalidation function: </para>
					<programlisting role="uniface"><![CDATA[; for each key
; if validation is pending,
; do it
; uh-oh
; next key, please
$MYENT$ = "CUST"
$1 = 1
while ( $1 &lt;= $totkeys($MYENT$))
if ($keyvalidation ($MYENT$, $1) &gt; 0)
validatekey $MYENT$, $1
if ($status &lt; 0)
return -1
endif
endif
$1 = $1 + 1
endwhile]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_labelproperties">
				<title>$labelproperties</title>
				<para> Introduced in: U9 </para>
				<para>Get and set the text of an attached label.</para>
				<sect2>
					<title>Syntax</title>
					<para>$labelproperties ( FieldName ) = "text= LabelText " </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FieldName—name of the field to which the label is attached;
									can be a literal name, or a string, variable function,
									parameter, or indirect reference to a field containing the name.
								</para>
							</listitem>
							<listitem>
								<para>LabelText—text of the label </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned by
							$labelproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Forms</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $labelproperties function makes it possible to dynamically change an
						attached label. It does not work with non-attached labels. </para>
					<para>Labels are user interface objects, so they can only be addressed when the
						presentation layer is available. This is after the form has been initially
						displayed using a show or edit statement. You can then use one of these
						statements again to refresh the display.</para>
					<para>The label dimensions as drawn on the form must be large enough to
						accomodate the assigned name; otherwise, the label is truncated.</para>
					<para>Although it can work with any widget type, $labelproperties is especially
						useful in the grid widget because it enables the attached label of the field
						shown as the column title to be changed dynamically. In grid widgets, if the
						label contains a new line character, it is concatenated into one line.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> </para>
					<para>In the following example, the field labels of the ABBREVIATION and
						FULLNAME fields are set in the Execute trigger. The show command draws the
						form, making the label available. After the $labelproperties instructions,
						the edit command refreshes the display with the new labels.</para>
					<programlisting role="uniface"><![CDATA[;Execute trigger
show
$labelproperties (ABBREVIATION) = "text=Initials"
$labelproperties (FULLNAME) = "text=Employee Name"
edit]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_language">
				<title>$language</title>
				<para>Return or set the current language code. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$language</command> = <parameter>Language</parameter>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Language—name of the desired language; can be a string, or a field (or
						indirect reference to a field), a variable, or a function that evaluates to
						a string. It is recommended that you use the country codes from the ISO or
						ANSI standards. Return Values </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> Current language code.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained).</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use $language to set or return the name of the current language. If the
						language has not been set in an assignment file (with the setting $LANGUAGE
						in USYS:usys.asn or your local assignment file), it defaults to USA. If you
						explicitly define a value for $language, the assignment file setting is
						ignored. </para>
				</sect2>
				<sect2>
					<title>Example: Setting $language </title>
					<para> The following example saves the current language in general variable $1,
						and sets the current language to German, which has a country code of D:
						<programlisting role="uniface"><![CDATA[; save current language
; set current language to German
$1 = $language $language = "D"
]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Example: Setting $language and $variation</title>
					<para>The following example shows how to correctly set $language and $variation.
						The example assumes that you do not want to override any assignment file
						settings, but do want to change the language and library if the defaults
						have been given. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Application Execute
if ($language = "USA") ; default language used, so change to UK
$language = "UK"
endif ; otherwise, leave alone
if ($variation = "USYS") ; default library used, so change to TECH_PUBS
$variation = "TECH_PUBS"
endif ; otherwise, leave alone
]]></programlisting>
					<para>The only problem with the example (and the problem is unavoidable) is that
						the assignment file below is ignored: </para>
					<programlisting role="uniface"><![CDATA[$LANGUAGE = USA
$VARIATION = USYS]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_ldir">
				<title>$ldir</title>
				<para> Introduced in: U8 </para>
				<para>Return the name of the working directory. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$ldir</command> ( ) </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Name of the working directory, which can be located in a ZIP
						archive.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The working directory is set by one of the following:</para>
					<itemizedlist>
						<listitem>
							<para>The directory in which the application is started </para>
						</listitem>
						<listitem>
							<para>Command line switch /dir, which overrides the start-up directory
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_ldirlist">
				<title>$ldirlist</title>
				<para>Return the contents of the specified directory. </para>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para> $ldirlist ( DirPath {, Topic}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>DirPath—directory path, that is, one that ends with a
									directory separator. The directory can be located inside a ZIP
									archive. The directory name (or its suffix) can contain the
									Uniface wildcard characters <emphasis role="underline"
										>?</emphasis> (GOLD ?) or <emphasis role="underline"
										>*</emphasis> (GOLD *). </para>
							</listitem>
							<listitem>
								<para>Topic—type of item to return; one of: <itemizedlist>
										<listitem>
											<para>FILE—list files in the specified path; default if
												Topic is omitted or an empty string, FILE is
												assumed. </para>
										</listitem>
										<listitem>
											<para>DIR—list subdirectories in the specified path
											</para>
										</listitem>
										<listitem>
											<para>DATASET—z/OS only; list datasets that have the
												specified path as prefix </para>
										</listitem>
										<listitem>
											<para>MEMBER—z/OS only; list PDS file members </para>
										</listitem>
									</itemizedlist><emphasis role="bold"> Note:</emphasis>  Using
									DATASET or MEMBER makes your code platform-specific and
									non-portable. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List of files or subdirectories (depending on Topic) separated
									by GOLD ; ( <emphasis role="underline">;</emphasis> ). </para>
							</listitem>
							<listitem>
								<para>Empty list ("") if the directory is empty, does not exist, or
									an error occurred. $procerror contains the exact error. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values commonly returned by $procerror following
								$ldirlist and $dirlist</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
									<row>
										<entry> -1110</entry>
										<entry> &lt;UPROCERR_TOPIC&gt;</entry>
										<entry> Topic name not known. </entry>
									</row>
									<row>
										<entry> -1132</entry>
										<entry> &lt;UPROCERR_UNRESOLVED_TOPIC&gt;</entry>
										<entry> Topic could not be resolved. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $ldirlist function returns the contents of the specified directory,
						ignoring any file redirections in the assignment file. </para>
					<para>When using wildcards, a wildcard cannot match a dot if DIR is specified.
						If FILE is specified, it can match the dot between the file name and the
						extension. </para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On iSeries, DirPath can specify either a library, or a file in a library
							(<emphasis role="bold">library/.file</emphasis>, without a member name
						before the period). The objects returned depend on whether a library or file
						is specified, and the notation used, as well as the value of Topic. </para>
					<para>If you use IFS notation (DirPath contains the prefix <emphasis role="bold"
							>IFS:</emphasis> or <emphasis role="bold">!</emphasis>), libraries and
						files are considered to be directories. </para>
					<itemizedlist>
						<listitem>
							<para>If Topic is "file" $ldirlist returns all objects except files in
								the library specified, postfixed with their object types, or returns
								all members in the file postfixed with <emphasis role="bold"
									>.MBR</emphasis>. </para>
						</listitem>
						<listitem>
							<para>If Topic is "dir", $ldirlist returns only the file names in the
								library, postfixed with <emphasis role="bold">.FILE</emphasis>.
							</para>
						</listitem>
					</itemizedlist>
					<para>If the file specification does not use IFS notation, the following rules
						apply: </para>
					<itemizedlist>
						<listitem>
							<para>If DirPath is a library and: <itemizedlist>
									<listitem>
										<para>Topic is "file", all objects except files in the
											library are returned, postfixed with their object types,
											for example <emphasis role="bold"
											>PROGRAM.PGM</emphasis>; </para>
									</listitem>
									<listitem>
										<para>Topic is "dir", all file names in the library are
											returned, without postfixes; no other names (of object
											types) are returned; </para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>If DirPath is a file in a library (that is, <emphasis role="bold"
									>library/.file</emphasis>, without a member name before the
								period) and: <itemizedlist>
									<listitem>
										<para>Topic is "file", all member names of the file are
											returned, without postfixes; </para>
									</listitem>
									<listitem>
										<para>Topic is "dir", nothing is returned, because files
											cannot contain anything other than members. </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On z/OS, DirPath can return files or subdirectories in an HFS, datasets or
						prefixes, or PDS file members. The objects returned depend on the platform
						prefix specified in DIrPath, whether the notation indicates a partioned file
						system (PDS or PDSE), as well as the value of Topic. </para>
					<para>On HFS, $ldirlist works as it does on other platforms. However, on
						datasets, its behavior is different. it is also possible to specify DATASET
						or MEMBER as the Topic parameter.</para>
					<para>For more information, see $dirlist and $ldirlist on z/OS </para>
				</sect2>
				<sect2>
					<title>Example: Retrieving and Displaying Directory Contents</title>
					<para>The following Proc code retrieves the files in the directory <emphasis
							role="bold">drinks\tea</emphasis> in the current working directory and
						displays the files in the message frame line-by-line: </para>
					<programlisting role="uniface"><![CDATA[variables
string vFilePath, vContent
numeric N
endvariables
$dir$ = "drinks\tea"
; or $dir$ = "drinks/tea"
; or $dir$ = "[drinks.tea]"
vContent = $ldirlist($dir$,"File")
putmess "Files in directory '%%$dir$':"
N = 1
getitem vFilePath, vContent, N
while ($status &gt; 0)
putmess " %%vFilePath%%%"
N = N + 1
getitem vFilePath, vContent, N
endwhile
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_lfileexists">
				<title>$lfileexists</title>
				<para> Introduced in: U8 </para>
				<para>Returns a value that indicates whether the specified file or directory
					exists.</para>
				<sect2>
					<title>Syntax</title>
					<para>$lfileexists ( FilePath | DirPath ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
							<listitem>
								<para>DirPath—directory name, optionally preceded by the path to the
									directory. Must end with a directory separator </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned on all systems except AS/400</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> File or directory does not exist</entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> File exists</entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry> Directory exists</entry>
								</row>
								<row>
									<entry> 4</entry>
									<entry> File exists in a ZIP archive </entry>
								</row>
								<row>
									<entry> 5</entry>
									<entry> Directory exists in a ZIP archive</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values returned on AS/400</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> File or directory does not exist</entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> File member, or another object in a library,
										exists</entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry> File containing zero or more members</entry>
								</row>
								<row>
									<entry> 3</entry>
									<entry> Library exists </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Specifying File and Directory Paths</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>VMS</title>
					<para>On VMS, $lfileexists first checks for file, then for directory.</para>
				</sect2>
				<sect2>
					<title>Example: Checking if a File Exists</title>
					<para> The following example checks whether the file <emphasis role="bold"
							>test.txt</emphasis> exists in the directory <emphasis role="bold"
							>sub1dir</emphasis> and, if so, loads it: </para>
					<programlisting role="uniface"><![CDATA[$file$ = "sub1dir\test.txt"
; or $file$ = "sub1dir/test.txt"
; or $file$ = "[.sub1dir]test.txt"
; or $file$ = "[.sub1dir]test.txt;5" ; (VMS specific)
if ($lfileexists($file$) = 1) 
lfileload $file$, $content$ 
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_lfileproperties">
				<title>$lfileproperties</title>
				<para> Introduced in: U8 </para>
				<para>Return the properties of the specified file, directory, or zip archive,
					ignoring any file redirections in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para>$lfileproperties ( FilePath | DirPath {, Topic}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
							<listitem>
								<para>DirPath—directory name, optionally preceded by the path to the
									directory. Must end with a directory separator. </para>
							</listitem>
							<listitem>
								<para>Topic—associative list of attributes, separated by GOLD ; (
										<emphasis role="underline">;</emphasis> ). If omitted, all
									the available properties are returned. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> $lfileproperties returns a list of properties applicable to the file. The
						properties returned depend on the type of file.<itemizedlist>
							<listitem>
								<para>Associative list of Topic=Value pairs, separated by GOLD ; (
										<emphasis role="underline">;</emphasis> ). </para>
							</listitem>
							<listitem>
								<para>Empty list ("") if the file or directory does not exist, or an
									error occurred. $procerror contains the precise error. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Properties that can be returned by $lfileproperties and
								$fileproperties</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Topic</entry>
										<entry> Returned value</entry>
										<entry> Normal FIles</entry>
										<entry> Zip Files</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> FILETYPE </entry>
										<entry> On MS Windows, Unix, VMS, or z/OS—DIR or FILE On
											iSeries—DIR if it is an IFS directory (DIR or DDIR);
											FILE if the object is an IFS stream file (STMF or DSTMF)
											or a file in a library (*FILE); for other object types,
											the type returned by the OS, without the '*,' for
											example MBR, LIB, PGM, SRVPGM, USRSPC etc.</entry>
										<entry> X</entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> FILESIZE </entry>
										<entry> Size, in bytes, of the file or object. Not supported
											on z/OS datasets.</entry>
										<entry> X</entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> FULLPATH </entry>
										<entry> Full path to the file, or the file in a zip archive.
											When using relative paths, the path includes the working
											directory. If the file is in a zip archive, the zip file
											and path are specified by ZIPFILENAME </entry>
										<entry> X</entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> CREATIONDATE </entry>
										<entry> Date the file was created. String in the format
											yyyymmddhhmmsstt, where the ticks (tt) is always 00. For
											VMS, see MODIFICATIONDATE. Not supported on z/OS
											datasets, except for PDS members with ISPF statistic
											information.</entry>
										<entry> X</entry>
										<entry> </entry>
									</row>
									<row>
										<entry> MODIFICATIONDATE </entry>
										<entry> Last time the file was modified, in the same format
											as CREATIONDATE. Files located in zip archives have the
											modification date set rather than the creation date. On
											VMS, modifying the content of a file creates a new file
											version, which causes both the creation date and the
											modification date to be set. The modification date is
											different only when file attributes are changed, not
											when the content changes. Not supported on z/OS
											datasets, except for PDS members with ISPF statistic
											information.</entry>
										<entry> X</entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> ACCESSDATE </entry>
										<entry> Last time the file was accessed, in the same format
											as for CREATIONDATE. Not supported on VMS or z/OS
											datasets.</entry>
										<entry> X</entry>
										<entry> </entry>
									</row>
									<row>
										<entry> FILEATTRIBUTES </entry>
										<entry>
											<para>String containing the file attributes.</para>
											<itemizedlist>
												<listitem>
												<para>MS Windows—zero or more of the letters
												RHSACET, where R=read-only, H=hidden, S=system,
												A=archive, C=compressed, E=encypted. </para>
												<para>For files located in zip archives— T=text
												file or ""=other (binary) files </para>
												</listitem>
												<listitem>
												<para>UNIX—string is rw[x|s]rw[x|s]rwx. Granted
												permissions are represented by the respective
												letter in the string: </para>
												<para>r=read; w=write; x=execute; s=execute plus
												set user/group ID permission. This format
												resembles the format of ls -l. </para>
												<para>Absence of a permission is represented by a
												dash (-). </para>
												</listitem>
												<listitem>
												<para>iSeries—string is rw[x|s]rw[x|s]rwx. </para>
												<para>It is equivalent to what the QSH command ls
												-l File produces. If the file is an object in the
												library system, it is followed by a comma and
												RAUDE,OMEAR. </para>
												<para>This additonal string refers to the
												permissions for the object of the current process
												only; group or public authorities are not included
												(unlike the Unix-like part, which represents user,
												group and world privileges). </para>
												<para>RAUDE represents the data permissions: R:
												read; A: add; U: update; D: delete; E: execute </para>
												<para>OMEAR represents the object permissions: O:
												operation; M: management; E: existence; A: alter;
												R: reference. </para>
												<para>Absence of a particular privilege is
												represented by a dash -. </para>
												<para>For more information, refer to the iSeries
												documentation, such as the documentation of
												EDTOBJAUT. </para>
												</listitem>
												<listitem>
												<para>VMS—string is RWED,RWED,RWED,RWED </para>
												</listitem>
												<listitem>
												<para>z/OS—for HFS, same as for Unix; for dataset,
												RWX for read/write/execute </para>
												</listitem>
											</itemizedlist>
										</entry>
										<entry> X</entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> COMPRESSEDSIZE </entry>
										<entry> Size, in bytes, of the compressed file or object in
											a zip archive.</entry>
										<entry> </entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> CHECKSUM </entry>
										<entry> 32-bit number used to determine whether a file in a
											zip archive has been modified or corrupted.</entry>
										<entry> </entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> METHOD </entry>
										<entry>
											<para> Method used to store the file or object; either: </para>
											<itemizedlist>
												<listitem>
												<para>0—file or object is stored without
												compression </para>
												</listitem>
												<listitem>
												<para>8—file or object is stored and compressed in
												a zip archive </para>
												</listitem>
											</itemizedlist>
										</entry>
										<entry> </entry>
										<entry> X</entry>
									</row>
									<row>
										<entry> ZIPFILENAME </entry>
										<entry> Full path to the zip archive that contains the file
											or directory. When using relative paths, the path
											includes the working directory.</entry>
										<entry> </entry>
										<entry> X</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								$lfileproperties and $fileproperties</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
									<row>
										<entry> -1110</entry>
										<entry> &lt;UPROCERR_TOPIC&gt;</entry>
										<entry> Topic name not known. </entry>
									</row>
									<row>
										<entry> -1132</entry>
										<entry> &lt;UPROCERR_UNRESOLVED_TOPIC&gt;</entry>
										<entry> Topic could not be resolved. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $lfileproperties function returns an associative list of the
						properties of the specified file or directory, ignoring any file
						redirections in the assignment file. The file or directory can be located in
						a zip archive. </para>
				</sect2>
				<sect2>
					<title>Specifying File and Directory Paths</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>OpenVMS</title>
					<para>When querying creation times of files, each change made to the content of
						a file causes a new version of that file to be created, with a new creation
						date. The creation date and modification date of the new file version are
						the same. This differs from other systems, where a modification to the file
						content does not change the creation date. </para>
					<para>OpenVMS 7.2 and earlier versions do not have the concept of access date,
						but actually return the modification date. OpenVMS 7.3 and higher do know of
						it, but do not consistently set it, as is proven by 'dir/full file.txt'. The
						output for Accessed: is always &lt;None specified&gt;, no matter how many
						times you edit, type, change properties, or otherwise attempt to modify this
						file. Therefore the ACCESSDATE property is not supported on VMS and returns
						-13 when specified. </para>
					<para>On OpenVMS 7.2., $lfileproperties does not work for [000000] root
						directories. On OpenVMS 7.3. and higher, it works partially—the
						FILEATTRIBUTES option does not work for [000000].</para>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On the z/OS, if a file on the HFS system is specified, the standard
						properties are returned. </para>
					<para>However, on the dataset system, some standard properties are not returned
						and dataset-specific properties are returned. </para>
					<table>
						<title>Table 3. Properties Returned on z/OS</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Property</entry>
									<entry> HFS</entry>
									<entry> Datasets</entry>
									<entry> PDS members* </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> ACCESSDATE</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> CREATIONDATE</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> FILEATTRIBUTES</entry>
									<entry> X Same as Unix</entry>
									<entry> X "RWX" for read/write/execute </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FILESIZE</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FILETYPE</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> FULLPATH </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> MODIFICATIONDATE </entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> BLKSIZE</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DATACLAS</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DDNAME </entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DSNTYPE</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> DSORG </entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> LRECL</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> MGMTCLAS</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> RECFM</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> STORCLAS</entry>
									<entry> </entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>* only for PDS members with ISPF statistic information </para>
				</sect2>
				<sect2>
					<title>Example: Checking if a File Exists</title>
					<para> The following example checks whether the file <emphasis role="bold"
							>test.txt</emphasis> exists in the directory <emphasis role="bold"
							>sub1dir</emphasis> and, if so, loads
						it:<programlisting role="uniface"><![CDATA[$file$ = "sub1dir\test.txt"
; or $file$ = "sub1dir/test.txt"
; or $file$ = "[.sub1dir]test.txt"
; or $file$ = "[.sub1dir]test.txt;5" ; (VMS specific)
if ($lfileproperties($file$,"Filetype") = "FILETYPE=FILE") 
lfileload $file$, $content$
endif
]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Example: Extracting a File's Modification Date and Time</title>
					<para>This example extracts the modifcation date and time of the file <emphasis
							role="bold">grid1.xml</emphasis> residing in <emphasis role="bold"
							>grid1.zip</emphasis> file of the <emphasis role="bold"
							>\samples</emphasis> directory, assuming the current working directory
						is <emphasis role="bold">d:\usys\project</emphasis>, and assuming the return
						value of the function is:</para>
					<programlisting role="uniface"><![CDATA[FILETYPE=FILE·;MODIFICATIONDATE=2006061414351600·;COMPRESSEDSIZE=24344·;FILESIZE=272113·;
CHECKSUM=351677385·;FULLPATH=GRID1.XML·;METHOD=8·;FILEATTRIBUTES=T·;ZIPFILENAME=..\samples\grid1.zip
]]></programlisting>
					<programlisting role="uniface"><![CDATA[FIELD1.MYENTITY = $lfileproperties("..\samples\grid1.zip:grid1.xml")
; Extract the modification date:
getitem/id $1,FIELD1.MYENTITY,"MODIFICATIONDATE"
$2 = $date($1) ; gives $2 = "20060614"
; Extract the modification time:
$3 = $clock($1) ; gives $3 = "0000000014351600"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_lines">
				<title>$lines</title>
				<para>Return the number of lines remaining on the current page. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$lines</command>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $lines </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Uniface is not printing ($printing = 0); $status is
											set to an empty string ("") </entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Number of lines remaining on the page, <emphasis
												role="italic">excluding </emphasis>the header and
											trailer frames. Uniface is printing ($printing =
											1)</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use $lines to test whether there is enough space left to print your break
						frame, or to start printing a new occurrence on the current page. </para>
					<para>$lines is based upon how many lines of font 0 will fit on the page. If
						widget fonts specify different fonts or fonts size, the number of lines may
						be greater or less than this. If the number of lines is not a whole number,
						it is rounded downwards. For example 2.8 becomes 2. Thus, if $lines=2 there
						are between 2 and 3 lines of font 0 available. There is no function that can
						tell how many lines of a specified widget font will fit on a page. </para>
					<para>To print column headers on a new page, or text at the bottom of a page use
						headers and trailers surrounded by area frames with the Printing property
						set to Suppress when empty. This is easier then trying to do this with
						$lines.</para>
				</sect2>
				<sect2>
					<title>Example: Ejecting a Page</title>
					<para> </para>
					<para>The following example shows how to use $lines to trigger an eject if there
						is not enough room left to print information: </para>
					<programlisting role="uniface"><![CDATA[; trigger : Leave Printed Occurrence
; entity : INVOICE
; compare date of next occurrence
compare (DATE) from "INVOICE"
; if next date different
if ($result = 0)
   ; if less than 5 lines left, start printing on new page
   if ($lines &lt; 5)
      eject
   endif
   
	; set date in Break Frame
	DATE.DAYTOT = DATE.INVOICE
   ; print break frame for day total
   printbreak "DAYTOT"
   ; reset to zero for new day
   AMOUNT.DAYTOT = 0
   ; if less than 10 lines left, eject after printing break frame
   if ($lines &lt; 10)
      eject
   endif
endif
return(0)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_log">
				<title>$log</title>
				<para> Introduced in: U8 </para>
				<para>Return the natural logarithm of <parameter>X</parameter> (log e X). </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$log</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><parameter>X</parameter>—positive numeric constant, or a field (or
						indirect reference to a field), variable, function, or expression that
						evaluates to a positive numeric value. <parameter>X</parameter> must be in
						the range 0 through 10 to the power of 9999</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Natural logarithm of X </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following $log and
							$log10.</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1204 </entry>
									<entry> &lt;UPROCERR_NEGATIVE&gt; </entry>
									<entry> Negative value not allowed. </entry>
								</row>
								<row>
									<entry> -1205 </entry>
									<entry> &lt;UPROCERR_ZERO&gt; </entry>
									<entry> Zero value not allowed. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $log function returns the natural logarithm of
							<parameter>X</parameter> (that is, log e <parameter>X</parameter>).
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the natural logarithm of the given
						expression: </para>
					<programlisting role="uniface"><![CDATA[$NATLOG$ = $log(MYFIELD * 2)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_log10">
				<title>$log10</title>
				<para> Introduced in: U8 </para>
				<para> Return the base 10 logarithm of X (log10X).</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$log10</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<parameter>X</parameter>— positive numeric constant, or a field (or indirect
						reference to a field), variable, function, or expression that evaluates to a
						positive numeric value. X must be in the range 0 through 10 to the power of 9999</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Base 10 logarithm of X </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following $log and
							$log10.</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1204 </entry>
									<entry> &lt;UPROCERR_NEGATIVE&gt; </entry>
									<entry> Negative value not allowed. </entry>
								</row>
								<row>
									<entry> -1205 </entry>
									<entry> &lt;UPROCERR_ZERO&gt; </entry>
									<entry> Zero value not allowed. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The function $log10 returns the base 10 logarithm of X, that is, log10 X.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the base 10 logarithm of the given
						expression: </para>
					<programlisting role="uniface"><![CDATA[$NOTNATLOG$ = $log10(MYFIELD * 2)]]></programlisting>
					<para> If the value of MYFIELD is 50, the value stored in $NOTNATLOG$ is 2.
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_logical">
				<title>$logical</title>
				<para>Return a logical value defined in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$logical</command> ( <parameter>LogicalName</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>LogicalName—name of a logical symbol defined in the [LOGICALS] section of
						the assignment file; can be a string, or a field (or indirect reference to a
						field), a variable, or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Value associated with the logical symbol name. </para>
							</listitem>
							<listitem>
								<para>empty string (""), if LogicalName is not found. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>You can use logicals to allow you to spawn platform-specific commands.
						Consider the following section in an assignment file: </para>
					<programlisting role="uniface"><![CDATA[
[LOGICALS]
work_directory = c:\my_app\test\work
]]></programlisting>
					<para>This logical symbol can be used in Proc to refer to the appropriate
						directory: </para>
					<programlisting role="uniface"><![CDATA[
WorkDir = $logical("work_directory")
SubDir = "%%$logical("work_directory")%%%\axel"
]]></programlisting>
					<para> The results of these statements are: </para>
					<itemizedlist>
						<listitem>
							<para>WorkDir contains c:\my_app\test\work </para>
						</listitem>
						<listitem>
							<para>SubDir contains c:\my_app\test\work\axel </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Enabling the Debugger in a Deployed Application</title>
					<para>To enable the debugger to be started in a deployed application:</para>
					<orderedlist>
						<listitem>
							<para>Add the following Proc code to the Switch Keyboard trigger of the
								application shell:
								<programlisting role="uniface"><![CDATA[; Switch keyboard trigger
if ($logical("SwitchKeyboard") = "debug")
    debug
endif
]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>If debugging is required for some reason in the deployed
								application, add SwitchKeyboard=debug to the [LOGICALS] section of
								the assignment file, and activate the trigger by pressing GOLD Y.
							</para>
						</listitem>
					</orderedlist>
					<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_lowercase">
				<title>$lowercase</title>
				<para> Introduced in: U8 </para>
				<para>Convert a string to lowercase.</para>
				<sect2>
					<title>Syntax</title>
					<para> $lowercase ( String {, "NlsLocale" | "classic" } ) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>String—string to convert to lowercase; can be a string, field
									(or indirect reference to a field), variable, or function that
									evaluates to a string. </para>
							</listitem>
							<listitem>
								<para>NlsLocale—apply locale-based rules based on the value of the
									$nlslocale, as specified by $nlslocale or $NLS_LOCALE. </para>
							</listitem>
							<listitem>
								<para>classic—ignore locale when converting data; apply one-to-one
									character conversion according to Unicode definitions. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para> ... String converted to lowercase. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The way in which strings are converted depends on the NLS settings in
						effect. If the second argument is omitted, the value of $nlscase is used to
						determine case conversion behavior. For more information, see Case
						Conversion.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>For example, the following Proc converts the Turkish word KIPIRTI to
						lowercase as kipirti. </para>
					<programlisting role="uniface"><![CDATA[FIELD1 = $lowercase ("KIPIRTI", "classic")
;Result: FIELD1 = kipirti]]></programlisting>
					<para>However, Turkish has both a dotted i and an undotted ı, so this case
						conversion is incorrect. To get the correct conversion, you need to set the
						locale to Turkish, so that locale-based case conversion is applied.</para>
					<programlisting role="uniface"><![CDATA[$nlslocale = "tr_TR" ; set locale to Turkish(Turkey)
FIELD2 = $lowercase ("KIPIRTI")
Result: FIELD2 = kıpırtı]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_ltrim">
				<title>$ltrim</title>
				<para> Introduced in: U8 </para>
				<para>Left trim a string following a pattern. </para>
				<sect2>
					<title>Syntax</title>
					<para> $ltrim ( Source , Pattern ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Source—string to be left trimmed. </para>
							</listitem>
							<listitem>
								<para>Pattern—pattern to remove. It can be a constant string or a
									Syntax Strings for Pattern Matching. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Trimmed string. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $ltrim function is used to left trim a string following a pattern.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$1="xxxxUNIFACE"
$2 = $ltrim($1,"x")
; $2 now contains "UNIFACE"
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_modelname">
				<title>$modelname</title>
				<para> Introduced in: U8 </para>
				<para>Return the name of the current model</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$modelname</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...<itemizedlist>
							<listitem>
								<para>Name of the current model (in uppercase). </para>
							</listitem>
							<listitem>
								<para>empty string (""), if there is no current entity (that is, if
									the last node of the active path is not a field or entity).
								</para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in form, service, session service, entity service, and report
						components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
					<para>The $modelname function is useful when you are writing global Procs,
						because it allows you to generalize your code. It is also useful to examine
						this function when you are using the Proc debugger to step through Proc
						statements. You can use $modelname from everywhere within the
						component.</para>
				</sect2>
				<sect2>
					<title>Example: Returning the Fully Qualified Name of the Current Field</title>
					<para>The following Proc example returns the full qualified name of the current
						field:</para>
					<programlisting role="uniface"><![CDATA[entry FullQualifiedFieldName
returns string
return "%%$fieldname%%%.%%$entname%%%.%%$modelname%%%"
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_msgdata">
				<title>$msgdata</title>
				<para>Return the message data. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$msgdata</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Data that was sent with a postmessage statement. The returned value has
						the same data type as the data that was sent. </para>
					<para>In addition, $msgid returns a nonempty string. If the Asynchronous
						Interrupt trigger was not activated by postmessage, $msgid returns an empty
						string (""). </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in an Asynchronous Interrupt trigger of form components (and
						in service and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Message Handling</title>
					<para>The following example shows the Asynchronous Interrupt trigger for an
						application. The example assumes that an instance named ASYNC_HANDLER has
						already been created (probably in the Application Execute trigger as the
						application started). The instance ASYNC_HANDLER is an instance of a service
						that contains an operation to process each type of asynchronous interrupt
						that is expected in the application. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Asynchronous Interrupt of start-up shell
; this msg was sent by postmessage
; return a confirmation
; this is a regular async interrupt
if ( $result = "message" )
   putmess "%%$msgdst received from %%$msgsrc"
   putmess " message id =%%$msgid"
   putmess " message text=%%$msgdata"
   if ( $msgid != "Ack")
      postmessage $msgsrc, "Ack", "Acknowledging message %%$msgid"
   else
      if ( $msgid = "A" ) activate "ASYNC_HANDLER".A ($msgdata)
      if ( $msgid = "B" ) activate "ASYNC_HANDLER".B ($msgdata)
      ...
   endif
else
  if ( $result = "Close" ) activate "ASYNC_HANDLER".CLOSE
  if ( $result = "Timeout" ) activate "ASYNC_HANDLER".TIMEOUT
  else
     putmess "%%$instancename received unexpected async message: %%$result"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_msgdst">
				<title>$msgdst</title>
				<para>Return the name of the component instance to which a message was addressed. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$msgdst</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String containing thename of the form to which the message was addressed
						(the destination for the message) </para>
					<para>In addition, $msgid returns a nonempty string. If the Asynchronous
						Interrupt trigger was not activated by postmessage, $msgid returns an empty
						string (""). </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in an Asynchronous Interrupt trigger in form components (and
						in service and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Example: Message Handling</title>
					<para>The following example shows the Asynchronous Interrupt trigger for an
						application. The example assumes that an instance named ASYNC_HANDLER has
						already been created (probably in the Application Execute trigger as the
						application started). The instance ASYNC_HANDLER is an instance of a service
						that contains an operation to process each type of asynchronous interrupt
						that is expected in the application. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Asynchronous Interrupt of start-up shell
; this msg was sent by postmessage
; return a confirmation
; this is a regular async interrupt
if ( $result = "message" )
   putmess "%%$msgdst received from %%$msgsrc"
   putmess " message id =%%$msgid"
   putmess " message text=%%$msgdata"
   if ( $msgid != "Ack")
      postmessage $msgsrc, "Ack", "Acknowledging message %%$msgid"
   else
      if ( $msgid = "A" ) activate "ASYNC_HANDLER".A ($msgdata)
      if ( $msgid = "B" ) activate "ASYNC_HANDLER".B ($msgdata)
      ...
   endif
else
  if ( $result = "Close" ) activate "ASYNC_HANDLER".CLOSE
  if ( $result = "Timeout" ) activate "ASYNC_HANDLER".TIMEOUT
  else
     putmess "%%$instancename received unexpected async message: %%$result"
endif
]]></programlisting>
					<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_msgid">
				<title>$msgid</title>
				<para>Return the message identifier for the message. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$msgid</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $msgid</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> ""</entry>
										<entry> Empty string (""), if the asynchronous event was not
											sent by postmessage; $result indicates the source of the
											message. </entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Message identifier, if the Asynchronous Interrupt
											trigger was activated by a postmessage statement;
											$result is "message". </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Asynchronous Interrupt trigger of form components (and
						in service and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Message Handling</title>
					<para>The following example shows the Asynchronous Interrupt trigger for an
						application. The example assumes that an instance named ASYNC_HANDLER has
						already been created (probably in the Application Execute trigger as the
						application started). The instance ASYNC_HANDLER is an instance of a service
						that contains an operation to process each type of asynchronous interrupt
						that is expected in the application. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Asynchronous Interrupt of start-up shell
; this msg was sent by postmessage
; return a confirmation
; this is a regular async interrupt
if ( $result = "message" )
   putmess "%%$msgdst received from %%$msgsrc"
   putmess " message id =%%$msgid"
   putmess " message text=%%$msgdata"
   if ( $msgid != "Ack")
      postmessage $msgsrc, "Ack", "Acknowledging message %%$msgid"
   else
      if ( $msgid = "A" ) activate "ASYNC_HANDLER".A ($msgdata)
      if ( $msgid = "B" ) activate "ASYNC_HANDLER".B ($msgdata)
      ...
   endif
else
  if ( $result = "Close" ) activate "ASYNC_HANDLER".CLOSE
  if ( $result = "Timeout" ) activate "ASYNC_HANDLER".TIMEOUT
  else
     putmess "%%$instancename received unexpected async message: %%$result"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_msginfo">
				<title>$msginfo</title>
				<para>Return the requested information about the latest message. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$msginfo</command> ( <parameter>Topic</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Topic—valid topic name; can be a string, or a field (or indirect reference
						to a field), a variable, or a function that evaluates to a string. The topic
						name is not case-sensitive; you can use uppercase or lowercase letters, or
						any combination of these to increase readability. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $msginfo per topic</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Topic</entry>
										<entry> Return value</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> DATA </entry>
										<entry> The message data associated with the message. (See
											-$msgdata- for more information. </entry>
									</row>
									<row>
										<entry> DST </entry>
										<entry> Intended destination for message. (See -$msgdst- for
											more information. </entry>
									</row>
									<row>
										<entry> ID </entry>
										<entry> The message ID associated with the message. (See
											-$msgid- for more information. </entry>
									</row>
									<row>
										<entry> INSTANCENAME </entry>
										<entry> The name of the instance that sent the message. (See
											-$instancename- for more information. </entry>
									</row>
									<row>
										<entry> INSTANCEPATH </entry>
										<entry> The path of the instance that sent the message. (See
											-$instancepath- for more information. </entry>
									</row>
									<row>
										<entry> SRC </entry>
										<entry> Sender of message. (See -$msgsrc- for more
											information. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Asynchronous Interrupt trigger in form, service, and
						report components, . </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The information returned in $msginfo is available using the individual
						functions $instancename, $instancepath, $msgdata, $msgdst, $msgid, and
						$msgsrc. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following code could appear in the Asynchronous Interrupt trigger of a
						component: </para>
					<programlisting role="uniface"><![CDATA[postmessage $msginfo("SRC"),"MSG001", %\
"Reply to sender: message received."
]]></programlisting>
					<para>To handle messages that are incorrectly addressed, the following code
						could appear in the Asynchronous Interrupt trigger of the application: </para>
					<programlisting role="uniface"><![CDATA[postmessage $msginfo("SRC"), "MSG001", %\
"Reply to sender: instance addressed is unknown"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_msgsrc">
				<title>$msgsrc</title>
				<para>Return the name of the component instance that sent the message. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$msgsrc</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String identifying the component instance that sent the message, if the
						Asynchronous Interrupt trigger was activated by a postmessage statement. The
						string contains all the path information necessary to reply to the message. </para>
					<para>In addition, $msgid returns a nonempty string. If the Asynchronous
						Interrupt trigger was not activated by postmessage, $msgid returns an empty
						string (""). </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in an Asynchronous Interrupt trigger of form, service, and
						report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following code could appear in the Asynchronous Interrupt trigger of a
						component: </para>
					<programlisting role="uniface"><![CDATA[postmessage $msgsrc, "MSG001", "Reply to sender: message received."]]></programlisting>
					<para>To handle messages that are incorrectly addressed, the following code
						could appear in the Asynchronous Interrupt trigger of the application. </para>
					<programlisting role="uniface"><![CDATA[postmessage $msgsrc, "MSG001", "Reply to sender: instance addressed is unknown"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_next">
				<title>$next</title>
				<para>Return the value of the next occurrence of a field. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$next</command> ( <parameter>Field</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Field—field name; can be a literal name, a string, or a field (or indirect
						reference to a field), a variable, or a function that evaluates to a string.
						It can optionally contain a qualified field name, for example MYFLD.MYENT.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Value of Field in the next occurrence. </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if there is no next occurrence. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $next function enables you to refer to the contents of a field in the
						next occurrence. You can use it to: </para>
					<itemizedlist>
						<listitem>
							<para>Copy contents of a field to another field or variable. </para>
						</listitem>
						<listitem>
							<para>Perform calculations. </para>
						</listitem>
						<listitem>
							<para>Make Boolean comparisons. </para>
						</listitem>
					</itemizedlist>
					<para>However, $next is not always the most efficient way of referring to a
						field in the next occurrence. This is particularly true when the referenced
						field is part of an occurrence that has already been active. </para>
					<para>In this case, it is often preferable to store the contents of that field
						in a variable before moving to the next occurrence, <emphasis role="italic"
							>then </emphasis>refer to the variable. This usually costs less
						processing power. Use the Occurrence Gets Focus trigger to do this. Or, if
						you are printing, you could also use the Leave Printed Occurrence trigger.
					</para>
				</sect2>
				<sect2>
					<title>Example: Setting a Page Break </title>
					<para>The following example shows the use of the $next function to trigger a
						page break in a report: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Printed Occurrence
; entity : INVOICE
; if next date different
; print totals for date
; force page break
if (PAYDATE != $next(PAYDATE))
   printbreak "DAYTOTAL"
   eject
endif]]></programlisting>
					<para>In this example, the DAYTOTAL break frame is printed and a page break
						forced after the last occurrence has been printed; if you want something
						else to happen after printing the last occurrence, you need to be able to
						test whether the next occurrence exists. Use the compare statement for this. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The compare statement is usually
						faster. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlscase">
				<title>$nlscase</title>
				<para> Introduced in: U9 </para>
				<para>Return the current value of the NLS case setting, or set it to a new value to
					apply or ignore locale-based case conversion rules.</para>
				<sect2>
					<title>Syntax</title>
					<para>$nlscase = "nlslocale" | "classic" </para>
					<para>Result = $nlscase </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>nlslocale—apply case conversion rules for the current locale
									(if not set to classic) when using case conversion Proc commands
									such as $uppercase and $lowercase </para>
							</listitem>
							<listitem>
								<para>classic—ignore locale-based case conversion rules when using
									case conversion Proc commands such as $uppercase and $lowercase.
									Convert characters on a character-by-character basis according
									to the Unicode definitions. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the current setting.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When setting $nlscase, you can specify a string, field, or variable that
						evaluates to a string.</para>
					<para>Setting $nlscase overrides the value set by $NLS_CASE, if specified. The
						value of $nlscase itself can be overridden by specifying a locale qualifier
						in $uppercase or $lowercase.</para>
					<para>The following Proc instructions are available for converting between
						uppercase and lowercase:</para>
					<itemizedlist>
						<listitem>
							<para>lowercase </para>
						</listitem>
						<listitem>
							<para>uppercase </para>
						</listitem>
						<listitem>
							<para>$lowercase </para>
						</listitem>
						<listitem>
							<para>$uppercase </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>For example, if $NLS_LOCALE is set to en_US, the following code will turn
						off locale-based conversion.</para>
					<programlisting role="uniface"><![CDATA[$nlscase = "classic"
FIELD1 = $uppercase (" Groß-Gerau")
;Result: FIELD1 =  GROß-GERAU]]></programlisting>
					<para>The ß character, which would have been converted to SS if locale-based
						rules were applied, is not converted.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlsformat">
				<title>$nlsformat</title>
				<para> Introduced in: U9 </para>
				<para>Set or return the current NLS format value, which determines how
					locale-sensitive data is displayed.</para>
				<sect2>
					<title>Syntax</title>
					<para>$nlsformat = "nlslocale" | "classic" </para>
					<para>Result = $nlsformat </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>nlslocale—display data of type Number, Float, Date, Time, and
									Datetime according to the current locale, if $nlslocale is not
									set to classic </para>
							</listitem>
							<listitem>
								<para>classic—ignore the locale when displaying locale-sensitive
									data </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the current setting.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When setting $nlsformat, you can specify a string, field, or variable that
						evaluates to a string. Setting $nlsformat overrides the value of the
						$NLS_FORMAT assignment setting, if specified.</para>
					<para>When $nlsformat is set to nlslocale: </para>
					<itemizedlist>
						<listitem>
							<para>All display formats for Number, Float, Date, Time, and Datetime
								data are treated as if an $NLS format has been applied. </para>
							<para>Thus, the display format DIS(zzzP99) becomes DIS($NLS(zzzP99)). In
								this case, the P representing a decimal point is displayed as a
								comma if $nlslocale is de_DE, meaning German(Germany), or as a
								period if the locale is English (United States). </para>
						</listitem>
						<listitem>
							<para>The return values of the Proc functions $number, $float, $date,
								$clock, and $datim, which parse a string to covert it to the
								respective data type, are displayed in accordance with the locale. </para>
							<para>Thus, if the value of $datim is 2009122316094200, it is displayed
								as Dec 23, 2009 4:09:42 PM if the locale is English (United States),
								and as 23 Dec 2009 16:09:42 if the locale is English (United
								Kingdom). </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Effect of Locale on Displayed Date</title>
					<para>In the following example, when the user selects a locale in the LOCALES
						field, the Value Changed trigger assigns this value to the $nlslocale and
						updates the value of the CURRENTDATE field. </para>
					<programlisting role="uniface"><![CDATA[;Value Changed trigger of LOCALES
$nlslocale = LOCALES
CURRENTDATE = $datim]]></programlisting>
					<para>With the display format (Field Layout) of CURRENTDATE set to
						DIS($NLS(FULL, DATE)), the following table shows how the date is displayed
						for some example locales:</para>
					<table>
						<title>Table 1. Effect of Locale on Displayed Dates</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Locale Code</entry>
									<entry> Locale</entry>
									<entry> Displayed Data</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> en_US </entry>
									<entry> English (United States)</entry>
									<entry> Wednesday, December 2, 2009 </entry>
								</row>
								<row>
									<entry> en_GB</entry>
									<entry> English (United Kingdom)</entry>
									<entry> Wednesday, 2 December 2009</entry>
								</row>
								<row>
									<entry> fr_CA</entry>
									<entry> French (Canada)</entry>
									<entry> mercredi 2 décembre 2009</entry>
								</row>
								<row>
									<entry> nl_NL</entry>
									<entry> Dutch (Netherlands)</entry>
									<entry> woensdag 2 december 2009</entry>
								</row>
								<row>
									<entry> ja_JP</entry>
									<entry> Japanese (Japan)</entry>
									<entry> 2009年12月2日水曜日</entry>
								</row>
								<row>
									<entry> bg_BU</entry>
									<entry> Bulgarian (Bulgaria)</entry>
									<entry> 02 декември 2009, сряда</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlsinternaltime">
				<title>$nlsinternaltime</title>
				<para> Introduced in: U9 </para>
				<para>Specify whether to use Coordinated Universal Time (UTC+00:00) as the internal
					time zone.</para>
				<sect2>
					<title>Syntax</title>
					<para>$nlsinternaltime = "UTC" | "classic" </para>
					<para>Result = $nlstimezone </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>UTC—sets the internal time zone to UTC+00:00, and adjusts to
									the external or local value when displaying or parsing date and
									time data in fields. </para>
							</listitem>
							<listitem>
								<para>classic—use the local time zone; do not apply any internal to
									external time zone correction. This is the default. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the current setting.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When setting $nlsinternaltime, you can specify a string, field, or
						variable that evaluates to a string. Setting $nlstimezone overrides the
						value set by $NLS_INTERNAL_TIME in the assignment file (if defined). </para>
					<para>Setting the value to UTC sets the internal time zone to Coordinated
						Universal time at Greenwich (UTC+00:00). This has the following
						consequences:</para>
					<itemizedlist>
						<listitem>
							<para>Proc functions $clock, $date, and $datim return the internal time
							</para>
						</listitem>
						<listitem>
							<para>The internal date and time is stored and retrieved from the
								database </para>
						</listitem>
						<listitem>
							<para>The internal time is used when exchanging data </para>
						</listitem>
					</itemizedlist>
					<para>However, the internal time zone is always corrected to the external time
						zone when displaying data. </para>
					<para>Setting the value to classic explicitly instructs Uniface to use its
						default behavior, which is to use the local time as defined on the executing
						system. The date and time are not corrected to the external time. </para>
					<para>For applications that store date or time data, it makes sense to use
						UTC+00:00 as the internal time zone, so that all data conforms to a standard
						time. For example, if you place an order at 9:00 AM in Detroit, the date is
						corrected to the UTC time of UTC-05:00, in other words 14:00 (2:00 PM)
						Greenwich Mean Time. Corrections for Daylight Savings Time are also applied.
						When retrieving data from the database, the UTC time is corrected to display
						the time according to the external time zone. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> Any data that exists in the
						database prior to setting the internal time is assumed to be stored at
						GMT+00:00, so it will also be corrected to the external or local time when
						displayed. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc code checks the current value of internal time, and if
						it is not UTC, it temporarily sets the internal time to UTC before
						performing a store, and then sets it to back to previous value.</para>
					<programlisting role="uniface"><![CDATA[$INTERNALTIME$ = $nlsinternaltime
if ($INTERNALTIME$ != "UTC")
  $nlsinternaltime = "UTC"
endif
store
$nlsinternaltime = $INTERNALTIME$]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlslocale">
				<title>$nlslocale</title>
				<para> Introduced in: U9 </para>
				<para>Set or return the current locale (language and country), or locale setting. </para>
				<sect2>
					<title>Syntax</title>
					<para>$nlslocale = "classic" | "system" | ln_CY </para>
					<para>result = $nlslocale </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>classic—Uniface behavior prior to Uniface 9.4; no locale-based
									sorting or formating is performed. This is the default. </para>
							</listitem>
							<listitem>
								<para>system—sorting and formatting behavior is based on the locale
									defined for the local (client) system; Windows only </para>
							</listitem>
							<listitem>
								<para>ln_CY—locale identifier, in which ln specifies the two-letter
									language code and CY the two-letter country code as defined by
									ISO 639; for example, fr_CA for French (Canada) </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the current locale or setting.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When setting the $nlslocale, you can specify the value as a string, field
						(or indirect reference to a field), variable, or function that evaluates to
						a string. </para>
					<para>The value of $nlslocale overrides the value of the $NLS_LOCALE assignment
						setting. If the NLS locale is set to system or a specific locale,
						locale-based processing rules are applied, unless they are overridden by one
						of these other assigment settings, or in Proc. If it is set to classic,
						Uniface does not apply locale-based processing unless the locale is set in
						Proc using $nlslocale. </para>
					<para>The default value of the$NLS_CASE, $NLS_FORMAT, and $NLS_SORT_ORDER
						assignment settings is nlsformat. This means that they use the value set by
						$NLS_LOCALE to control their specific area of functionality. Thus, setting
						$nlslocale affects the default way in which data is displayed, sorted, and
						transformed with case conversion. For more information, see Language and
						Locale.</para>
					<para>You can use $nlslocalelist to get the system locale or a list of
						locales.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, when the user selects a locale in the LOCALES
						field, the Value Changed trigger assigns this value to the $nlslocale and
						updates the value of the CURRENTDATE field. </para>
					<programlisting role="uniface"><![CDATA[;Value Changed trigger of LOCALES
$nlslocale = LOCALES
CURRENTDATE = $datim]]></programlisting>
					<para>With the display format (Field Layout) of CURRENTDATE set to
						DIS($NLS(FULL, DATE)), the following table shows how the date is displayed
						for some example locales:</para>
					<table>
						<title>Table 1. Effect of Locale on Displayed Dates</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Locale Code</entry>
									<entry> Locale</entry>
									<entry> Displayed Data</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> en_US </entry>
									<entry> English (United States)</entry>
									<entry> Wednesday, December 2, 2009 </entry>
								</row>
								<row>
									<entry> en_GB</entry>
									<entry> English (United Kingdom)</entry>
									<entry> Wednesday, 2 December 2009</entry>
								</row>
								<row>
									<entry> fr_CA</entry>
									<entry> French (Canada)</entry>
									<entry> mercredi 2 décembre 2009</entry>
								</row>
								<row>
									<entry> nl_NL</entry>
									<entry> Dutch (Netherlands)</entry>
									<entry> woensdag 2 december 2009</entry>
								</row>
								<row>
									<entry> ja_JP</entry>
									<entry> Japanese (Japan)</entry>
									<entry> 2009年12月2日水曜日</entry>
								</row>
								<row>
									<entry> bg_BU</entry>
									<entry> Bulgarian (Bulgaria)</entry>
									<entry> 02 декември 2009, сряда</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example: Setting Locale with Local Browser Setting</title>
					<para>When a request is sent to a Uniface Web application from the client
						browser, the locale of the browser is included in the HTTP headers. This can
						be useful, for example, if you want to return information in the local
						language or currency. Use the following Proc construction to extract the
						browser locale from the request header and use it to set $nlslocale:</para>
					<programlisting role="uniface"><![CDATA[$nlslocate = $item("accept-language", $webinfo("httpRequestHeaders"))]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlslocalelist">
				<title>$nlslocalelist</title>
				<para> Introduced in: U9 </para>
				<para>Return a list of valid locales or the system locale.</para>
				<sect2>
					<title>Syntax</title>
					<para>Result = $NlsLocaleList{("system")} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>system—return the locale as specified on the operating system
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns an associative list of available locales, or the system
						locale</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>All components</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>You can use the $nlslocalelist to check the system locale or populate a
						widget's ValRep list, enabling the user to select the locale.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$valrep (LOCALELIST) = $nlslocalelist]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nls_sort_order">
				<title>$nls_sort_order [DEPRECATED]</title>
				<para>This function is deprecated. Please use $nlssortorder instead.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlssortorder">
				<title>$nlssortorder</title>
				<para> Introduced in: U9 </para>
				<para>Set or return the current sequencing rules to apply when sorting entities and
					lists, or reading occurrences from the hitlist.</para>
				<sect2>
					<title>Syntax</title>
					<para>$nlssortorder = nlslocale | classic | binary </para>
					<para>Result = $nlssortorder </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<table>
							<title>Parameters</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Parameter</entry>
										<entry> Description </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> NLSLOCALE </entry>
										<entry> Applies locale-based sorting if $nlslocale is not
											set to classic. </entry>
									</row>
									<row>
										<entry> CLASSIC </entry>
										<entry> No locale-based sorting rules are applied.</entry>
									</row>
									<row>
										<entry> BINARY </entry>
										<entry> Binary ordering </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The function $nlssortorder returns a string indicating the sorting order
						currently in use. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and server page components, and in service and report
						components that are not self-contained. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use the $nlssortorder function to check, set, or change the default way in
						which Uniface sequences data. The sort order determines how the sort and
						sort/list statements sequence data.</para>
					<para>$nlssortorder can also be used to establish a new sort order. If the
						sorting order has not been set in an assignment file (with the setting
						$NLS_SORT_ORDER), it defaults to BINARY. If you explicitly define a value
						for $nlssortorder, the assignment file setting for $NLS_SORT_ORDER is
						ignored. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example saves the current sorting order in general variable
						$1, and sets the current sorting order to BINARY: </para>
					<programlisting role="uniface"><![CDATA[; save current sort order
; set sort order to BINARY
; sort country codes as binary
; restore original sort order
$1 = $nls_sort_order
$nls_sort_order = "BINARY"
sort/e "COUNTRY_CODES", "CODE.COUNTRY:a"
$nls_sort_order = $1]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlstimezone">
				<title>$nlstimezone</title>
				<para> Introduced in: U9 </para>
				<para>Return the current external time zone setting, or set it to a new
					value.</para>
				<sect2>
					<title>Syntax</title>
					<para>$nlstimezone = TimeZone | "classic" | "system" </para>
					<para>Result = $nlstimezone </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>TimeZone—name of the time zone as defined in the International
									Components for Unicode. For example, America/Detroit or EST.
								</para>
							</listitem>
							<listitem>
								<para>classic—no time zone is specified. All date and time data is
									treated as being at the local time as specified on the executing
									system, and no time zone-based corrections are applied. Default.
								</para>
							</listitem>
							<listitem>
								<para>system—use the time zone as set on the local system; Windows
									only. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the current setting.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When setting $nlstimezone, you can specify a string, field, or variable
						that evaluates to a string. Setting $nlstimezone overrides the value set by
						$NLS_TIME_ZONE in the assignment file (if defined). </para>
					<para>Setting the value of $nlstimezone and/or $nlsinternaltime influences the
						date and time of values that are:</para>
					<itemizedlist>
						<listitem>
							<para>Returned by the Proc functions $clock, $date, and $datim </para>
						</listitem>
						<listitem>
							<para>Displayed in fields with data types date, time, or combined date
								and time </para>
						</listitem>
						<listitem>
							<para>Stored and retrieved in the database </para>
						</listitem>
						<listitem>
							<para>Exchanged when using XML, call-in, or call-out </para>
						</listitem>
					</itemizedlist>
					<para>If $nlstimezone is set to classic, no time zone-related processing
						occurrs. It is assumed that all times are the local time. This is Uniface
						default behavior.</para>
					<para>If $nlstimezone is set to a specific time zone or to system, time zone
						corrections can be applied, such as daylight savings time are applied. </para>
					<para>You can use the $nlstimezonelist function to get the list of valid time
						zones, or the time zones available on the system.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[;Value Changed trigger of TIMEZONELIST
$nlstimezone = TIMEZONELIST
CURRENTDATETIME = $datim]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nlstimezonelist">
				<title>$nlstimezonelist</title>
				<para> Introduced in: U9 </para>
				<para>Returns a list of time zones.</para>
				<sect2>
					<title>Syntax</title>
					<para>Result = $nlstimezonelist{("system")} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>system—return the system time zone </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns an associative list of value-representation pairs for valid time
						zones.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>All components</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>You can use the $nlstimezonelist to populate a widget's ValRep list,
						enabling the user to select the local time zone.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$valrep (TIMEZONES) = $nlstimezonelist]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_nmforms">
				<title>$nmforms</title>
				<para>Return a list of all non-modal form instances in the component pool. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$nmforms</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>String containing a list of form instance names. (This list
									can be manipulated with Proc statements such as getitem,
									getlistitems, and so on.) </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if no non-modal forms have been started.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example could be used to fill the field LISTBOX with the
						list of non-modal forms that are currently active: </para>
					<programlisting role="uniface"><![CDATA[$valrep(LISTBOX) = $nmforms ]]></programlisting>
					<para>To allow the user to change focus to the desired form, the Detail trigger
						for LISTBOX contains the following code: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail for LISTBOX
if (LISTBOX != " ")
   setformfocus LISTBOX
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_number">
				<title>$number</title>
				<para>Return the value of the numeric part of a string. </para>
				<sect2>
					<title>Syntax</title>
					<para>$number ( String ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>String—a string, or a field (or indirect reference to a field), a
						variable, or a function that evaluates to a string. Only leading numeric
						text is converted. Leading white space (tabs or spaces) is ignored. If the
						number appears after alphabetic data, it is not converted. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Value of the leading numeric part it encounters in String.
								</para>
							</listitem>
							<listitem>
								<para>0, if String contains no numeric text, or if it starts with
									alphabetic text. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>You can use a combination of the scan statement and $number to extract
						numeric data that is preceded by alphabetic data. </para>
					<para>The $number function recognizes numbers in scientific notation. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the values returned by $number, when given
						different strings to evaluate: </para>
					<programlisting role="uniface"><![CDATA[; $1 = 0
$1 = $number("Amsterdam")
; $1 = 123
$1 = $number("123Amsterdam")
; $1 = 0
$1 = $number("Amsterdam123")
; $1 = 123
$1 = $number("123,456")]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Using scan and $number </title>
					<para>The following example shows how to use a combination of $number and scan
						to extract the numeric part of a string, regardless of the position of the
						numeric data in the string: </para>
					<programlisting role="uniface"><![CDATA[; find start of numeric data
; string ($1) contains numeric data
; save $result (start position of numeric data)
clrmess
$1 = "Amsterdam123jim"
scan $1,'#'
if ($result &gt; 0)
   $3 = $result
else
   message "%%$1 does not contain numeric data"
   return -1
endif
$2 = $number($1[$3])
putmess "numeric part of %%$1 is %%$2"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occcheck">
				<title>$occcheck</title>
				<para>Return or set the requirement for checking an occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para><command>$occcheck</command>{( Entity )} </para>
					<para><command>$occcheck</command>{( Entity )} = Expression </para>
					<para>set | reset $occcheck {( Entity )}</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. If omitted, the current entity is
									used. </para>
							</listitem>
							<listitem>
								<para>Expression—expression that evaluates to a numeric value,
									explicitly setting the value of $occcheck. When Expression
									evaluates to a nonzero value, $occcheck becomes 1. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $occcheck</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Occurrence checking is <emphasis role="italic">not
										</emphasis>enabled. </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> Occurrence checking is currently enabled.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>When $occcheck is used as the target of an assignment, $status is set: </para>
					<table>
						<title>Table 2. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "" </entry>
									<entry> Occurrence checking could not be enabled. This usually
										means that Entity is not present or does not exist. </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> Occurrence checking was successfully enabled. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$occcheck indicates whether the current occurrence of Entity is to be
						validated the next time that validation can occur. </para>
					<para>If $occcheck indicates that validation is demanded, validation is
						performed regardless of whether validation is actually required. (Validation
						is required when both $occmod and $occvalidation are 1, indicating that the
						occurrence has been modified, but has not yet been validated.) </para>
					<para>Validation can occur when:</para>
					<itemizedlist>
						<listitem>
							<para>The user leaves the occurrence (for example, with ^NEXT_OCC or a
								mouse click) </para>
							<para>An explicit validation statement is encountered (for example,
								validateocc) </para>
							<para>A store statement is encountered. </para>
						</listitem>
					</itemizedlist>
					<para>Validation includes syntax checks for each field in the entity, activation
						of the Validate Occurrence trigger, and, in forms only, activation of the
						Leave Modified Occurrence trigger. After validation completes, $occcheck is
						set to 0. </para>
					<para>You can also set the value of $occcheck as a Proc assignment. Set
						$occcheck to 1 to require checking for the specified entity; set it to 0 to
						let Uniface take responsibility for validation. For example: </para>
					<programlisting role="uniface"><![CDATA[$occcheck=!$occcheck ]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to use this function in the Occurrence
						Gets Focus trigger: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
set $occcheck(CUSTOMER)
This use of the function $occcheck causes the Leave Modified Occurrence trigger in the form to behave like a Leave Occurrence trigger.  ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occcrc">
				<title>$occcrc</title>
				<para> Introduced in: U8 </para>
				<para>Set or return the CRC checksum of an occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>$occcrc ( EntityName ) </para>
					<para>$occcrc ( EntityName ) = CheckSum </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>EntityName—entity name </para>
							</listitem>
							<listitem>
								<para>CheckSum—eight-character hexadecimal string </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>Eight-character hexadecimal string that represents the current
								values of an occurrence's fields. It is the CRC checksum as
								calculated by the database driver for database occurrences. </para>
						</listitem>
						<listitem>
							<para>An empty string for non-database occurrences </para>
						</listitem>
					</itemizedlist>
					<para>If $occcrc is not equal to an eight-character hexadecimal string,
						$procerror is set to the error constant &lt;UPROCERR_RANGE&gt;. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$occcrc returns an eight-character hexadecimal string that represents the
						current values of an occurrence's fields. If the occurrence's field values
						change, the CRC checksum calculation yields a different result. </para>
					<para>$occcrc can be set by $occcrc, and by xmlload (which sets $occcrc to equal
						the value of the crc attribute for the occurrence in the XML stream).
						Otherwise, it is set automatically when loading data from a database.
					</para>
				</sect2>
				<sect2>
					<title>XML streams</title>
					<para>CRC checksum values are required for disconnected record sets, and are
						produced automatically by Uniface when loading data from a database, or when
						creating or loading data from XML streams. They are used by
						retrieve/reconnect to determine if an occurrence can be updated by an XML
						stream. </para>
					<para>If the crc processing information attribute is specified in the DTD used
						by the XML stream, CRC checksums are stored in crc. retrieve/reconnect does
						not update an occurrence with data from an XML stream unless the CRC value
						in the stream matches the value of $occcrc for the occurrence. </para>
				</sect2>
				<sect2>
					<title>Disabling CRC Checks During retrieve/reconnect</title>
					<para>If you set the value of $occcrc for an occurrence to "00000000" then
						retrieve/reconnect does not carry out a CRC check before merging data from
						the XML stream into the occurrence. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occdbmod">
				<title>$occdbmod</title>
				<para>Return the modification status of a database occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para> $occdbmod{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $occdbmod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> Entity does not exist or is not painted on the
											component. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry>
											<para> In the following cases: </para>
											<itemizedlist>
												<listitem>
												<para>No modifications have been made to database
												fields in the occurrence. </para>
												</listitem>
												<listitem>
												<para>No entities are painted on the component.
												</para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry>
											<para> In the following cases: </para>
											<itemizedlist>
												<listitem>
												<para>A field in the occurrence that is defined as
												being a database field has been modified. </para>
												</listitem>
												<listitem>
												<para>The current occurrence is a database
												occurrence that has been removed. </para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$occdbmod is an occurrence-level function that tests whether any database
						field in the current occurrence has been modified. Non-database model fields
						and dummy fields do not affect $occdbmod. </para>
					<para>Events that cause a field to modified include: </para>
					<itemizedlist>
						<listitem>
							<para>The user entering a retrieve profile in an empty field. (This
								means that $occdbmod can be set to 1 before a retrieve has been
								performed.) </para>
						</listitem>
						<listitem>
							<para>The user changing the value of data that has been retrieved.
							</para>
						</listitem>
						<listitem>
							<para>Modification of a non-database field made by a Proc assignment (=)
								without the /init switch. </para>
						</listitem>
					</itemizedlist>
					<para>(You could consider $occdbmod to be the inclusive OR of the values of the
						$fielddbmod functions for all database fields in the occurrence.) </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occdel">
				<title>$occdel</title>
				<para>Return the removal status of an occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para> $occdel{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. For example: If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $occdel</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> Occurrence is marked for removal. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Occurrence is not marked for removal. </entry>
								</row>
								<row>
									<entry> "" </entry>
									<entry> Entity does not exist or is not painted on the
										component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para> ^REM_OCC sets $occdel to 1. $occdel is also set if an occurrence is
						removed via a remocc Proc statement. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Delete trigger of form, service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $occdel function is useful because an occurrence may be deleted
						without the user activating the ^REM_OCC function for this particular
						occurrence. Consider a one-to-many relationship, with a cascading delete, as
						shown in the following illustration: </para>
					<para>Figure 1. Outer and inner entities, with a cascading delete </para>
					<para>


						<mediaobject>
							<imageobject>
								<imagedata fileref="images/outerinner.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
					<para>If the first occurrence of entity B is removed with ^REM_OCC, and a STORE
						is performed, the Delete trigger is activated only in the first occurrence
						of entity B; in this trigger, $occdel returns 1 (occurrence will be
						removed). </para>
					<para>Now consider the following situation. The first occurrence of entity B is
						removed with ^REM_OCC, the occurrence of entity A is removed, then a STORE
						is performed. The Delete trigger for the occurrence of entity A is
						activated, and $occdel returns 1, because the user used ^REM_OCC on this
						occurrence. The Delete trigger for the first occurrence of entity B is also
						activated, and $occdel returns 1, because the user used ^REM_OCC on this
						occurrence also. For the other occurrences in entity B (that is, those that
						have not been explicitly removed with ^REM_OCC), the actions performed by
						Uniface are slightly different. The structure editor activates the Delete
						trigger for entity B only once. The occurrence number (given by $curocc) is
						NULL, and $occdel returns 0, as the user has not explicitly removed these
						other occurrences. </para>
					<para>Therefore, when there is a cascading delete, the Delete trigger of the
						inner entities will be activated once for each occurrence removed with
						^REM_OCC, then a final time for all other occurrences. </para>
				</sect2>
				<sect2>
					<title>Using $occdel</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occdepth">
				<title>$occdepth</title>
				<para>Return the depth of the painted occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>$occdepth{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Number of lines drawn for the specified occurrence. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $occdepth allows you to test how many lines are needed to print an
						occurrence of the specified entity. This function cannot take into
						consideration any vertical expansion that might occur when the frame is
						printed at run time. </para>
					<para>It is usually easier to set the Print Occurrence on Same Page property of
						an entity or named area frame. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to use $occdepth to determine whether
						there is enough space left on a page to print an occurrence: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
if ($lines &lt; $occdepth)
   eject
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occhandle">
				<title>$occhandle</title>
				<para> Introduced in: U8 </para>
				<para>Return the handle of the current occurrence of the requested entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> $occhandle {( <emphasis role="italic">Entity </emphasis>)} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $occhandle</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry>
											<itemizedlist>
												<listitem>
												<para>An error occurred. $procerror contains the
												exact error. </para>
												</listitem>
												<listitem>
												<para><emphasis role="italic">Entity </emphasis>is
												an incorrect entity </para>
												</listitem>
												<listitem>
												<para>There is no occurrence for the given entity
												with the name <emphasis role="italic">Entity
												</emphasis>. </para>
												</listitem>
												<listitem>
												<para>There are no public operations defined for
												the entity. If there are no public operations, no
												signature can be created for it. Without a
												signature, no handle can be returned; instead a
												NULL value is returned. </para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Handle of the current occurrence of the entity of
												<emphasis role="italic">Entity </emphasis>. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$occhandle</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1101 </entry>
										<entry> UPROCERR_FIELD</entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> UPROCERR_ENTITY</entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]> </programlisting></para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_3occmod">
				<title>$occmod</title>
				<para>Return the modification status of an occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para> $occmod{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. If omitted, the current entity is
									used. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $occmod</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 1 </entry>
										<entry>
											<itemizedlist>
												<listitem>
												<para>Occurrence has been removed </para>
												</listitem>
												<listitem>
												<para>At least one field has been modified. The
												field can be any database field or a non-database
												field (if Entity is a non-database entity).
												</para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> Occurrence has not been removed and no field has
											been modified. </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> Entity does not exist or is not painted on the
											component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). Description </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$occmod is an occurrence-level function that tests the modification status
						of data in the current occurrence of the specified entity. </para>
					<para>The $occmod function is set to 0 by the following events: </para>
					<itemizedlist>
						<listitem>
							<para>Restarting a component is restarted (except when the component has
								the Keep Data in Memory property set). </para>
						</listitem>
						<listitem>
							<para>retrieve (Note that $occmod can be set to 1 <emphasis
									role="italic">before </emphasis>a retrieve has been performed.)
							</para>
						</listitem>
						<listitem>
							<para>store </para>
						</listitem>
						<listitem>
							<para>release </para>
						</listitem>
						<listitem>
							<para>clear </para>
						</listitem>
						<listitem>
							<para>reload </para>
						</listitem>
					</itemizedlist>
					<para>Events that cause a field to be modified (and $occmod set to 1) include: </para>
					<itemizedlist>
						<listitem>
							<para>The user entering a retrieve profile in an empty field. </para>
						</listitem>
						<listitem>
							<para>The user changing the value of data that has been retrieved.
							</para>
						</listitem>
						<listitem>
							<para>Modification of a non-database field made by a Proc assignment (=)
								without the /init switch. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In this example, $occmod checks whether the current occurrence of ENTNAME
						has been modified, and records this status in the message frame. </para>
					<programlisting role="uniface"><![CDATA[$13 = $occmod (ENTNAME)
selectcase $13
   case 0
      putmess "The occurrence is unmodified"
   case 1
      putmess "The occurrence has been modified"
endselectcase
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occproperties">
				<title>$occproperties</title>
				<para> Introduced in: U8 </para>
				<para>Return or set the properties of an occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>$occproperties ( Entity ) </para>
					<para>$occproperties ( Entity ) = PropertyList </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. If omitted, the current entity is
									used. </para>
							</listitem>
							<listitem>
								<para>PropertyList—Uniface associative list of Key = Property pairs,
									in which the Key can be: <itemizedlist>
										<listitem>
											<para>errormsg—occurrence-level validation error
												messages. This can contain default Uniface
												validation error messages, or it can contain
												user-defined error messages. </para>
										</listitem>
										<listitem>
											<para>subclass—a style subclass used by server pages to
												present validation errors. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Associative list of properties.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$occproperties returns or sets the properties of an occurrence using an
						associative list. </para>
				</sect2>
				<sect2>
					<title>$occproperties in a Web application</title>
					<para>You can use subclass to provide visual clues for errors, and errormsg is
						used to provide detailed information on the nature of the error in a server
						page. To use $occproperties for this purpose, place it in the entity-level
						On Error trigger. </para>
					<para>subclass=MyClass can be substituted by, or used with, a specific error
						message using errormsg=My Error Message </para>
					<para>For example, when used together, the syntax is:</para>
					<para>$occproperties( Field )="subclass= MyClass <emphasis role="underline"
							>;</emphasis>errormsg=My error message" </para>
					<itemizedlist>
						<listitem>
							<para>MyClass—predefined style class in the application’s CSS. </para>
						</listitem>
						<listitem>
							<para>MyErrorMessage—message such as "Error in occurrence". </para>
						</listitem>
					</itemizedlist>
					<para>The syntax of $occproperties must not include spaces. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If the On Error trigger is empty,
						Uniface changes the default code from $text("%%$error") to
						$occproperties(Entity)="errormsg=$text(%%$error), but only if the trigger
						has been fired due to a validation error for a field or key. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occstatus">
				<title>$occstatus</title>
				<para> Introduced in: U8 </para>
				<para>Return or set the reconnect status for each disconnected occurrence in a
					component.</para>
				<sect2>
					<title>Syntax</title>
					<para>$occstatus ( EntityName ) </para>
					<para>$occstatus ( EntityName ) = ReconnectStatus </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>EntityName—name of an entity </para>
							</listitem>
							<listitem>
								<para>ReconnectStatus—status of the occurrence for reconnection to
									existing data by the retrieve/reconnect statement. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para><table>
							<title>Table 1. Values returned in $occstatus </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry>
											<para>$occstatus has not been set. This can mean one of
												the following: </para>
											<itemizedlist>
												<listitem>
												<para>No status attribute in the XML stream;
												xmlload could not set a value for $occstatus when
												it created the occurrence. </para>
												</listitem>
												<listitem>
												<para>Occurrence was not created by xmlload, and
												has not had $occstatus set in Proc. </para>
												</listitem>
												<listitem>
												<para>$occstatus has been set to "" in Proc.
												</para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> "est" </entry>
										<entry> Occurrence exists in the database </entry>
									</row>
									<row>
										<entry> "mod" </entry>
										<entry> Occurrence exists in the database and has been
											modified</entry>
									</row>
									<row>
										<entry> "new" </entry>
										<entry> Occurrence is new—it does not exist in the database,
											or the occurrence originates from a non-database entity
										</entry>
									</row>
									<row>
										<entry> "del" </entry>
										<entry> Occurrence is marked for deletion. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<emphasis role="bold"> Note:</emphasis> Never attempt to remove occurrences
						by setting $occstatus to "del"; use remocc instead. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $occstatus function allows you to get or set the reconnect status for
						each disconnected occurrence in the component. </para>
					<para>The xmlload Proc statement assigns a value to $occstatus using the status
						attribute in incoming XML streams. </para>
					<para>The xmlsave Proc statement uses the value of $occstatus, if available, to
						set the value of the status attribute in outgoing XML streams. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Although you are allowed to set
						$occstatus to a specific ReconnectStatus, you are strongly advised not to do
						so, because Uniface calculates its value. </para>
					<para>After retrieve/reconnect, $occstatus is empty. Use $occmod, $occdel, and
						$storetype to determine the modification state of occurrences. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_occvalidation">
				<title>$occvalidation</title>
				<para>Identify whether an occurrence requires validation. </para>
				<sect2>
					<title>Syntax</title>
					<para> $occvalidation{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. If omitted, the current entity is
									used. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> Entity is not valid, for example, the field name is
											not drawn. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> Occurrence does not require validation, either
											becasue the occurrence has not been modified or it has
											already been successfully modified. Check the the value
											of $occmod to determine which of these situations
											applies. </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Occurrence requires validation. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and service components (and in report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$occvalidation enables you to check whether an occurrence requires
						validation. An occurrence needs validation in either of the following
						circumstances: </para>
					<itemizedlist>
						<listitem>
							<para>Data in one of the fields of the occurrence has been modified
								($occmod is 1), but has not yet been successfully validated
								($occvalidation is also 1). </para>
						</listitem>
						<listitem>
							<para>Validation has been demanded by Proc code ($occcheck is 1),
								regardless of the value of $occvalidation. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> In this example $occvalidation returns the validation status of the
						current occurrence of an entity.
						<programlisting role="uniface"><![CDATA[; Field Gets Focus trigger of DUMMY
; DUMMY and FLD2 are non-database fields
; enter an appropriate entity name in FLD2
$8 = $occvalidation("%%FLD2%%%")
selectcase($8)
   case ""
      message/error "Entity name is not valid"
   case 0
      message/info "The occurrence is valid"
   case 1
      message/info "The occurrence requires validation"
endselectcase
</programlisting></para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_ocxhandle">
				<title>$ocxhandle</title>
				<para> Introduced in: U8 </para>
				<para>Return the handle of the requested OCX object.</para>
				<sect2>
					<title>Syntax</title>
					<para> $ocxhandle ( Field ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Field—field name; can be a literal name, a string, or a field (or indirect
						reference to a field), a variable, or a function that evaluates to a string.
						Mandatory. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Handle of the OCX object encapsulated in the OCX container
									widget. </para>
							</listitem>
							<listitem>
								<para>A NULL handle is returned if Field is not an OCX object or if
									an error occurs during the evaluation of this function.
									$procerror contains a negative value that identifies the exact
									error. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror Commonly Returned Following
								$occhandle</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1101 </entry>
										<entry> UPROCERR_FIELD </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> UPROCERR_ENTITY </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_oprsys">
				<title>$oprsys</title>
				<para>Return a mnemonic for the operating system used by Uniface. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$oprsys</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para><table>
							<title>Table 1. Values returned by $oprsys</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Operating system </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> A </entry>
										<entry> OpenVMS Alpha </entry>
									</row>
									<row>
										<entry> H </entry>
										<entry> Microsoft Windows 98 </entry>
									</row>
									<row>
										<entry> L </entry>
										<entry> Microsoft Windows NT </entry>
									</row>
									<row>
										<entry> P </entry>
										<entry> Microsoft Windows XP </entry>
									</row>
									<row>
										<entry> U </entry>
										<entry> Unix </entry>
									</row>
									<row>
										<entry> V </entry>
										<entry> OpenVMS VAX </entry>
									</row>
									<row>
										<entry> Y </entry>
										<entry> Microsoft Windows Vista </entry>
									</row>
									<row>
										<entry> Z </entry>
										<entry> z/OS </entry>
									</row>
									<row>
										<entry> 2 </entry>
										<entry> Microsoft Windows 2000 </entry>
									</row>
									<row>
										<entry> 3 </entry>
										<entry> Microsoft Windows 2003</entry>
									</row>
									<row>
										<entry> 4 </entry>
										<entry> AS/400 </entry>
									</row>
									<row>
										<entry> 8 </entry>
										<entry> Microsoft Windows 2008</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<emphasis role="bold"> Note:</emphasis> If a service or report component is
						running in a remote environment, the $oprsys function returns the operating
						system of the server (not of the client). </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $oprsys returns the mnemonic for the operating system that
						the Uniface application or Application Server is using. </para>
				</sect2>
				<sect2>
					<title>Example: Using $oprsys to Create a Log File</title>
					<para>In this example $oprsys is used to create a log file recording user,
						program and operating system details. </para>
					<programlisting role="uniface"><![CDATA[variables
   string localvar
   string filetext
endvariables
selectcase $oprsys
   case "A"
      localvar = "OpenVMS Alpha"
   case "P"
      localvar = "Microsoft Windows XP"
   case "H"
      localvar = "Microsoft Windows 98"
   case "L"
      localvar = "Microsoft Windows NT"
   case "U"
      localvar = "Unix"
   case "Z"
      localvar = "z/OS"
   elsecase
      localvar = "a supported operating system"
endselectcase
filetext = "%%$user%%% ran program %%$applname%%% under %%localvar%%%.%%^"
filedump/append filetext, "log.txt"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Using $oprsys to Affect Representation Property</title>
					<para>This example uses $oprsys to check if the Uniface application is running
						on Microsoft Windows XP. If so, the command button is switched to a header
						button, that is, the command button's representation property is changed to
						header. </para>
					<programlisting role="uniface"><![CDATA[;Running under Windows XP with XP look and feel.
;Set representation of command button to header.
if ($oprsys = 'P')
   $fieldproperties(FLD_BUTTON.CONTROLS) = "representation=header"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_outer">
				<title>$outer [DEPRECATED]</title>
				<para>This function is deprecated. Use $entinfo instead.</para>
				<sect2>
					<title>Syntax</title>
					<para/>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_page">
				<title>$page</title>
				<para>Return the current page number. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$page</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $page</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Uniface is not printing (that is, $printing is
											0)</entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Number of the page currently being printed. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in presentation components (and in service components that are not
						self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>You can use $page to assign the page number to dummy fields in header or
						trailer frames. </para>
					<para>If you are not printing, it returns zero when used in the Frame Gets Focus
						trigger of a header or trailer frame.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The Proc code in the following example assigns the page number to the
						dummy field REPORTPAGE in the trailer frame. The trailer frame has the
						Suppress Print if Empty property selected, which means that it does not
						appear if REPORTPAGE has no value. (right-click the frame and choose
							<emphasis role="bold">Printing &gt; Suppress Print if
						Empty</emphasis>.)</para>
					<para>The first page of the report is a cover sheet that is not numbered;
						subsequent pages are numbered starting at 1. Because of the unnumbered page,
						the value of REPORTPAGE is one less than the value supplied by $page. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Frame Gets Focus of TRAILER frame
if ($page = 1) ;if on first page done ;take no action
   done
else
   REPORTPAGE = $page - 1
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_paintedfieldproperties">
				<title>$paintedfieldproperties</title>
				<para> Introduced in: U9 </para>
				<para>Return or set the position and size for a specific instance of a field
					widget.</para>
				<sect2>
					<title>Syntax</title>
					<para>$paintedfieldproperties( Field , {PaintedOccurrence ,} { PropertyList} )
						{=} PropertyValuesList </para>
					<para>PropertyValuesList = $paintedfieldproperties( Field , PaintedOccurrence {,
						Position | Size} ) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—field name; can be a literal name, or a string,
									variable, function, parameter, or indirect reference to a field
									containing the name. It can optionally contain a qualified field
									name, for example MYFLD.MYENT. </para>
							</listitem>
							<listitem>
								<para>PaintedOccurrence—number of a painted occurrence or, if there
									are nested multiple occurrences, a GOLD <emphasis
										role="underline">;</emphasis> separated list specifying the
									occurrences starting from the outer occurrence. For example,
										"3<emphasis role="underline">;</emphasis>1" specifies the
									field in the third occurrence of the inner entity in the first
									occurrence of an outer entity. </para>
							</listitem>
							<listitem>
								<para>PropertyList—associative list of one or more of the following
									property names: <itemizedlist>
										<listitem>
											<para>xpos—sets the horizontal position </para>
										</listitem>
										<listitem>
											<para>ypos—sets the vertical position </para>
										</listitem>
										<listitem>
											<para>xsize—sets the horizontal size in characters
											</para>
										</listitem>
										<listitem>
											<para>ysize—sets the vertical size in characters </para>
										</listitem>
										<listitem>
											<para>zorder—places the painted field to Top or Bottom
												of a stack of fields (Z-order) </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>PropertyValuesList—associative list of property values
									specifying the position, size, or Z-order of the GUI object
								</para>
							</listitem>
							<listitem>
								<para>Position—associative list of properties specifying the
									beginning coordinates of the GUI object, in characters; the
									format is: </para>
								<para>" XPos {+ | -} = Value <emphasis role="underline">;</emphasis>
									YPos {+ | -} = Value " </para>
							</listitem>
							<listitem>
								<para>Size—associative list of properties defining the dimensions of
									the GUI object, in characters; the format is: </para>
								<para>" XSize {+ | -} = Value <emphasis role="underline"
										>;</emphasis> YSize {+ | -} = Value " </para>
							</listitem>
							<listitem>
								<para>+ | - —increment or decrement the current value of the size or
									position property by the specified value. If increment or
									decrement is not used, the value specified is absolute. </para>
							</listitem>
							<listitem>
								<para>ZOrder—place the current field on top or bottom of stack;
									useful when fields stack or overlap. </para>
								<para>" ZOrder = Top|Bottom " </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Associative list of properties for the specified GUI object.
								</para>
							</listitem>
							<listitem>
								<para>Empty string ("") if the object cannot be found. </para>
							</listitem>
							<listitem>
								<para>ZOrder has no return value. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use the $paintedfieldproperties function to move or resize specific field
						widgets on a form at runtime. Only the single specified widget is affected. </para>
					<para>The position of the widget is not restricted by the position of entities
						and fields on the form in the Layout Editor. This frees the form layout from
						the restrictions imposed by drawing the data structure in the Layout Editor
						as frames within frames. </para>
					<para>The Field and PaintedOccurrence identify the specific field instance to be
						repositioned. </para>
					<para>If you use enhanced printing to print a form after using
						$paintedfieldproperties, the printed output reflects the change. </para>
					<para>When $paintedfieldproperties is used in the Execute trigger, it must be
						preceded by a show statement. This ensures that the painted fields are
						available, which is otherwise not the case when the Execute trigger is
						executed. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If the form has a split bar, it is
						not possible to set the position or size of a field using
						$paintedfieldproperties. </para>
				</sect2>
				<sect2>
					<title>Stacked or Overlapping Fields</title>
					<para>The $paintedfieldproperties function enables you to position fields on top
						of one another, either directly, or so that they overlap. This means that
						forms may gain a virtual third dimension along a Z axis. </para>
					<para>To determine which field is displayed on top (or on the bottom) when
						fields stack or overlap, you can set the ZOrder property of the field to
						appear on the top or bottom of the stack.</para>
					<para>Normally. the default Z-order is determined by the initial painted
						position of a field, so the top left field is on top and the bottom right
						field is at the bottom of the Z-order. Resizing or repositioning the field
						has no effect on the Z-order.</para>
					<para>However, when the position or size of an Edit Box, Output Box, or Rich
						Text Edit widget is changed, it is put on top of the Z-order stack. </para>
				</sect2>
				<sect2>
					<title>Multiple Occurrences</title>
					<para>If a field can be displayed multiple times in a form, you need to specify
						which instance of the field you want to move or resize. Fields are displayed
						multiple times if you draw multiple occurrences of the entity. Therefore,
						you need to specify the <emphasis role="italic">painted
							occurrence</emphasis> containing the field to be moved or resized. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis>
						<emphasis role="italic">Painted occurrence</emphasis> refers to the
						occurrence painted on the form and has nothing to do with the number of
						occurrences retrieved. For example, as the user scrolls through retrieved
						data, occurrence 54 may be displayed as the first painted occurrence on the
						form. </para>
					<para>To specify a painted occurrence, provide the occurrence number. For
						example, If you have painted four occurrences of an entity on a form, and
						you want to change the size of a field (NAME) in the fourth occurrence, use
						the following instruction: </para>
					<programlisting role="uniface"><![CDATA[$paintedfieldproperties (NAME, 4) = "xsize=3<emphasis role="underline">;</emphasis>ysize=25"]]></programlisting>
					<para>However, if you have multiple occurrences nested in multiple occurrences,
						you need to specify both the inner entity occurrence and the outer entity
						occurrence. For example, the following form shows the layout and data
						structure of multiple nested entities. There are four occurrences of the
						Employee entity, each containing three occurrences of the Employment entity.
						When run, this form can display the project name field 12 times. </para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/FRM_NestedMultipleOccs.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
					<para>If you wanted to specify that the third project name of the fourth
						displayed employee is to be resized, you could use the following
						instruction: $paintedfieldproperties (NAME.PROJECT.MYORG, "1;3;4;1") =
						"xsize+=2" </para>
					<programlisting role="uniface"><![CDATA[$paintedfieldproperties (NAME.PROJECT.MYORG, "1<emphasis role="underline">;</emphasis>3<emphasis role="underline">;</emphasis>4<emphasis role="underline">;</emphasis>1") = "xsize+=2"]]></programlisting>
					<para>In this case: </para>
					<itemizedlist>
						<listitem>
							<para>The fully qualified field name is specified because there are
								multiple fields called NAME. </para>
						</listitem>
						<listitem>
							<para>1—first (and only) painted occurrence of PROJECT.MYORG </para>
						</listitem>
						<listitem>
							<para>3 —third painted occurrence of EMPLOYMENT.MYORG </para>
						</listitem>
						<listitem>
							<para>4 —fourth painted occurrence of EMPLOYEE.MYORG </para>
						</listitem>
						<listitem>
							<para>1—first (and only) occurrence of DEPARTMENT.ORG. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example sets a field widget, named FIELD1 to X, Y position
						(50, 50). </para>
					<programlisting role="uniface"><![CDATA[
; trigger exec
show
$paintedfieldproperties(FIELD1,"1") = "XPos=50<emphasis role="underline">;</emphasis>YPos=50"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example sets a field widget, named FIELD1 to Z-sort order
						Top. </para>
					<programlisting role="uniface"><![CDATA[
$paintedfieldproperties(FIELD1,"1") = "Zorder=Top"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_paintedocc">
				<title>$paintedocc</title>
				<para>Return the number of occurrences painted for the specified entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> $paintedocc{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $paintedocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> Entity does not exist or is not painted on the
											component </entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Number of occurrences painted for the specified
											entity. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example: Multiple occurrences painted on a form</title>
					<para>This example shows a form on which occurrences of entity CUSTOMER have
						been painted in three rows and two columns. In this case,
						$paintedocc(CUSTOMER) returns 6, the total number of occurrences. </para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/fig14_2.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_password">
				<title>$password</title>
				<para>Return the password used to log on to the path. </para>
				<sect2>
					<title>Syntax</title>
					<para> $password{( Path )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Path—Operating system or DBMS path name; can be a literal name, string,
						variable, function, parameter, or indirect reference to a field. If omitted,
						the user’s operating system password is returned. The leading dollar sign
						($) is never included for the path. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Password used to log on to the operating system or DBMS given
									by Path, if the operating system or DBMS supports this. </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if no password was required to log on or if
									returning a password is not supported. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$password is supported only for DBMSs that require a user name to log on
						and for those operating systems which support a user name. It is not
						supported for network drivers. </para>
					<para>If you want to close and then open a database, you can use $user and
						$password to get these values before closing. Then use these values to open
						the database. This avoids reprompting the user for information they may have
						already entered. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example saves the password and user name used to open a
						particular path, closes the path, then opens the path again: </para>
					<programlisting role="uniface"><![CDATA[$1 = $password(CUSTOMERS)
$2 = $user(CUSTOMERS)
close "$CUSTOMERS"
open "|%%$2|%%$1","$CUSTOMERS"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_pi">
				<title>$pi</title>
				<para> Introduced in: U8 </para>
				<para>Return the value of pi. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Value of pi. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$pi returns the mathematical value of pi (3.14159...). </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following shows an example of the $pi function: </para>
					<programlisting role="uniface"><![CDATA[$circum$ = $pi() * $diam$]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_power">
				<title>$power</title>
				<para> Introduced in: U8 </para>
				<para>Calculate the value of X raised to the power of Y. </para>
				<sect2>
					<title>Syntax</title>
					<para> $power ( X , Y ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> X and Y—numeric constant, or field (or indirect reference to a field),
						variable, function, or expression that evaluates to a numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Calculated value of X raised to the power of Y. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$power</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1204 </entry>
									<entry> &lt;UPROCERR_NEGATIVE&gt; </entry>
									<entry> Negative value not allowed</entry>
								</row>
								<row>
									<entry> -1207 </entry>
									<entry> &lt;UPROCERR_UNDERFLOW&gt; </entry>
									<entry> Underflow</entry>
								</row>
								<row>
									<entry> -1208 </entry>
									<entry> &lt;UPROCERR_OVERFLOW&gt; </entry>
									<entry> Overflow </entry>
								</row>
								<row>
									<entry> -1209 </entry>
									<entry> &lt;UPROCERR_DIVIDE&gt; </entry>
									<entry> Divide by zero </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $power calculates the value of X raised to the power of Y
						((XY). </para>
					<para>If X is less than zero, Y must be an integer. </para>
					<para>The absolute value of the result of $power must be in the range of 10 to the power of -9999 till 10 to the power of 9999, inclusive. </para>
				</sect2>
				<sect2>
					<title>Example: Calculating a Cube Root</title>
					<para>The following example computes the cube root of the value in MYFIELD: </para>
					<programlisting role="uniface"><![CDATA[$cuberoot$ = $power(MYFIELD, 1/3)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_previous">
				<title>$previous</title>
				<para>Return the value of the field in the previous occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$previous</command> ( <parameter>Field</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field name; can be a literal name, a string, or a field (or
						indirect reference to a field), a variable, or a function that evaluates to
						a string. Fieldcan optionally contain a qualified field name, for example
						MYFLD.MYENT. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Value of Field in the previous occurrence. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") is returned if there is no previous
									occurrence.</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $previous function allows you to refer to the contents of a field in
						the previous occurrence. Use it to: </para>
					<itemizedlist>
						<listitem>
							<para>Copy contents of a field to another field or variable. </para>
						</listitem>
						<listitem>
							<para>Perform calculations. </para>
						</listitem>
						<listitem>
							<para>Make Boolean comparisons. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> This function is not always the most
						efficient way of referring to a field in the previous occurrence. This is
						particularly true when the field referred to by $previous is part of an
						occurrence that has already been active. </para>
					<para>If the field forms part of an occurrence that has already been active, it
						is often preferable to store the contents of that field in a variable before
						moving to the previous occurrence, <emphasis role="italic">then
						</emphasis>referring to the variable. This usually costs less processing
						power. Use the Occurrence Gets Focus trigger to do this. If you are
						printing, you could also use the Leave Printed Occurrence trigger. </para>
					<para>You can test for an empty string with:
						<programlisting role="uniface"><![CDATA[if ($previous(NAME) = "")]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example generates a new invoice number using the previous
						number as a base: </para>
					<programlisting role="uniface"><![CDATA[invoiceno = $previous(INVOICENO) + 1]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_printing">
				<title>$printing</title>
				<para>Return a status indicating whether the current component is printing. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$printing</command></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>1, if Uniface is printing. </para>
							</listitem>
							<listitem>
								<para>0, if Uniface is not printing. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $printing function allows you to test whether Uniface is printing the
						current component. This can be particularly useful in the Occurrence Gets
						Focus trigger. For example, you may want to use a form both for report
						purposes and for interactive data entry or administration. The code you
						would use during a print process is probably very different from the code
						you would use for an interactive session. </para>
				</sect2>
				<sect2>
					<title>Example: Checking Print Status</title>
					<para>The following example shows how to display a message informing the user
						which page is currently being printed: </para>
					<programlisting role="uniface"><![CDATA[; check print status with $printing
if ($printing = 1)
   message "Printing %%$page%%%"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_proc_tracing">
				<title>$proc_tracing</title>
				<para> Introduced in: U9 </para>
				<para>Return the current status of Proc tracing, or activate or deactivate Proc
					tracing.</para>
				<sect2>
					<title>Syntax</title>
					<para>$proc_tracing </para>
					<para>$proc_tracing = Expression </para>
					<para>set | reset $proc_tracing </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The function $proc_tracing returns: </para>
					<itemizedlist>
						<listitem>
							<para>1, if Proc tracing is currently enabled </para>
						</listitem>
						<listitem>
							<para>0, if Proc tracing is currently not enabled </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components and in service, session service, entity
						service, and report components that are not self-contained.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use set or reset to enable or disable Proc tracing in Proc. To enable Proc
						tracing for your entire application, use the $PROC_TRACING assignment
						setting. The Proc function $proc_tracing overrides the assignment setting
						$PROC_TRACING.</para>
					<para>You can also use $proc_tracing as the target in the left side of an
						assignment, for example, $proc_tracing = 1 to enable Proc tracing, or
						$proc_tracing = !$proc_tracing to toggle between enabling and disabling Proc
						tracing.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_proc_tracing_addition">
				<title>$proc_tracing_addition</title>
				<para> Introduced in: U9 </para>
				<para> Return the current value of $proc_tracing_addition, or prefix Proc tracing
					with additional information. </para>
				<sect2>
					<title>Syntax</title>
					<para> $proc_tracing_addition</para>
					<para>$proc_tracing_addition = AdditionalInfo </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para> AdditionalInfo can be any string or expression. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>$proc_tracing_addition returns the current value of the additional
						information previously assigned using $proc_tracing_addition. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> Use $proc_tracing_addition to prefix Proc tracing with additional
						information via your Proc code. To prefix Proc tracing with additional
						information for your entire application, use the $PROC_TRACING_ADDITION
						assignment setting. The Proc function $proc_tracing_addition overrides the
						assignment setting. </para>
					<para>For example, $proc_tracing_addition = "Status:%% $status". </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The space between Status:%% and
						$status is necessary to keep the Proc engine from evaluating $status. </para>
					<para><emphasis role="bold"> Note:</emphasis> The information in the log file
						can be truncated, depending on the length of the additional information.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_procerror">
				<title>$procerror</title>
				<para>Return the reason for an error in Proc execution. </para>
				<sect2>
					<title>Syntax</title>
					<para>$procerror {= Value} </para>
					<para>reset $procerror </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>You can use the error constants shown in writing your Proc code. Using
						these constants makes your Proc code more readable. </para>
					<table>
						<title>Table 1. Values returned by $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> UACT_SUCCESS</entry>
									<entry> Success.</entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> UGENERR_ERROR </entry>
									<entry> An error occurred. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> UIOSERR_OCC_NOT_FOUND </entry>
									<entry> Occurrence or record not found; the table is empty or
										end of file was encountered. Occurrence removed since last
										retrieve. The entity is painted as an up entity and the key
										value was not found during the database lookup. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> UIOSERR_EXCEPTIONAL </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> UIOSERR_OPEN_FAILURE </entry>
									<entry> The table or file could not be opened. The entity is not
										painted or the corresponding table or file does not exist in
										the database. </entry>
								</row>
								<row>
									<entry> -5 </entry>
									<entry> UIOSERR_UPDATE_NOT_ALLOWED</entry>
									<entry> No write or delete permission for the table or file. The
										occurrence is read-only (cannot be locked). </entry>
								</row>
								<row>
									<entry> -6 </entry>
									<entry> UIOSERR_WRITE_FAILURE </entry>
									<entry> An error occurred while writing, updating, or deleting
										the table or file; for example, lack of disk space, no write
										permission, or violation of a database constraint. </entry>
								</row>
								<row>
									<entry> -7 </entry>
									<entry> UIOSERR_DUPLICATE_KEY </entry>
									<entry> The key exists in the database but was not found in the
										hitlist. This occurs when the user tries to enter a
										duplicate key. </entry>
								</row>
								<row>
									<entry> -8 </entry>
									<entry> UIOSERR_END_OF_HITLIST </entry>
									<entry> End of hitlist. </entry>
								</row>
								<row>
									<entry> -9 </entry>
									<entry> UIOSERR_LOGON_ERROR </entry>
									<entry> DBMS logon error. This can occur if the database
										connection has been lost or the maximum number of DBMS
										logons has already been reached. </entry>
								</row>
								<row>
									<entry> -10 </entry>
									<entry> UIOSERR_LOCK_DATA_MISMATCH </entry>
									<entry> Occurrence has been modified or removed since it was
										retrieved; the occurrence should be reloaded. </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> UIOSERR_LOCKED </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -12 </entry>
									<entry> UIOSERR_FILE_READ_WRITE </entry>
									<entry> An error occurred while trying to read or write to the
										file. </entry>
								</row>
								<row>
									<entry> -13 </entry>
									<entry> UIOSERR_OS_COMMAND</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set $ioprint to 63 to display the exact error in
										the message frame.</entry>
								</row>
								<row>
									<entry> -14 </entry>
									<entry> URETERR_MULTIPLE_DOWN </entry>
									<entry> The entity is painted as a normal down entity and
										multiple hits were found during the database lookup
										(ambiguous key). </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> URETERR_MULTIPLE_UP </entry>
									<entry> The entity is painted as an up entity and multiple hits
										were found during the database lookup. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> UNETERR_UNKNOWN </entry>
									<entry> Network error. </entry>
								</row>
								<row>
									<entry> -17 </entry>
									<entry> UNETERR_PIPE_BROKEN </entry>
									<entry> Connection lost. </entry>
								</row>
								<row>
									<entry> -18 </entry>
									<entry> UNETERR_CONNECTION</entry>
									<entry> Application failed to connect to the Router, or failed
										to start an exclusive Application Server. </entry>
								</row>
								<row>
									<entry> -19 </entry>
									<entry> UNETERR_FATAL </entry>
									<entry> Application Server exited with fatal error. </entry>
								</row>
								<row>
									<entry> -20</entry>
									<entry> UNETERR_MAX_CLIENTS </entry>
									<entry> Router could not accept new client, $MAX_CLIENTS
										exceeded. </entry>
								</row>
								<row>
									<entry> -21 </entry>
									<entry> UNETERR_LOGON_ERROR </entry>
									<entry> Network logon error. </entry>
								</row>
								<row>
									<entry> -22 </entry>
									<entry> UNETERR_NO_REGISTRATION </entry>
									<entry> Application failed to register with the Router. </entry>
								</row>
								<row>
									<entry> -23 </entry>
									<entry> UNETERR_DOUBLE_UST </entry>
									<entry> Registration with Router specified UST that is already
										in use. </entry>
								</row>
								<row>
									<entry> -24 </entry>
									<entry> UNETERR_START_SERVER </entry>
									<entry> Router could not start Application Server process
										(executable not found). </entry>
								</row>
								<row>
									<entry> -25 </entry>
									<entry> UNETERR_SERVER_GONE </entry>
									<entry> Router could not route request to specific Application
										Server process. </entry>
								</row>
								<row>
									<entry> -31 </entry>
									<entry> UGENERR_LICENSE </entry>
									<entry> No license for requested action. Contact your Uniface
										representative. </entry>
								</row>
								<row>
									<entry> -32 </entry>
									<entry> UGENERR_TIMEOUT </entry>
									<entry> A time-out occurred. </entry>
								</row>
								<row>
									<entry> -33 </entry>
									<entry> UGENERR_BATCH_ONLY </entry>
									<entry> Statement not allowed in batch mode. Use a test on
										$batch to avoid this. </entry>
								</row>
								<row>
									<entry> -34 </entry>
									<entry> UGENERR_CURRENCY </entry>
									<entry> Changes to the active path not allowed. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> UGENERR_4GL_SAYS_ERROR </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -36 </entry>
									<entry> UGENERR_TEST </entry>
									<entry> Statement not allowed in test mode. </entry>
								</row>
								<row>
									<entry> -40</entry>
									<entry> USYSERR_NOMEMORY</entry>
									<entry> Not enough memory</entry>
								</row>
								<row>
									<entry> -41</entry>
									<entry> USYSERR_INVALID</entry>
									<entry> Invalid characters in directory or filename </entry>
								</row>
								<row>
									<entry> -50 </entry>
									<entry> UACTERR_NO_SIGNATURE </entry>
									<entry> Signature descriptor for the current component not found
										(in ULANA.DICT, USYSANA.DICT, URR file, or resource file).
										For example, the component name provided is not valid.
									</entry>
								</row>
								<row>
									<entry> -51 </entry>
									<entry> UACTERR_SIGNATURE_ID </entry>
									<entry> The identifier of the compiled component does not match
										the identifier in the signature descriptor (in ULANA.DICT,
										USYSANA.DICT, URR file, or resource file). </entry>
								</row>
								<row>
									<entry> -52 </entry>
									<entry> UACTERR_PROTOCOL </entry>
									<entry> Protocol error (wrong sequence of operations). </entry>
								</row>
								<row>
									<entry> -53 </entry>
									<entry> UACTERR_ENTITY_GET </entry>
									<entry> An error occurred while copying the occurrences of an
										entity parameter to occurrences of the activated operation.
										This occurs at the start of processing for the activate
										statement on either the client or the server. </entry>
								</row>
								<row>
									<entry> -54 </entry>
									<entry> UACTERR_ENTITY_PUT </entry>
									<entry> An error occurred while copying occurrences of the
										entity parameter in the activated operation to occurrences
										of the component instance. This occurs at the end of
										processing for the activate statement on either the client
										or the server. </entry>
								</row>
								<row>
									<entry> -55 </entry>
									<entry> UACTERR_PARAMETER_GET </entry>
									<entry> An error occurred while getting an OUT or INOUT
										parameter from the activated operation. For example, the
										actual parameter provided cannot be used to receive output
										because it is a constant string. This occurs at the end of
										processing for the activate statement on either the client
										or the server. </entry>
								</row>
								<row>
									<entry> -56 </entry>
									<entry> UACTERR_PARAMETER_PUT </entry>
									<entry> An error occurred while putting an IN or INOUT parameter
										into the activated operation. This error occurs at the start
										of processing for the activate statement on either the
										client or the server. </entry>
								</row>
								<row>
									<entry> -57 </entry>
									<entry> UACTERR_NO_INSTANCE </entry>
									<entry> The named instance cannot be found in the component
										pool. </entry>
								</row>
								<row>
									<entry> -58 </entry>
									<entry> UACTERR_NO_COMPONENT </entry>
									<entry> The named component cannot be found. </entry>
								</row>
								<row>
									<entry> -59 </entry>
									<entry> UACTERR_NO_OPERATION </entry>
									<entry> No definition found for operation. </entry>
								</row>
								<row>
									<entry> -60 </entry>
									<entry> UACTERR_ACTION_ON_MODAL_FORM </entry>
									<entry> An attempt was made by an instance other than the
										current modal form instance to start an operation other than
										the EXEC operation. </entry>
								</row>
								<row>
									<entry> -61 </entry>
									<entry> UACTERR_ENTITY_DUMMY </entry>
									<entry> The entity specified as an entity parameter is a dummy
										entity. </entry>
								</row>
								<row>
									<entry> -62 </entry>
									<entry> UACTERR_ENTITY_PARAM_MISMATCH </entry>
									<entry> The entity specified as an entity parameter must be the
										same entity as that specified in the operation. That is, one
										is a supertype and the other is a subtype of that supertype,
										or both are subtypes of the same supertype. </entry>
								</row>
								<row>
									<entry> -63</entry>
									<entry> UACTERR_NO_PROPERTY </entry>
									<entry> No property found.</entry>
								</row>
								<row>
									<entry> -64</entry>
									<entry> UACTERR_OPER_MAP_NO_MAP</entry>
									<entry> Operation not mapped.</entry>
								</row>
								<row>
									<entry> -65 </entry>
									<entry> UACTERR_OPER_NOT_IMPLEMENTED </entry>
									<entry> No implementation found for operation. </entry>
								</row>
								<row>
									<entry> -66</entry>
									<entry> UACTERR_OCC_NOT_ALLOWED</entry>
									<entry> Not allowed on occurrence parameter.</entry>
								</row>
								<row>
									<entry> -67</entry>
									<entry> UACTERR_OCCURRENCE_GET</entry>
									<entry> Occurrence parameter get error.</entry>
								</row>
								<row>
									<entry> -68</entry>
									<entry> UACTERR_OCCURRENCE_PUT</entry>
									<entry> Occurrence parameter put error.</entry>
								</row>
								<row>
									<entry> -69</entry>
									<entry> UACTERR_OCC_RELTD_ONE_MISS</entry>
									<entry> Occurrence parameter error. The related occurrence is
										not available.</entry>
								</row>
								<row>
									<entry> -70</entry>
									<entry> UACTERR_ENT_DESCR_NOTFND</entry>
									<entry> Entity descriptor not found.</entry>
								</row>
								<row>
									<entry> -71</entry>
									<entry> UACTERR_GET_STATE</entry>
									<entry> Error in getting state.</entry>
								</row>
								<row>
									<entry> -72</entry>
									<entry> UACTERR_ENTITY_PARAM_IS_SELF</entry>
									<entry> Entity parameter is both source and destination.</entry>
								</row>
								<row>
									<entry> -80</entry>
									<entry> UACTERR_URB_INIT</entry>
									<entry> Failure to connect to URB.</entry>
								</row>
								<row>
									<entry> -81</entry>
									<entry> UACTERR_ENGINE_INIT</entry>
									<entry> Failure to connect to engine.</entry>
								</row>
								<row>
									<entry> -84</entry>
									<entry> UACTERR_NO_OBJECT</entry>
									<entry> No handle or empty handle specified.</entry>
								</row>
								<row>
									<entry> -85</entry>
									<entry> UACTERR_NO_REQUEST</entry>
									<entry> No request specified.</entry>
								</row>
								<row>
									<entry> -86</entry>
									<entry> UACTERR_EXPOSE</entry>
									<entry> Failure to expose object.</entry>
								</row>
								<row>
									<entry> -87</entry>
									<entry> UACTERR_REQUEST</entry>
									<entry> Unsupported or unknown request encountered.</entry>
								</row>
								<row>
									<entry> -88</entry>
									<entry> UACTERR_OBJECT_DELETED</entry>
									<entry> Object has been deleted.</entry>
								</row>
								<row>
									<entry> -90</entry>
									<entry> UZIPERR_STREAM</entry>
									<entry> Invalid (compressed) data stream error </entry>
								</row>
								<row>
									<entry> -91</entry>
									<entry> UZIPERR_DATA</entry>
									<entry> Invalid data in zip file structure </entry>
								</row>
								<row>
									<entry> -92</entry>
									<entry> UZIPERR_CRC </entry>
									<entry> CRC data mismatch </entry>
								</row>
								<row>
									<entry> -93</entry>
									<entry> UZIPERR_LENGTH</entry>
									<entry> Data length mismatch </entry>
								</row>
								<row>
									<entry> -94 </entry>
									<entry> UZIPERR_VERSION</entry>
									<entry> Zip library incompatible </entry>
								</row>
								<row>
									<entry> -150 </entry>
									<entry> UACTERR_UNKNOWN </entry>
									<entry> A hardware or software error occurred. Contact your
										Uniface representative. </entry>
								</row>
								<row>
									<entry> -151 </entry>
									<entry> UACTERR_EXCEPTION_THROWN </entry>
									<entry> An exception error has been thrown.</entry>
								</row>
								<row>
									<entry> -154</entry>
									<entry> UACTERR_INSTANCE_NAME_EXISTS</entry>
									<entry>
										<para>An instance with this name already exists. This error
											code is returned, for example, in the following
											cases:</para>
										<itemizedlist>
											<listitem>
												<para>When a modal form which is already active is
												activated again </para>
											</listitem>
											<listitem>
												<para>When an attempt is made to activate a modal
												form from a non-modal form </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> -155 </entry>
									<entry> UACTERR_CREATE_INSTANCE </entry>
									<entry>
										<para>An error occurred while creating an instance:</para>
										<itemizedlist>
											<listitem>
												<para>An unknown property occurs in the instance
												properties. </para>
											</listitem>
											<listitem>
												<para>A property in the instance properties has a
												value that is not valid. </para>
											</listitem>
											<listitem>
												<para>The component could not be loaded. </para>
											</listitem>
											<listitem>
												<para>An exit statement was executed in the
												operation INIT. </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> -156 </entry>
									<entry> UACTERR_WRONG_IMPLEMENTATION </entry>
									<entry> Wrong or undefined implementation. </entry>
								</row>
								<row>
									<entry> -159 </entry>
									<entry> UACTERR_QUEUE </entry>
									<entry> Message could not be delivered to requested queue.
									</entry>
								</row>
								<row>
									<entry> -160 </entry>
									<entry> UACTERR_ILLEGAL_SYNC_MODE </entry>
									<entry> Unknown communication mode </entry>
								</row>
								<row>
									<entry> -161 </entry>
									<entry> UACTERR_ILLEGAL_SYNC_TYPE </entry>
									<entry> Illegal mixture of synchronous and asynchronous
										communication modes. </entry>
								</row>
								<row>
									<entry> -162 </entry>
									<entry> UACTERR_DELETE_INSTANCE </entry>
									<entry> Deleting the instance has been postponed because the
										instance is busy. For example, operation A1 in INSTA
										activates operation B1 in INSTB. Operation B1, in turn,
										activates operation A2 in INSTA. Operation A2 performs an
										exit, but INSTA cannot be deleted until operations B1 and A1
										complete. </entry>
								</row>
								<row>
									<entry> -163 </entry>
									<entry> UACTERR_DEL_POSTPONED_CHILD </entry>
									<entry> Deleting the instance has been postponed because the
										instance has at least one busy child instance. The instance
										will be deleted when it no longer has busy children. For
										example, non-modal form FRMX starts an attached non-modal
										form FRMY. While the application is idle, the user clicks on
										FRMY, activating a trigger which sends a message to FRMX.
										This message results in an exit (on FRMX), but FRMX cannot
										be deleted until its child instance FRMY is not busy.
									</entry>
								</row>
								<row>
									<entry> -164 </entry>
									<entry> UACTERR_DEL_POSTPONED_PROC </entry>
									<entry> The instance is in the process of being deleted. For
										example, between a deleteinstance or exit and the time the
										instance is actually deleted, an attempt is made to activate
										an operation in the instance being deleted. </entry>
								</row>
								<row>
									<entry> -165 </entry>
									<entry> UACTERR_BAD_HANDLE </entry>
									<entry> Handle not valid. </entry>
								</row>
								<row>
									<entry> -166 </entry>
									<entry> UACTERR_STATELESS </entry>
									<entry> Component instance could not be created by the
										newinstance statement because the component is stateless.
									</entry>
								</row>
								<row>
									<entry> -167</entry>
									<entry> UACTERR_BAD_INIT_OPT</entry>
									<entry> Initilization or Option properties error</entry>
								</row>
								<row>
									<entry> -170</entry>
									<entry> UACTERR_TX_FAILURE</entry>
									<entry> Transaction manager failure.</entry>
								</row>
								<row>
									<entry> -171</entry>
									<entry> UACTERR_TX_NO_TRANSPORT</entry>
									<entry> Transaction cannot be transported.</entry>
								</row>
								<row>
									<entry> -172</entry>
									<entry> UACTERR_TX_NOT_STARTED</entry>
									<entry> Transaction is not started.</entry>
								</row>
								<row>
									<entry> -173</entry>
									<entry> UACTERR_TX_NOT_RUNNING</entry>
									<entry> Transaction is not running.</entry>
								</row>
								<row>
									<entry> -250 </entry>
									<entry> UWEBERR_SKELETON </entry>
									<entry> Skeleton file not found or is incorrect. </entry>
								</row>
								<row>
									<entry> -251 </entry>
									<entry> UWEBERR_OUTFILE </entry>
									<entry> When $web ="", the output file is not specified or is
										the same as the skeleton file. </entry>
								</row>
								<row>
									<entry> -252 </entry>
									<entry> UWEBERR_IO </entry>
									<entry> Output file could not be written. </entry>
								</row>
								<row>
									<entry> -253 </entry>
									<entry> UWEBERR_IO_IMAGE </entry>
									<entry> Image file could not be written. </entry>
								</row>
								<row>
									<entry> -254 </entry>
									<entry> UWEBERR_ITERATION </entry>
									<entry> Nested iteration over the same entity. </entry>
								</row>
								<row>
									<entry> -255 </entry>
									<entry> UWEBERR_NO_CGI </entry>
									<entry> This statement must be used in a Web run-time
										environment ($web !=""). </entry>
								</row>
								<row>
									<entry> -256 </entry>
									<entry> UWEBERR_NO_INPUT_EXPECTED </entry>
									<entry> No further input expected, because no fill-out document
										has been generated. </entry>
								</row>
								<row>
									<entry> -257 </entry>
									<entry> UWEBERR_ILLEGAL_ACT </entry>
									<entry> One or more fields cannot be accessed; that is, field
										names referenced in the fill-out document skeleton file are
										not available in the current Uniface form. </entry>
								</row>
								<row>
									<entry> -258 </entry>
									<entry> UWEBERR_STEP </entry>
									<entry> Form synchronization error, that is, the user has
										submitted an HTML document that does not correspond to the
										last one generated. It is, instead, a form generated by
										Uniface earlier in the same session. </entry>
								</row>
								<row>
									<entry> -259 </entry>
									<entry> UWEBERR_HASH </entry>
									<entry> Mismatch between the security hash of a field and the
										field value. This occurs when the value of a NED field has
										been modified by the browser or other web user agent.
									</entry>
								</row>
								<row>
									<entry> -300 </entry>
									<entry> UVALERR_SYNTAX </entry>
									<entry> An error in declarative syntax occurred. </entry>
								</row>
								<row>
									<entry> -301 </entry>
									<entry> UVALERR_CONSTRAINT </entry>
									<entry> Violation of restricted delete constraint. </entry>
								</row>
								<row>
									<entry> -302 </entry>
									<entry> UVALERR_KEY_PROFILE </entry>
									<entry> A key field contains a profile character or the key is
										incomplete. </entry>
								</row>
								<row>
									<entry> -303 </entry>
									<entry> UVALERR_KEY_EMPTY </entry>
									<entry> A key field is empty. </entry>
								</row>
								<row>
									<entry> -304</entry>
									<entry> UVALERR_TARGET_FIELD</entry>
									<entry> Cannot move focus to target field </entry>
								</row>
								<row>
									<entry> -350 </entry>
									<entry> UHLPERR_STARTUP </entry>
									<entry> Unable to start help. </entry>
								</row>
								<row>
									<entry> -351 </entry>
									<entry> UHLPERR_PLATFORM </entry>
									<entry> Platform does not support native help. (In this case you
										may want to use the help [native] statement to provide help
										information.) </entry>
								</row>
								<row>
									<entry> -352 </entry>
									<entry> UHLPERR_LOGICAL_NAME </entry>
									<entry> Unable to map logical name. </entry>
								</row>
								<row>
									<entry> -353 </entry>
									<entry> UHLPERR_TOPIC </entry>
									<entry> Requested help topic or keyword not found. </entry>
								</row>
								<row>
									<entry> -354 </entry>
									<entry> UHLPERR_OPTION </entry>
									<entry> Native help does not support the requested option.
									</entry>
								</row>
								<row>
									<entry> -400 </entry>
									<entry> UMISERR_PRINT </entry>
									<entry>
										<para>Uniface could not print, for example: </para>
										<itemizedlist>
											<listitem>
												<para>Printing is already being performed ($printing
												=1). </para>
											</listitem>
											<listitem>
												<para>^QUIT was used in the Print form. </para>
											</listitem>
											<listitem>
												<para>The print mode is not valid. For more
												information on printmodes, see print </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> -401 </entry>
									<entry> UMISERR_PRINT_BREAK </entry>
									<entry>
										<para>An error occurred during printbreak:</para>
										<itemizedlist>
											<listitem>
												<para>Uniface is not printing ($printing =0).
												</para>
											</listitem>
											<listitem>
												<para>printbreak encountered in a header or trailer
												frame. </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> -403 </entry>
									<entry> UMISERR_UWHERE </entry>
									<entry> Nonexistent field in a u_where clause. </entry>
								</row>
								<row>
									<entry> -404 </entry>
									<entry> UMISERR_TRX </entry>
									<entry> The TRX-formatted DML statement from a where clause or
										an sql statement exceeds 16 KB. </entry>
								</row>
								<row>
									<entry> -405 </entry>
									<entry> UMISERR_SETFORMFOCUS </entry>
									<entry> Modal form has focus. </entry>
								</row>
								<row>
									<entry> -406 </entry>
									<entry> UMISERR_FILEBOX </entry>
									<entry> An error occurred during a filebox statement. </entry>
								</row>
								<row>
									<entry> -1001 </entry>
									<entry> UPROCERR_STRING </entry>
									<entry> Not a valid String value. </entry>
								</row>
								<row>
									<entry> -1002 </entry>
									<entry> UPROCERR_NUMERIC </entry>
									<entry> Not a valid Numeric value. </entry>
								</row>
								<row>
									<entry> -1003 </entry>
									<entry> UPROCERR_FLOAT </entry>
									<entry> Not a valid Float value. </entry>
								</row>
								<row>
									<entry> -1004 </entry>
									<entry> UPROCERR_DATE </entry>
									<entry> Not a valid Date value. </entry>
								</row>
								<row>
									<entry> -1005 </entry>
									<entry> UPROCERR_TIME </entry>
									<entry> Not a valid Time value. </entry>
								</row>
								<row>
									<entry> -1006 </entry>
									<entry> UPROCERR_DATETIME </entry>
									<entry> Not a valid Datetime value. </entry>
								</row>
								<row>
									<entry> -1007 </entry>
									<entry> UPROCERR_RAW </entry>
									<entry> Not a valid Raw value. </entry>
								</row>
								<row>
									<entry> -1008 </entry>
									<entry> UPROCERR_BOOLEAN </entry>
									<entry> Not a valid Boolean value. </entry>
								</row>
								<row>
									<entry> -1009 </entry>
									<entry> UPROCERR_LINEAR_DATE </entry>
									<entry> Not a valid Linear Date value. </entry>
								</row>
								<row>
									<entry> -1010 </entry>
									<entry> UPROCERR_LINEAR_TIME </entry>
									<entry> Not a valid Linear Time value. </entry>
								</row>
								<row>
									<entry> -1011 </entry>
									<entry> UPROCERR_LINEAR_DATETIME </entry>
									<entry> Not a valid Linear Datetime value. </entry>
								</row>
								<row>
									<entry> -1012 </entry>
									<entry> UPROCERR_IMAGE </entry>
									<entry> Not a valid Image value. </entry>
								</row>
								<row>
									<entry> -1013 </entry>
									<entry> UPROCERR_SYNTAXSTRING </entry>
									<entry> Not a valid syntax string. </entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> UPROCERR_ENTITY </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1103 </entry>
									<entry> UPROCERR_MODEL </entry>
									<entry> The model name provided is not a valid name or the model
										is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1104 </entry>
									<entry> UPROCERR_KEY </entry>
									<entry> The key number provided is not valid; for example, the
										key number was out of range. </entry>
								</row>
								<row>
									<entry> -1105 </entry>
									<entry> UPROCERR_INSTANCE </entry>
									<entry> The instance name provided is not valid. (See
										newinstance for more information.) For example, the argument
										contains incorrect characters. </entry>
								</row>
								<row>
									<entry> -1106 </entry>
									<entry> UPROCERR_COMPONENT </entry>
									<entry> The component name provided is not valid; for example,
										the argument contains an empty string (""). </entry>
								</row>
								<row>
									<entry> -1107 </entry>
									<entry> UPROCERR_PATH </entry>
									<entry> The path name is not correct or the path does not exist,
										for example, no assignment is found for the path. </entry>
								</row>
								<row>
									<entry> -1108 </entry>
									<entry> UPROCERR_COUNTER </entry>
									<entry> Uniface was unable to access UOBJ.TEXT or the counter is
										not defined. </entry>
								</row>
								<row>
									<entry> -1109 </entry>
									<entry> UPROCERR_ENTRY </entry>
									<entry> The entry name specified cannot be found. </entry>
								</row>
								<row>
									<entry> -1110 </entry>
									<entry> UPROCERR_TOPIC </entry>
									<entry> Topic name not known. </entry>
								</row>
								<row>
									<entry> -1111 </entry>
									<entry> UPROCERR_MESSAGE </entry>
									<entry> The message identifier is not valid; the field or
										variable was not found, or the string is not a valid message
										identifier. </entry>
								</row>
								<row>
									<entry> -1112 </entry>
									<entry> UPROCERR_OPTION </entry>
									<entry> Option not valid. </entry>
								</row>
								<row>
									<entry> -1113 </entry>
									<entry> UPROCERR_PARAMETER </entry>
									<entry> Parameter name not valid or not defined. </entry>
								</row>
								<row>
									<entry> -1114 </entry>
									<entry> UPROCERR_LOCAL_VARIABLE </entry>
									<entry> Local variable name not valid or not defined. </entry>
								</row>
								<row>
									<entry> -1115 </entry>
									<entry> UPROCERR_COMPONENT_VARIABLE </entry>
									<entry> Component variable name not valid or not found. </entry>
								</row>
								<row>
									<entry> -1116 </entry>
									<entry> UPROCERR_GENERAL_VARIABLE </entry>
									<entry> General variable not valid. </entry>
								</row>
								<row>
									<entry> -1117 </entry>
									<entry> UPROCERR_GLOBAL_VARIABLE </entry>
									<entry> Global variable name not valid or not found. </entry>
								</row>
								<row>
									<entry> -1118 </entry>
									<entry> UPROCERR_ARGUMENT </entry>
									<entry> The argument specified is incorrect. </entry>
								</row>
								<row>
									<entry> -1119 </entry>
									<entry> UPROCERR_FUNCTION </entry>
									<entry> Proc function not valid. </entry>
								</row>
								<row>
									<entry> -1120 </entry>
									<entry> UPROCERR_OPERATION </entry>
									<entry> The operation name provided is not valid (see
										operation). </entry>
								</row>
								<row>
									<entry> -1121 </entry>
									<entry> UPROCERR_3GL </entry>
									<entry> The requested 3GL function was not found. </entry>
								</row>
								<row>
									<entry> -1122 </entry>
									<entry> UPROCERR_NARGUMENTS </entry>
									<entry> Wrong number of arguments. </entry>
								</row>
								<row>
									<entry> -1123 </entry>
									<entry> UPROCERR_NPARAMETERS </entry>
									<entry> Wrong number of parameters. </entry>
								</row>
								<row>
									<entry> -1124 </entry>
									<entry> UPROCERR_APPLICATION </entry>
									<entry> Application name not valid. </entry>
								</row>
								<row>
									<entry> -1125 </entry>
									<entry> UPROCERR_MENU </entry>
									<entry> The specified menu does not exist. </entry>
								</row>
								<row>
									<entry> -1126 </entry>
									<entry> UPROCERR_PROPERTY </entry>
									<entry> A property is not valid. </entry>
								</row>
								<row>
									<entry> -1127 </entry>
									<entry> UPROCERR_DATATYPE </entry>
									<entry> Data type not valid. </entry>
								</row>
								<row>
									<entry> -1128 </entry>
									<entry> UPROCERR_NOT_A_KEY </entry>
									<entry> The key number specified is an index. </entry>
								</row>
								<row>
									<entry> -1129</entry>
									<entry> UPROCERR_ITEM</entry>
									<entry> Item not found.</entry>
								</row>
								<row>
									<entry> -1130</entry>
									<entry> UPROCERR_PUTLIST_DOUBLE</entry>
									<entry> Double entry in PUTLIST.</entry>
								</row>
								<row>
									<entry> -1131</entry>
									<entry> UPROCERR_PUTLIST_NON_EXIST</entry>
									<entry> Nonexisting entry in PUTLIST.</entry>
								</row>
								<row>
									<entry> -1132</entry>
									<entry> UPROCERR_UNRESOLVED_TOPIC</entry>
									<entry> Topic could not be resolved.</entry>
								</row>
								<row>
									<entry> -1201 </entry>
									<entry> UPROCERR_SMALL </entry>
									<entry> Value too small. </entry>
								</row>
								<row>
									<entry> -1202 </entry>
									<entry> UPROCERR_LARGE </entry>
									<entry> Value too large. </entry>
								</row>
								<row>
									<entry> -1203 </entry>
									<entry> UPROCERR_RANGE </entry>
									<entry> Value out of range. </entry>
								</row>
								<row>
									<entry> -1204 </entry>
									<entry> UPROCERR_NEGATIVE </entry>
									<entry> Negative value not allowed. </entry>
								</row>
								<row>
									<entry> -1205 </entry>
									<entry> UPROCERR_ZERO </entry>
									<entry> Zero value not allowed. </entry>
								</row>
								<row>
									<entry> -1206 </entry>
									<entry> UPROCERR_INTEGER </entry>
									<entry> Not an integer. </entry>
								</row>
								<row>
									<entry> -1207 </entry>
									<entry> UPROCERR_UNDERFLOW </entry>
									<entry> Underflow. </entry>
								</row>
								<row>
									<entry> -1208 </entry>
									<entry> UPROCERR_OVERFLOW </entry>
									<entry> Overflow. </entry>
								</row>
								<row>
									<entry> -1209 </entry>
									<entry> UPROCERR_DIVIDE </entry>
									<entry> Divide by zero. </entry>
								</row>
								<row>
									<entry> -1301 </entry>
									<entry> UPROCERR_SYNTAX </entry>
									<entry> Syntax error. </entry>
								</row>
								<row>
									<entry> -1302 </entry>
									<entry> UPROCERR_SERVICE </entry>
									<entry> Function not allowed on service. </entry>
								</row>
								<row>
									<entry> -1303 </entry>
									<entry> UPROCERR_REPORT </entry>
									<entry> Function not allowed on report. </entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> UPROCERR_UNKNOWN_CONTEXT </entry>
									<entry> Function not allowed, unknown context. </entry>
								</row>
								<row>
									<entry> -1305 </entry>
									<entry> UPROCERR_EXPRESSION </entry>
									<entry> Expression not allowed. </entry>
								</row>
								<row>
									<entry> -1306 </entry>
									<entry> UPROCERR_CONDITION </entry>
									<entry> Condition not allowed. </entry>
								</row>
								<row>
									<entry> -1307 </entry>
									<entry> UPROCERR_EXTRACTION_EXPR </entry>
									<entry> Extraction expression is a condition. </entry>
								</row>
								<row>
									<entry> -1308 </entry>
									<entry> UPROCERR_INDIRECTION </entry>
									<entry> Indirection followed by brackets. </entry>
								</row>
								<row>
									<entry> -1309 </entry>
									<entry> UPROCERR_PARENTHESES </entry>
									<entry> Operand followed by parentheses. </entry>
								</row>
								<row>
									<entry> -1310 </entry>
									<entry> UPROCERR_BRACKETS </entry>
									<entry> Operand followed by square brackets. </entry>
								</row>
								<row>
									<entry> -1311 </entry>
									<entry> UPROCERR_UNSOLVED_OPERAND</entry>
									<entry> A field, parameter, or variable could not be found in
										current context. </entry>
								</row>
								<row>
									<entry> -1312</entry>
									<entry> UPROCERR_LABEL </entry>
									<entry> The label is not valid.</entry>
								</row>
								<row>
									<entry> -1313</entry>
									<entry> UPROCERR_SWITCH </entry>
									<entry> The switch is not valid.</entry>
								</row>
								<row>
									<entry> -1314</entry>
									<entry> UPROCERR_DESTINATION </entry>
									<entry> The operand cannot be used as destination.</entry>
								</row>
								<row>
									<entry> -1315</entry>
									<entry> UPROCERR_OPERATOR </entry>
									<entry> The operator is not valid.</entry>
								</row>
								<row>
									<entry> -1316</entry>
									<entry> UPROCERR_RELATIONAL </entry>
									<entry> Conditional operators are not allowed in
										expressions.</entry>
								</row>
								<row>
									<entry> -1317</entry>
									<entry> UPROCERR_SWITCH_COMBINATION </entry>
									<entry> The switch combination is not valid.</entry>
								</row>
								<row>
									<entry> -1318</entry>
									<entry> UPROCERR_SELFCONTAINED </entry>
									<entry> This is not allowed in a self-contained
										component.</entry>
								</row>
								<row>
									<entry> -1319</entry>
									<entry> UPROCERR_SERVERPAGE</entry>
									<entry> Function not allowed on server page.</entry>
								</row>
								<row>
									<entry> -1401 </entry>
									<entry> UPROCERR_PROMPT </entry>
									<entry> Prompted field not valid. </entry>
								</row>
								<row>
									<entry> -1402 </entry>
									<entry> UPROCERR_STATEMENT </entry>
									<entry> Statement not allowed in this trigger. </entry>
								</row>
								<row>
									<entry> -1403 </entry>
									<entry> UPROCERR_OPERAND </entry>
									<entry> Operand not valid. </entry>
								</row>
								<row>
									<entry> -1404 </entry>
									<entry> UPROCERR_NO_PRINTING </entry>
									<entry> Not printing (that is, $printing =0). </entry>
								</row>
								<row>
									<entry> -1405 </entry>
									<entry> UPROCERR_UOBJ </entry>
									<entry> UOBJ access failure. </entry>
								</row>
								<row>
									<entry> -1406 </entry>
									<entry> UPROCERR_MEMORY </entry>
									<entry> Memory allocation failure. </entry>
								</row>
								<row>
									<entry> -1407 </entry>
									<entry> UPROCERR_READ_ONLY </entry>
									<entry> Operand is read-only. </entry>
								</row>
								<row>
									<entry> -1408 </entry>
									<entry> UPROCERR_NO_GUI </entry>
									<entry> GUI driver not active. </entry>
								</row>
								<row>
									<entry> -1409 </entry>
									<entry> UPROCERR_INTERACTIVE </entry>
									<entry> Not in interactive mode. </entry>
								</row>
								<row>
									<entry> -1410 </entry>
									<entry> UPROCERR_PROPERTY_VALUE </entry>
									<entry> A property has been assigned an incorrect value.
									</entry>
								</row>
								<row>
									<entry> -1411 </entry>
									<entry> UPROCERR_EDITTWICE </entry>
									<entry> Edit is not allowed in interactive mode. An edit
										statement was encountered when the structure editor was
										already active. This error also occurs when an activate is
										performed on a modal form that is already in edit mode and
										that has an empty Execute trigger (an implicit edit).
									</entry>
								</row>
								<row>
									<entry> -1412</entry>
									<entry> UPROCERR_HANDLE_USAGE </entry>
									<entry> Invalid use of a handle.</entry>
								</row>
								<row>
									<entry> -1413</entry>
									<entry> UPROCERR_ASSIGN_HANDLE_SCOPE </entry>
									<entry> Destination availability scope is too wide.</entry>
								</row>
								<row>
									<entry> -1414</entry>
									<entry> UPROCERR_THREAD_START </entry>
									<entry> Thread start failure.</entry>
								</row>
								<row>
									<entry> -1415</entry>
									<entry> UPROCERR_NODE</entry>
									<entry> Not a valid Node Topic </entry>
								</row>
								<row>
									<entry> -1416</entry>
									<entry> UPROCERR_OBJECT</entry>
									<entry> Specified handle is invalid</entry>
								</row>
								<row>
									<entry> -1498</entry>
									<entry> UPROCERR_OBJECT_NOT_ALLOWED </entry>
									<entry> Handle is not allowed.</entry>
								</row>
								<row>
									<entry> -1499</entry>
									<entry> UPROCERR_OBJECT </entry>
									<entry> The specified handle is not valid.</entry>
								</row>
								<row>
									<entry> -1500 </entry>
									<entry> UXMLERR_DTD_NOTFOUND </entry>
									<entry> A DTD could not be located. </entry>
								</row>
								<row>
									<entry> -1501 </entry>
									<entry> UXMLERR_DTD_INVALID </entry>
									<entry> There is a syntax error in the DTD. </entry>
								</row>
								<row>
									<entry> -1502 </entry>
									<entry> UXMLERR_GENERATION </entry>
									<entry> An error occurred during generation of an XML stream.
									</entry>
								</row>
								<row>
									<entry> -1503 </entry>
									<entry> UXMLERR_PARSE </entry>
									<entry> An error occurred during parsing of an XML stream.
									</entry>
								</row>
								<row>
									<entry> -1504</entry>
									<entry> UXMLERR_VALIDATE </entry>
									<entry> An error occurred during validation of an XML
										stream.</entry>
								</row>
								<row>
									<entry> -1505</entry>
									<entry> UXMLERR_TRANSFORM </entry>
									<entry> An error occurred during transformation of an XML
										stream.</entry>
								</row>
								<row>
									<entry> -1506</entry>
									<entry> UXMLERR_FIELD_NOTAVAIL </entry>
									<entry> A mandatory field is not available in the field list of
										the entity. In the DTD, such fields must be followed by a
										question mark (?).</entry>
								</row>
								<row>
									<entry> -1600</entry>
									<entry> UPROCERR_INLINEMENU_CONTEXT</entry>
									<entry> The function has been used outside the scope of the
										current Predisplay context</entry>
								</row>
								<row>
									<entry> -1601</entry>
									<entry> UPROCERR_INLINEMENU_COMPOMENT</entry>
									<entry> The function has been used in a component. It is allowed
										only in a Predisplay trigger</entry>
								</row>
								<row>
									<entry> -1602</entry>
									<entry> UPROCERR_INLINEMENU_CONTENT </entry>
									<entry> The menu item list has been incorrectly defined.</entry>
								</row>
								<row>
									<entry> -1603</entry>
									<entry> UPROCERR_INLINEMENU_REFMENU</entry>
									<entry> A menu referenced in a cascading menu does not
										exist.</entry>
								</row>
								<row>
									<entry> -1604</entry>
									<entry> UPROCERR_INLINEMENU_ID</entry>
									<entry> Menu item identifier is missing</entry>
								</row>
								<row>
									<entry> -1605</entry>
									<entry> UPROCERR_INLINEMENU_UNIQUE_ID</entry>
									<entry> Menu item identifier is not unique</entry>
								</row>
								<row>
									<entry> -1606</entry>
									<entry> UPROCERR_INLINEMENU_TYPE</entry>
									<entry> Invalid menu item type</entry>
								</row>
								<row>
									<entry> -1607</entry>
									<entry> UPROCERR_OPERATIONNAME</entry>
									<entry> Invalid operation name </entry>
								</row>
								<row>
									<entry> -1700</entry>
									<entry> UUDEERR_UDE_NOT_AVAILABLE</entry>
									<entry> Function is not available at runtime</entry>
								</row>
								<row>
									<entry> -1701 </entry>
									<entry> UUDEERR_OPERATION </entry>
									<entry> Invalid operation name Occurs when the first argument of
										the $ude function is incorrect. </entry>
								</row>
								<row>
									<entry> -1702 </entry>
									<entry> UUDEERR_OPERATION_NOT_ALLOWED </entry>
									<entry> Operation not allowed in combination with Object Occurs
										when the first argument of the $ude function is incorrect.
									</entry>
								</row>
								<row>
									<entry> -1703 </entry>
									<entry> UUDEERR_OBJECTTYPE </entry>
									<entry> Invalid ObjectType Occurs when the second argument of
										the $ude function is incorrect. </entry>
								</row>
								<row>
									<entry> -1704 </entry>
									<entry> UUDEERR_OBJECTTYPE_NOT_ALLOWED </entry>
									<entry> ObjectType is not supported Occurs when the second
										argument of the $ude function is incorrect. </entry>
								</row>
								<row>
									<entry> -1705</entry>
									<entry> UUDEERR_DELETE</entry>
									<entry> Failed to delete </entry>
								</row>
								<row>
									<entry> -1706 </entry>
									<entry> UUDEERR_COMPILE </entry>
									<entry> Failed to compile</entry>
								</row>
								<row>
									<entry> -1707</entry>
									<entry> UUDEERR_CLEANUP</entry>
									<entry> Failed to cleanup </entry>
								</row>
								<row>
									<entry> -1708</entry>
									<entry> UUDEERR_LOOKUP</entry>
									<entry> Failed to find Object </entry>
								</row>
								<row>
									<entry> -1709</entry>
									<entry> UUDEERR_ARGUMENTS</entry>
									<entry> Invalid number of arguments </entry>
								</row>
								<row>
									<entry> -1710</entry>
									<entry> UUDEERR_SETTINGS</entry>
									<entry> Failed to get/set settings </entry>
								</row>
								<row>
									<entry> -1711</entry>
									<entry> UUDEERR_VALIDATE</entry>
									<entry> Failed to validate </entry>
								</row>
								<row>
									<entry> -1712</entry>
									<entry> UUDEERR_DESCRIBE</entry>
									<entry> Failed to describe </entry>
								</row>
								<row>
									<entry> -1713</entry>
									<entry> UUDEERR_DECOMPILE</entry>
									<entry> Failed to decompile </entry>
								</row>
								<row>
									<entry> -1714</entry>
									<entry> UUDEERR_LIST</entry>
									<entry> Failed to list </entry>
								</row>
								<row>
									<entry> -1715 </entry>
									<entry> UUDEERR_TEMPLATE </entry>
									<entry> Failed to find @Template</entry>
								</row>
								<row>
									<entry> -1716</entry>
									<entry> UUDEERR_TEST</entry>
									<entry> Failed to test </entry>
								</row>
								<row>
									<entry> -1717 </entry>
									<entry> UUDEERR_OPERAND </entry>
									<entry> Invalid operand</entry>
								</row>
								<row>
									<entry> -1718 </entry>
									<entry> UUDEERR_COPY </entry>
									<entry> Invalid copy / import / export Occurs when the when the
										copy, import, or export operation failed. </entry>
								</row>
								<row>
									<entry> -1719</entry>
									<entry> UUDEERR_GENHTMLSKELETON</entry>
									<entry> Error generating html skeleton </entry>
								</row>
								<row>
									<entry> -1720 </entry>
									<entry> UUDEERR_GENERAL </entry>
									<entry> Failed to process</entry>
								</row>
								<row>
									<entry> -1721</entry>
									<entry> UPACKERROR_PACKNOTSUPPORT</entry>
									<entry> PackingCode not allowed for this DataType </entry>
								</row>
								<row>
									<entry> -1722</entry>
									<entry> UPACKERROR_NOPACK</entry>
									<entry> Invalid PackingCode </entry>
								</row>
								<row>
									<entry> -1723</entry>
									<entry> UPACKERROR_NODEFAULT</entry>
									<entry> Default does not exist </entry>
								</row>
								<row>
									<entry> -1724</entry>
									<entry> UPACKERROR_PACKRANGE</entry>
									<entry> PackingCode out of range </entry>
								</row>
								<row>
									<entry> -1725</entry>
									<entry> UPACKERROR_INVSCALE</entry>
									<entry> Scaling only allowed for Numeric DataType </entry>
								</row>
								<row>
									<entry> -1726</entry>
									<entry> UPACKERROR_SCALERANGE</entry>
									<entry> Scaling out of range </entry>
								</row>
								<row>
									<entry> -1727</entry>
									<entry> UPACKERROR_SUBFIELD</entry>
									<entry> Invalid subfield declaration</entry>
								</row>
								<row>
									<entry> -1728</entry>
									<entry> UPACKERROR_SIZE</entry>
									<entry> Invalid size</entry>
								</row>
								<row>
									<entry> -1729</entry>
									<entry> UPACKERROR_SUBFIELDRANGE</entry>
									<entry> Subfield does not fit in FixedFieldWidth </entry>
								</row>
								<row>
									<entry> -1730</entry>
									<entry> UPACKERROR_SYNTAX</entry>
									<entry> Unrecognized characters seen </entry>
								</row>
								<row>
									<entry> -1731</entry>
									<entry> UPACKERROR_VARTYPE</entry>
									<entry> Invalid Variable ID</entry>
								</row>
								<row>
									<entry> -1732</entry>
									<entry> UPACKERROR_CHARSET</entry>
									<entry> Invalid Charset </entry>
								</row>
								<row>
									<entry> -1740</entry>
									<entry> ULAYERROR_SYNTAX</entry>
									<entry> Syntax error </entry>
								</row>
								<row>
									<entry> -1741</entry>
									<entry> ULAYERROR_MNEMONIC</entry>
									<entry> Invalid Mnemonic </entry>
								</row>
								<row>
									<entry> -1743</entry>
									<entry> ULAYERROR_PARENTHESIS</entry>
									<entry> Invalid Parenthesis </entry>
								</row>
								<row>
									<entry> -1744</entry>
									<entry> ULAYERROR_NUMBER</entry>
									<entry> Invalid Number </entry>
								</row>
								<row>
									<entry> -1745</entry>
									<entry> ULAYERROR_DISPLAY</entry>
									<entry> Invalid Displayformat </entry>
								</row>
								<row>
									<entry> -1750</entry>
									<entry> USYNERROR_SYNTAX</entry>
									<entry> Syntax error </entry>
								</row>
								<row>
									<entry> -1751</entry>
									<entry> USYNERROR_MNEMONIC</entry>
									<entry> Invalid Mnemonic </entry>
								</row>
								<row>
									<entry> -1752</entry>
									<entry> USYNERROR_PARENTHESIS</entry>
									<entry> Invalid Parenthesis </entry>
								</row>
								<row>
									<entry> -1753</entry>
									<entry> USYNERROR_NUMBER</entry>
									<entry> Invalid Number </entry>
								</row>
								<row>
									<entry> -1754</entry>
									<entry> USYNERROR_COMBINATION</entry>
									<entry> Invalid Combination </entry>
								</row>
								<row>
									<entry> -1755</entry>
									<entry> USYNERROR_ENTRY</entry>
									<entry> Invalid Entryformat </entry>
								</row>
								<row>
									<entry> -1756</entry>
									<entry> USYNERROR_ATTRIBUTES</entry>
									<entry> Bold/Italic/Underline not allowed </entry>
								</row>
								<row>
									<entry> -1760</entry>
									<entry> UMNEMERROR_DRVTYP</entry>
									<entry> Invalid mnemonic drivertype </entry>
								</row>
								<row>
									<entry> -1761</entry>
									<entry> UMNEMERROR_DRVMNEM</entry>
									<entry> Invalid mnemonic drivername </entry>
								</row>
								<row>
									<entry> -1771</entry>
									<entry> UUCBERR_GENERAL</entry>
									<entry> Clipboard general error </entry>
								</row>
								<row>
									<entry> -1772</entry>
									<entry> UUCBERR_NO_DISPLAY</entry>
									<entry> No display driver found </entry>
								</row>
								<row>
									<entry> -1773</entry>
									<entry> UUCBERR_OPEN_FAILED</entry>
									<entry> Failed to open clipboard</entry>
								</row>
								<row>
									<entry> -1774</entry>
									<entry> UUCBERR_FORMAT_NOTSUPPORTED</entry>
									<entry> Data format is not supported </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $procerror returns a value that indicates the reason for an
						error that was reported in $status. Using $status to indicate that an error
						occurred and $procerror to determine the reason for the error allows you to
						write error processing code in a more general manner. The following
						functions are also of use in this situation: </para>
					<itemizedlist>
						<listitem>
							<para>$procerrorcontext to determine the location of the error in your
								Proc code. </para>
						</listitem>
						<listitem>
							<para>$dataerrorcontext to determine the exact location of the error in
								the component's data structure. </para>
						</listitem>
					</itemizedlist>
					<para>The $procerror function is set to 0 at the start of any Proc module (and
						with reset $procerror). It is set to a negative value if an error occurs, as
						follows: </para>
					<itemizedlist>
						<listitem>
							<para>For a simple statement (such as creocc and putitem), $procerror is
								less than 0 and $status is usually less than 0. </para>
						</listitem>
						<listitem>
							<para>For a statement that activates another module (such as activate or
								call), both $procerror and $status are less than 0. (If $status is
								set by Proc code, $procerror remains 0.) </para>
						</listitem>
						<listitem>
							<para>For a statement that causes ‘nested’ activation of triggers (such
								as store and validate), both $procerror and $status are less than 0.
								(If $status is set by Proc code, $procerror is set to
								&lt;UGENERR_4GL_SAYS_ERROR&gt;. ) </para>
						</listitem>
						<listitem>
							<para>For a function, $procerror is less than 0 and $status is usually
								not changed. </para>
						</listitem>
					</itemizedlist>
					<para>If $procerror is set to Value, the description and mnemonic for this value
						can be retrieved from $procerrorcontext. </para>
				</sect2>
				<sect2>
					<title>Example: Error Handling with $procerror </title>
					<para>Symbolic error constant names can be used to create global constants.
						These can be used with $procerror to write generalized and more readable
						error handling routines. For example: </para>
					<programlisting role="uniface"><![CDATA[entry ERRORS
if ($procerror &gt;= 0)
   done
elseif ($procerror = &lt;UIOSERR_LOCKED&gt;)
   askmess "This occurrence is in use elsewhere. Please try later."
elseif ($procerror = &lt;UIOSERR_UPDATE_NOTALLOWED&gt;)
   askmess "You don't have Write permission."
elseif ($procerror = &lt;UGENERR_ERROR&gt;)
   aksmess "Sorry, something's wrong."
else
   aksmess "Problem: %%$status / %%$procerror"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_procerrorcontext">
				<title>$procerrorcontext</title>
				<para>Return the location of the error specified by $procerror. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$procerrorcontext</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Associative list that describes the context in which the error occurred. </para>
					<table>
						<title>Table 1. Associative List Items Returned by $procerrorcontext</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Item</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> ERROR= ErrorValue </entry>
									<entry> The value of $procerror </entry>
								</row>
								<row>
									<entry> MNEM= ErrorConstant </entry>
									<entry> The error constant associated with the current value of
										$procerror </entry>
								</row>
								<row>
									<entry> DESCRIPTION= Text </entry>
									<entry> A brief description of the error </entry>
								</row>
								<row>
									<entry> COMPONENT= CompName </entry>
									<entry> The name of the component in which the error occurred
									</entry>
								</row>
								<row>
									<entry> PROCNAME= ModuleName </entry>
									<entry> The name of the Proc module in which the error occurred,
										that is, the name of the entry, the operation, global Proc,
										or the Y nnn number of the trigger (as shown in the Proc
										listing) </entry>
								</row>
								<row>
									<entry> TRIGGER= TriggerName </entry>
									<entry> The trigger name abbreviation where the error occurred
									</entry>
								</row>
								<row>
									<entry> LINE= LineNumber </entry>
									<entry> The line number (as shown in the Proc listing) at which
										the error occurred </entry>
								</row>
								<row>
									<entry> ADDITIONAL= AssociativeList </entry>
									<entry> An associative list containing additional information
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Additional information is held under the ID ADDITIONAL, in an associative
						list:</para>
					<table>
						<title>Table 2. Associative List Items Under the ADDITIONAL ID of
							$procerrorcontext</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Item</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> MODULENAME= ModuleName </entry>
									<entry> The name of the module upon which a call statement
										failed. </entry>
								</row>
								<row>
									<entry> INSTANCENAME= InstanceName </entry>
									<entry> Name of the target instance on which a newinstance
										statement failed, or name of the instance containing the
										operation on which activate failed. </entry>
								</row>
								<row>
									<entry> OPERATIONNAME= OperationName </entry>
									<entry> The name of the operation upon which an activate
										statement failed. </entry>
								</row>
								<row>
									<entry> COMPONENTNAME= ComponentName </entry>
									<entry> Name of the target component upon which a newinstance
										statement failed. </entry>
								</row>
								<row>
									<entry> COMPONENTID= ComponentID </entry>
									<entry> The component ID of a component on which a newinstance
										statement failed due to a mismatch between unique IDs.
									</entry>
								</row>
								<row>
									<entry> DESCRIPTORID= DescriptorID </entry>
									<entry> The descriptor ID of a component on which a newinstance
										statement failed due to a mismatch between unique IDs.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $procerrorcontext function returns an associative list that describes
						the context of the last validation error that occurred. In certain
						situations, $procerrorcontext also offers additional information identified
						by the ID ADDITIONAL, which is itself an associative list. </para>
				</sect2>
				<sect2>
					<title>Example: Validating Keys and Error Handling </title>
					<para>The following example uses the $curkey function to perform specific
						validation for each key: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Validate Key
selectcase $curkey
   case 1 ;perform validation for the primary key
   ...
   case 2 ;perform validation for candidate key #2
...
   case 4 ;perform validation for candidate key #4
...
   elsecase
      message "Error %%$procerror occurred at %%$procerrorcontext"
      message "Context: %%$dataerrorcontext"
endselectcase ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_procreturncontext">
				<title>$procreturncontext</title>
				<para> Introduced in: U9 </para>
				<para>Return context information about the return value of the previous Proc
					instruction. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$procreturncontext</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>$procreturncontext returns an associative list of items concerning the
						previously-executed $ude or entitycopy instruction.</para>
					<table>
						<title>Table 1. Items Returned by $procreturncontext . An item is ommitted
							if its value is zero or an empty string.</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Item</entry>
									<entry> Description</entry>
									<entry> EntityCopy </entry>
									<entry> UDE Copy </entry>
									<entry> UDE Import </entry>
									<entry> UDE Export </entry>
									<entry> UDE Compile </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Context = Context </entry>
									<entry> Context of the information. Can have the value
										EntityCopy, UDE Copy, UDE Import, UDE Export, or UDE
										Compile. </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> InputRecords = Number </entry>
									<entry> Records to be copied, exported, or imported.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> OutputRecords = Number </entry>
									<entry> Records actually written. </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> SkippedRecords = Number </entry>
									<entry> Records not written due to map file entity mapping to
										&lt;void&gt; </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> WriteErrorsContinues = Number </entry>
									<entry> Write errors encountered that did not stop the copy
										action.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> InputDescriptors= Number </entry>
									<entry> Descriptors to be copied, exported, or imported. The
										same descriptor can occur more than once.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> OutputDescriptors = Number </entry>
									<entry> Signatures actually written. This can be less than the
										number of InputDescriptors if void mappings are
										encountered.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> SkippedDescriptors </entry>
									<entry> Entities mapped to &lt;void&gt; </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
								</row>
								<row>
									<entry> InputTrxFiles = Number </entry>
									<entry> TRX files to copy, if a wildcard was specified.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> InputXmlFiles = Number </entry>
									<entry> XML files to copy, if a wildcard was specified.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> </entry>
									<entry> </entry>
								</row>
								<row>
									<entry> InputSignatures = Number </entry>
									<entry> Signatures found for compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> OutputSignatures = Number </entry>
									<entry> Signatures compiled </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> InputComponents = Number </entry>
									<entry> Components found for compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> OutputComponents = Number </entry>
									<entry> Components compiled </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> InputApplications = Number </entry>
									<entry> Applications found for compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> OutputApplications = Number </entry>
									<entry> Applications compiled </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> InputModels = Number </entry>
									<entry> Models found for compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> OutputModels = Number </entry>
									<entry> Models compiled </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> InputDescriptors = Number </entry>
									<entry> Entities found for compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> OutputDescriptors = Number </entry>
									<entry> Entities compiled </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> InputLibraryItems = Number </entry>
									<entry> Library items found for compilation, such as menus,
										glyphs, global Proc </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> OutputLibraryItems = Number </entry>
									<entry> Library items compiled </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> Infos = Number </entry>
									<entry> Information messages generated during compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> Warnings = Number </entry>
									<entry> Warning messages generated during compilation </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> Errors = Number </entry>
									<entry> Error messages generated during compilation</entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> </entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> Release = ReleaseNumber </entry>
									<entry> Number of the Uniface release of the source
										data.</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
								<row>
									<entry> AdditionalInfo = String </entry>
									<entry> Information in the message frame, structured as a list.
										For details, see <emphasis role="italic"
											>AdditionalInfo</emphasis> below. This item is only
										available if requested by setting the option prcadditional=
										to TRUE. </entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
									<entry> X</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $procreturncontext function provides additional information for Proc
						instructions that are typically involved in batch processing, such as
						copying data. It can be used after entitycopy and $ude.</para>
					<para>$procreturncontext provides information in the form of items. An item is
						ommitted if its value is zero or an empty string. The items Context and
						Release are always present. The item AdditionalInfo is available only if
						specifically requested in the batch Proc instruction. It is useful for error
						handling, because it can return the error numbers and messages encountered
						during processing.</para>
				</sect2>
				<sect2>
					<title>AdditionalInfo</title>
					<para>The AdditionalInfo item is a representation of the information in the
						message frame, which has been structured into a list. The top-level items in
						this list are lists themselves. </para>
					<table>
						<title>Table 2. Top-Level Item Identitiers Available for AdditionalInfo.
							n—number appended to identifier, which corresponds to the sequential
							input number for that item. For example, REC1 means the first input
							record for a copy operation. </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Item</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> INFO </entry>
									<entry> General informational message </entry>
								</row>
								<row>
									<entry> SUMMARY </entry>
									<entry> Item stating how many compilations succeeded, with how
										many info, warnings and errors </entry>
								</row>
								<row>
									<entry> REC n </entry>
									<entry> List of base lists generated during the operation on
										that record </entry>
								</row>
								<row>
									<entry> ENT n </entry>
									<entry> List of base lists generated during the operation on
										that entity descriptor </entry>
								</row>
								<row>
									<entry> SIG n </entry>
									<entry> List of base lists generated during the operation on
										that signature </entry>
								</row>
								<row>
									<entry> COMP n </entry>
									<entry> List of base lists generated during the operation on
										that component </entry>
								</row>
								<row>
									<entry> APP n </entry>
									<entry> List of base lists generated during the operation on
										that application </entry>
								</row>
								<row>
									<entry> MOD n </entry>
									<entry> List of base lists generated during the operation on
										that model </entry>
								</row>
								<row>
									<entry> LIB n </entry>
									<entry> List of base lists generated during the operation on
										that library item such as proc, menu, glyph, and so
										on</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Each base list contains two items—ID and MESSAGE. For example:</para>
					<para>ID=8069;MESSAGE=8069 - Copy failed: Write error on file/table
						'IDF:UFORM.DICT' </para>
					<para>The ID may have value zero, for example: </para>
					<para>ID=0;MESSAGE=SOLID Database Error 10033: Primary key unique constraint
						violation. </para>
					<para>Thus, AdditionalInfo contains three levels of lists—the top-level items,
						the list of base lists, and the base lists themselves.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc handles AdditionalInfo, summarizing information in a
						field called ADDITIONAL.</para>
					<programlisting role="uniface"><![CDATA[getitem/id $AI$, $procreturncontext, "ADDITIONALINFO"
if ($status = 0)
   ADDITIONAL = "AdditionalInfo contains no top level items"
   return
endif
$AITOT$ = $itemcount($AI$)
ADDITIONAL = "Additional contains %%$AITOT$ top level items%%^"
$AICOUNT$ = 0
while ($AICOUNT$ &lt;= $AITOT$)
   $AICOUNT$ = $AICOUNT$ + 1
   getitem $TL$, $AI$, $AICOUNT$
   if ($status = 0)
      break
   endif
   $TLID$ = $idpart($TL$)
   $TLITEM$ = $valuepart($TL$)
   $BASELISTTOT$ = $itemcount($TLITEM$)
   ADDITIONAL = "%%ADDITIONAL%%%Item%%$AICOUNT$ %%$TLID$ contains %%$BASELISTTOT$ base list(s)%%^"
   $BASELISTCOUNT$ = 0
   while ($BASELISTCOUNT$ &lt;= $BASELISTTOT$)
      $BASELISTCOUNT$ = $BASELISTCOUNT$ + 1
      getitem $BASELIST$, $TLITEM$, $BASELISTCOUNT$
      if ($status = 0)
         break
      endif
      ADDITIONAL = "%%ADDITIONAL%%% %%$BASELIST$ %%^"
   endwhile
endwhile
]]></programlisting>
					<para>Given an AdditionalInfo that starts like: </para>
					<programlisting role="uniface"><![CDATA[AdditionalInfo=REC1=ID=0!!!;MESSAGE=I/O function: W, mode: 0, on file/table: UFORM length: 3978!!;ID=0!!!;
MESSAGE=SOLID Database Error 10033: Primary key unique constraint violation.!!;ID=8069!!!;MESSAGE=8069 - Copy failed: 
Write error on file/table 'IDF:UFORM.DICT'.!;INFO=ID=8078!!!;MESSAGE=8078 - Copy from 'c25114.trx' to 'IDF:UFORM.DICT'
.!;REC2=ID=0!!!;MESSAGE=I/O function: W, mode: 0, on file/table: UFORM length: 3988!!;ID=0!!!;MESSAGE=SOLID Database 
Error 10033: Primary key unique constraint violation.!!;ID=8069!!!;MESSAGE=8069 - Copy failed: Write error on 
file/table 'IDF:UFORM.DICT'.!;INFO=ID=8074!!!;MESSAGE=8074 - Copied from 'c25114.trx' to 'IDF:UFORM.DICT' total 
records/rows 0.!;REC3=....]]></programlisting>
					<para>The output is: </para>
					<programlisting role="uniface"><![CDATA[Additional contains 37 top level items
Item1 REC1 contains 3 base list(s)
ID=0;MESSAGE=I/O function: W, mode: 0, on file/table: UFORM length: 3978
ID=0;MESSAGE=SOLID Database Error 10033: Primary key unique constraint violation.
ID=8069;MESSAGE=8069 - Copy failed: Write error on file/table 'IDF:UFORM.DICT'.
Item2 INFO contains 1 base list(s)
ID=8078;MESSAGE=8078 - Copy from 'c25114.trx' to 'IDF:UFORM.DICT'.
Item3 REC2 contains 3 base list(s)
ID=0;MESSAGE=I/O function: W, mode: 0, on file/table: UFORM length: 3988
ID=0;MESSAGE=SOLID Database Error 10033: Primary key unique constraint violation.
ID=8069;MESSAGE=8069 - Copy failed: Write error on file/table 'IDF:UFORM.DICT'.
Item4 INFO contains 1 base list(s)
ID=8074;MESSAGE=8074 - Copied from 'c25114.trx' to 'IDF:UFORM.DICT' total records/rows 0.
Item5 REC3 contains 3 base list(s)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_prompt">
				<title>$prompt</title>
				<para>Return or set the position for the cursor when the current Proc module ends. </para>
				<sect2>
					<title>Syntax</title>
					<para>$prompt </para>
					<para>$prompt = Field </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Field—field name; optional; can be a literal name, a string, or a
						variable, function, parameter or indirect reference to a field. Field can
						optionally contain a qualified field name, for example MYFLD.MYENT. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>String that contains the name of the field where the cursor
									will be positioned when control returns to the structure editor.
									The returned value is Field . Entity . Model; all letters are
									uppercase. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") if the default prompting sequence is in
									effect. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
					<para>$prompt should <emphasis role="italic">not</emphasis> be used in
						I/O-related triggers that set the active path, such as Retrieve, because
						$prompt can change the active path. As a result, the sequence of fired
						triggers will be different from the expected sequence, and some triggers
						will not fire at all, for example Leave Field and Field Gets Focus.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $prompt can be used to define the field where the cursor
						should be positioned when the current Proc module ends. When the name of a
						field is assigned to $prompt, the cursor is positioned at that field when
						control returns to the structure editor. </para>
					<para>When executed, Uniface automatically scrolls to the field where the cursor
						is positioned. If the field has an associated label, Uniface scrolls to show
						the entire field including the associated label. This is especially useful
						in mobile applications in which some fields may not be immediately visible.
						You can disable this automatic scrolling using the $PROMPT_SCROLL assignment
						setting.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The Next Field trigger Proc code below defines conditional field
						prompting. If the invoice date is greater than the system date, the cursor
						goes automatically to the CORRESP entity. Otherwise, the cursor goes to the
						next field in the default prompting sequence. </para>
					<programlisting role="uniface"><![CDATA[; Next Field trigger
if (INVDATE &gt; $date)
   $prompt = TEXT.CORRESP
   message "Invoice is overdue. Write a reminder letter."
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_properties">
				<title>$properties</title>
				<para>Return or set the current widget properties of a field. </para>
				<sect2>
					<title>Syntax</title>
					<para>PropertyValuesList = $properties {( Field{, PropertyList}) } </para>
					<para>$properties {( Field )} = PropertyValuesList </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—field name; optional; can be a literal name, a string,
									or a variable, function, parameter or indirect reference to a
									field. Field can optionally contain a qualified field name, for
									example, MYFLD.MYENT. If omitted, the current field is used.
								</para>
							</listitem>
							<listitem>
								<para>PropertyList—list of widget property names, separated by GOLD
									; ( <emphasis role="underline">;</emphasis> ); can be a string,
									or a variable, function, or parameter that evaluates to a
									string, or a field (or indirect reference to a field) </para>
							</listitem>
							<listitem>
								<para>PropertyValuesList—associative list of Property=PropertyValue
									pairs (separated by GOLD ; ), where PropertyValue is the value
									to be assigned to the property identified by Property. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Associative list containing the widget properties that have
									been changed from the default widget properties for the
									specified field. </para>
							</listitem>
							<listitem>
								<para>Empty string ("") if: <itemizedlist>
										<listitem>
											<para>Default properties have not been changed (in the
												Define Properties form or with $properties). </para>
										</listitem>
										<listitem>
											<para>An error occurred. $procerror contains a negative
												value that identifies the exact error. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Values of $procerror commonly returned by
								$properties</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, report, and server page components (and in service
						components that are not self-contained)</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Widget properties can be modified from the default values by setting them
						in the Define Properties form or by using $properties. </para>
					<para>If a widget's default properties are changed using the Define Properties
						form, the altered properties are returned in $properties. The default
						properties are not available. </para>
					<para>The properties set with $properties: </para>
					<itemizedlist>
						<listitem>
							<para>Override <emphasis role="italic">all</emphasis> the properties
								that have been set in the Define Properties form or with a previous
								$properties assignment. Omitting a property causes that property to
								be reset. </para>
						</listitem>
						<listitem>
							<para>Are reset to the compiled values (that is, the default properties
								plus the properties set with in the Define Properties form) each
								time that a component (with the component property Keep Data in
								Memory cleared) is restarted. </para>
						</listitem>
						<listitem>
							<para>Can be overridden for the field in a single occurrence by using
								$fieldproperties. </para>
						</listitem>
					</itemizedlist>
					<para>At run time, up until the time that the form is presented to the user
						(with edit or display), all the properties associated with a widget can be
						changed. After this point, only the widget's <emphasis role="italic"
							>dynamic</emphasis> properties can be changed. </para>
					<para>When changing widget properties, keep in mind that these properties
						sometimes interact with each other. For example, for an edit box in
						Microsoft Windows, setting WordWrap=True has an effect only if
						MultiLine=True and HScroll=False. </para>
				</sect2>
				<sect2>
					<title>$properties in a Web application</title>
					<para>Style references are stored as property values in the Repository, and can
						be manipulated with $properties and $fieldproperties. For dynamic changes to
						the look and feel of style attributes, use the field-level subclass
						property, which is checked at run time and propagated through the generated
						HTML. The subclass property uses predefined style references from the
						Cascading Style Sheet (CSS) used by the Web application. The syntax used by
						$properties is: </para>
					<para>$properties( Field )="subclass= MyClass " </para>
					<para>where MyClass is a predefined style class in the application’s CSS. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The syntax of $properties <emphasis
							role="italic">must not</emphasis> include spaces. </para>
				</sect2>
				<sect2>
					<title>Example: Changing Font and Alignment</title>
					<para>The following example alters the font name used for the label associated
						with the radio group GENDER, and makes the representation appear to the left
						of the button: </para>
					<programlisting role="uniface"><![CDATA[; Execute trigger
$properties(GENDER) = "LabelFont=font10;Align=left"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_dollar_putmess">
				<title>$putmess</title>
				<para>Return or set the contents of the message frame. </para>
				<sect2>
					<title>Syntax</title>
					<para> $putmess {= String} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>String—string containing the message content, or a null string (""). </para>
					<itemizedlist>
						<listitem>
							<para>If String is assigned, the message frame is cleared and set to
								contain the contents of String. </para>
						</listitem>
						<listitem>
							<para>If a null string is assigned, the message frame is cleared.
							</para>
						</listitem>
						<listitem>
							<para>If omitted, the message frame is not cleared. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Contents of the message frame. </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if the message frame has been cleared.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in forms and server pages, and in service and report components
						that are not self-contained. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>What you can do with the contents of the message frame depends on the
						environment of the running component, for example:</para>
					<itemizedlist>
						<listitem>
							<para>In a component running locally, you can use $putmess output as you
								see fit </para>
						</listitem>
						<listitem>
							<para>In a remote component (that is, a service or report running on an
								Application Server, exclusive or shared), the Application Server
								will redirect the contents of the component's message frame to the
								server's logfile (see the assignment setting $PUTMESS_LOGFILE). </para>
							<para>This is <emphasis role="italic">not</emphasis> the case for a
								Database Server or File Server, which return server messages back to
								the client. </para>
						</listitem>
						<listitem>
							<para>You can also return $putmess to the client as an OUT parameter
								from a remote component, as shown in the example. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Using $putmess in Server Pages</title>
					<para>In a server page, $putmess inserts the content of the message frame into
						the generated HTML page. This is done by specifying the function type in the
						&lt;X_SUBST&gt; tag in the following way: </para>
					<para>&lt;PRE&gt;&lt;X_SUBST type=function
						name=$putmess&gt;$putmess&lt;/X_SUBST&gt;&lt;/PRE&gt; </para>
					<para>In a Web application, $putmess also contains trace information from the
						debug statement, if specified in the application. </para>
				</sect2>
				<sect2>
					<title>Example: Assigning Message Frame Contents to Variable </title>
					<para> The following example, from a component running locally, assigns the
						content of the message frame to the global variable RETRIEVEDETAILS.
						<programlisting role="uniface"><![CDATA[; Retrieve trigger
retrieve
if ($status &lt; 0)
message $text(1762) ;error
endif
$$RETRIEVEDETAILS = $putmess ]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Example: Returning Message Frame Contents as a Parameter</title>
					<para>The following example, from a service component running remotely, assigns
						the content of the message frame to an output parameter for processing by
						the client. </para>
					<programlisting role="uniface"><![CDATA[; Operations trigger of service component SVC1
operation TEST_RETRIEVE
params
   string pKey : IN
   string pPutmess : OUT
endparams
clrmess
putmess "Start of service &lt;$componentname&gt;"
CUST_ID/init = pKey
retrieve
if ($status &lt; 0)
   putmess " Retrieve failed"
   putmess " $procerror = %%$procerror"
   putmess " %%$procerrorcontext"
endif
putmess "End of service &lt;$componentname&gt;"
pPutmess = $putmess
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_relation">
				<title>$relation</title>
				<para>Return the related key field. </para>
				<sect2>
					<title>Syntax</title>
					<para> $relation{( Field )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field name; optional; can be a literal nam, a string, or a
						variable, function, parameter or indirect reference to a field. Field can
						optionally contain a qualified field name, for example, MYFLD.MYENT. If
						omitted, the current field is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Name of the related primary or foreign key field. The value
									returned depends on where the entities occur in the component
									data structure. </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if the specified field is not part of a
									related primary or foreign key. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $relation can be used to find the name of the key field that
						is related to the specified field when a one-to-many relationship exists
						between two painted entities. </para>
					<para>The use of $relation depends upon where the entities occur in the data
						structure: </para>
					<itemizedlist>
						<listitem>
							<para>If the specified field is part of the foreign key of an inner,
								many entity, $relation returns the name of the primary key field
								corresponding to that foreign key field. </para>
						</listitem>
						<listitem>
							<para>If the specified fieldis part of the foreign key of an outer, many
								entity, $relation returns the name of the primary key field
								corresponding to that foreign key field. </para>
							<para>If two or more painted entities are related to the outer entity
								via the same foreign key, the first one entity painted (as viewed
								left-to-right, top-to-bottom) is the one considered by $relation.
							</para>
						</listitem>
						<listitem>
							<para>If the specified field is part of the primary key of an inner, one
								entity, $relation returns the name of the foreign key field
								corresponding to that primary key field. </para>
						</listitem>
						<listitem>
							<para>In all other cases, $relation returns an empty string ("").
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The figure below illustrates an up relationship painted between the one
						entity OWNER and many entity HORSE: </para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/fig14_3.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
					<para> $relation can be used to obtain one of the following: </para>
					<itemizedlist>
						<listitem>
							<para> The name of the primary key field (in entity OWNER) that is
								related to the foreign key field HORSE_OWNER_NAME (in entity HORSE).
							</para>
						</listitem>
						<listitem>
							<para> The name of the foreign key field (in entity HORSE) that is
								related to the primary key field OWNER_HORSE in entity (OWNER).
							</para>
						</listitem>
					</itemizedlist>
					<para> This is illustrated in the following example: </para>
					<programlisting role="uniface"><![CDATA[$1 = $relation(HORSE_OWNER_NAME.HORSE)
; $1 is "OWNER_NAME.OWNER.TRACKER"
$2 = $relation(OWNER_NAME.OWNER)
; $2 is "HORSE_OWNER_NAME.HORSE.TRACKER"
$3 = $relation(HORSE_AGE.HORSE)
; $3 is ""
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_replace">
				<title>$replace</title>
				<para> Introduced in: U8 </para>
				<para>Replace substrings of strings. </para>
				<sect2>
					<title>Syntax</title>
					<para> $replace ( Source , StartPos , SearchFor , ReplaceWith{, Count}) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Source—string on which the replacement needs to be done.
								</para>
							</listitem>
							<listitem>
								<para>StartPos—position in Source where the replacement needs to
									start. </para>
							</listitem>
							<listitem>
								<para>SearchFor—substring to search for. SearchFor can be a constant
									string or a syntax string. </para>
							</listitem>
							<listitem>
								<para>ReplaceWith—substitute for the substring. </para>
							</listitem>
							<listitem>
								<para>Count—number of occurrences of the substring that should be
									replaced. If omitted, only the first occurrence of the substring
									is replaced. If Count is -1, all occurrences are replaced.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String with the replacements made. </para>
					<para>If ReplaceWith is empty, $replace returns the unaltered Source string and
						an error in $procerror. </para>
					<table>
						<title>Table 1. Values Commonly Returned by $procerror Following
							$replace</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error Constnat</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1118</entry>
									<entry> &lt;UPROCERR_ARGUMENT&gt;</entry>
									<entry> The argument specified is incorrect. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$1 = $replace("a should be uppercase", 1, "a", "A", -1)
; $1 now contains "A should be uppercAse"
; Every lowercase a is replaced with an uppercase A
$1 = $replace("a should be replaced by B", 1, "a", "B")
; $1 now contains "B should be replaced by B"
; Only the first "a" is replaced by "B"
]]></programlisting>
					</para>
				</sect2>
				<sect2>
					<title>Example: Operation GETXMLITEM</title>
					<para>This operation calls an XSLT stylesheet and returns the value of a node in
						an XML stream. The parameters can specify one node or several nodes. </para>
					<para>GETXMLITEM uses $replace to insert parameters XNODE and XVALUE into an
						XSLT stylesheet, and uses component USYSXSLT to process the XSLT stylesheet.
						For more information about the XSLT stylesheet used by this operation, and
						examples of input and output data, see USYSXSLT. </para>
					<programlisting role="uniface"><![CDATA[operation GETXMLITEM
; Get an item or set of items from an XML stream
; using XPATH patterns.
; Modify an XSLT stylesheet using the $replace
; function, and then activate USYSXSLT.
params
   numeric I_STATUS : OUT
   string I_STATUSCONTEXT : OUT
   string I_XML : IN
   string XNODE : IN
   string XVALUE : IN
   string I_VALUE : OUT
endparams
variables
   string XSLTFILE
endvariables
fileload "getitem.xsl", XSLTFILE
XSLTFILE = $replace(XSLTFILE, 1, "TargetNode", XNODE)
XSLTFILE = $replace(XSLTFILE, 1, "TargetValue", XVALUE)
filedump XSLTFILE, "getitemtemp.xsl"
activate "USYSXSLT".XMLTRANSFORM(I_XML, "getitemtemp.xsl", " ", I_VALUE, I_STATUS, I_STATUSCONTEXT)
end ; operation GETXMLITEM]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_result">
				<title>$result</title>
				<para>Return the result of certain Proc statements and tree widget events. </para>
				<sect2>
					<title>Syntax</title>
					<para>$result </para>
					<para>$result = Expression </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The $result functionis set by many Proc statements and by tree widget
						events. For the values $result can contain, see the documentation for the
						individual Proc statements. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>$result is allowed in form, service, and report components. </para>
					<para>$result = Expression is allowed in form components (and in service and
						report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$result receives the result of several Proc statements and tree widget
						events. For example: </para>
					<itemizedlist>
						<listitem>
							<para>First column of the last selected occurrence when a SELECT
								statement is included in an sql statement. </para>
						</listitem>
						<listitem>
							<para>Unique number generated by the numgen statement. </para>
						</listitem>
						<listitem>
							<para>Status of comparison made with the compare statement. </para>
						</listitem>
						<listitem>
							<para>Status of actions performed with $ude </para>
						</listitem>
					</itemizedlist>
					<para>In the debugger, $result can be accessed directly or as variable $101.
					</para>
				</sect2>
				<sect2>
					<title>Example: Generating and Retrieving Unique Sequence Numbers </title>
					<para>The following example uses the numgen statement to generate unique
						sequence numbers for a record. This unique number is accessible via $result. </para>
					<programlisting role="uniface"><![CDATA[; Execute trigger
numgen "INVOICE_NUMBER", 1, $variation
if ($status &lt; 0)
   message "Error generating sequence number."
   edit SEQNO
else
   SEQNO = $result
   edit NAME
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_rettype">
				<title>$rettype</title>
				<para>Return the retrieval mode of the outermost entity. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$rettype</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $rettype</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Trigger </entry>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> ""</entry>
										<entry> An error occured. $procerror contains a negative
											value that identifies the exact error.</entry>
									</row>
									<row>
										<entry> Add/Insert Occurrence </entry>
										<entry> 65 </entry>
										<entry> Add occurrence </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> 73 </entry>
										<entry> Insert occurrence </entry>
									</row>
									<row>
										<entry> Read </entry>
										<entry> 78 </entry>
										<entry> Next occurrence </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> 82 </entry>
										<entry> Retrieve </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> 110 </entry>
										<entry> Retrieve sequential </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$rettype</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1304 </entry>
										<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
										<entry> Function not allowed, unknown context. For example,
											$rettype was encountered outside the Add/Insert
											Occurrence and Read triggers. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $rettype returns the retrieval mode of the outermost entity.
						It should be used only in the Add/Insert Occurrence or the Read trigger. </para>
					<para>The following events set $rettype: </para>
					<itemizedlist>
						<listitem>
							<para>^ADD_OCC </para>
						</listitem>
						<listitem>
							<para>^INS_OCC </para>
						</listitem>
						<listitem>
							<para>read </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Imitating Uniface Default Behavior</title>
					<para>You can use retrieval mode values to mimic the default behavior of
						Uniface, and add additional code to set default values for fields in the
						created occurrence. </para>
					<programlisting role="uniface"><![CDATA[; Add/Insert Occurrence trigger
if ($rettype = 65)
   creocc "INVOICE", $curocc + 1
else
   creocc "INVOICE", $curocc - 1
endif
numgen "INV_COUNT", 1, $variation
INV_NUM/init = $result ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_rscan">
				<title>$rscan</title>
				<para> Introduced in: U9 </para>
				<para>Find a substring within a string, starting from the end of the string. </para>
				<sect2>
					<title>Syntax</title>
					<para> $rscan ( Source , SearchFor ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Source—string in which the substring needs to be found. </para>
						</listitem>
						<listitem>
							<para>SearchFor—substring to search for. SearchFor can be a constant
								string or a syntax string. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Position of the substring within the string. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example finds the literal string quick in the source string. </para>
					<programlisting role="uniface"><![CDATA[
OUTPUT = $rscan ("The quick brown fox", "quick")
; OUTPUT = 5
]]></programlisting>
					<para> The following example finds a number (using the syntax string "#") in the
						source string. </para>
					<programlisting role="uniface"><![CDATA[vOutput = $scan ("The quick brown fox is 2nd.", $syntax(#))]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_rtrim">
				<title>$rtrim</title>
				<para> Introduced in: U8 </para>
				<para>Right trim a string following a pattern. </para>
				<sect2>
					<title>Syntax</title>
					<para> $rtrim ( Source , Pattern ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Source—string to be right trimmed. </para>
							</listitem>
							<listitem>
								<para>Pattern—pattern to remove. It can be a constant string or a
									Syntax Strings for Pattern Matching. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Trimmed string. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $rtrim function is used to right trim a string following a pattern.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$1="UNIFACExxxx"
$2 = $rtrim($1,"x")
; $2 now contains "UNIFACE" ]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_runmode">
				<title>$runmode</title>
				<para>Return an indication of how the form was started. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$runmode</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $runmode</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry>
											<para>The form can be used for all I/O purposes.
												<emphasis role="italic">All </emphasis>of these
												conditions are met: </para>
											<itemizedlist>
												<listitem>
												<para>The form became active with an edit statement.<footnote>
												<para>When the Execute trigger is empty, Uniface
												behaves as if an edit statement were
												present</para>
												</footnote>
												</para>
												</listitem>
												<listitem>
												<para>The form is not a Limited form. </para>
												</listitem>
												<listitem>
												<para>The form was started by one of these
												methods: <itemizedlist>
												<listitem>
												<para>With a run statement used without a /display
												or /query switch. </para>
												</listitem>
												<listitem>
												<para>With a newinstance statement used with the
												component instance properties DISPLAY=FALSE and
												QUERY=FALSE. </para>
												</listitem>
												<listitem>
												<para>With an activate statement (resulting in an
												implicit newinstance). </para>
												</listitem>
												</itemizedlist></para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry>
											<para>The form can be used only for query purposes.
												<emphasis role="italic">All </emphasis>of these
												conditions are met: </para>
											<itemizedlist>
												<listitem>
												<para>The form became active with an
												<command>edit</command> statement. </para>
												</listitem>
												<listitem>
												<para>The form is a Limited form or the form was
												started by one of these methods: <itemizedlist>
												<listitem>
												<para>With a run/query statement. </para>
												</listitem>
												<listitem>
												<para>With a newinstance statement used with the
												component instance property QUERY=TRUE. </para>
												</listitem>
												</itemizedlist></para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
									<row>
										<entry> 2 </entry>
										<entry>
											<para>The form is display-only. <emphasis role="italic"
												>One </emphasis>of these conditions is met:</para>
											<itemizedlist>
												<listitem>
												<para>The form was started with a run/display
												statement. </para>
												</listitem>
												<listitem>
												<para>The form was started with a newinstance
												statement used with the component instance
												property DISPLAY=TRUE. </para>
												</listitem>
												<listitem>
												<para>The form became active with a display
												statement. </para>
												</listitem>
											</itemizedlist>
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $runmode function returns a value that indicates how the form was
						started. This also indicates how the form can be used to affect data.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In this example, $runmode is used to inform the user as to whether the
						form is editable or read-only. </para>
					<programlisting role="uniface"><![CDATA[; Execute trigger
selectcase $runmode
   case 0
   message/info "This form is editable"
elsecase
   message/info "This form is not editable"
   endselectcase
edit]]></programlisting>
					<para> </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_scan">
				<title>$scan</title>
				<para> Introduced in: U8 </para>
				<para>Find a substring within a string. </para>
				<sect2>
					<title>Syntax</title>
					<para> $scan ( Source , SearchFor ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Source—string in which the substring needs to be found. </para>
						</listitem>
						<listitem>
							<para>SearchFor—substring to search for. SearchFor can be a constant
								string or a syntax string. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Position of the substring within the string. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $scan function is used to find a substring within a string. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example finds the first occurrence of literal o in the
						source string. </para>
					<programlisting role="uniface"><![CDATA[vOutput = $scan("look for o", "o")
; vOutput = 2]]></programlisting>
					<para>The following example finds a number (using the syntax string "#") in the
						source string. </para>
					<programlisting role="uniface"><![CDATA[vOutput = $scan ("The quick brown fox is 2nd.", $syntax(#))]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_selblk">
				<title>$selblk</title>
				<para>Return or set the contents of the select buffer. </para>
				<sect2>
					<title>Syntax</title>
					<para>$selblk </para>
					<para>$selblk = String </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>String—expression that evaluates to a String value. The new data
						overwrites any previous contents of the buffer. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The function $selblk returns the current contents of the structure editor
						select buffer. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$selblk accesses the current contents of the save and remove buffer of the
						structure editor. This buffer contains text that can be accessed using
						structure editor functions. </para>
					<para>Data is moved from a field to $selblk by the following structure editor
						functions: </para>
					<itemizedlist>
						<listitem>
							<para>^REM_SELECT </para>
						</listitem>
						<listitem>
							<para>^REM_FIELD </para>
						</listitem>
						<listitem>
							<para>^SAVE </para>
						</listitem>
					</itemizedlist>
					<para>Data is moved from $selblk to a field by the following structure editor
						functions: </para>
					<itemizedlist>
						<listitem>
							<para>^INS_SELECT </para>
						</listitem>
						<listitem>
							<para>^INS_FIELD </para>
						</listitem>
					</itemizedlist>
					<para>Whenever data is sent or assigned to $selblk, the new data overwrites any
						previous contents of the buffer. </para>
					<para>In the Debugger, $selblk can be accessed directly or as variable $102.
					</para>
				</sect2>
				<sect2>
					<title>Example: Copying Contents of Message Frame to Time-Stamped File</title>
					<para>The following example uses the macro statement to copy the contents of the
						message frame into $selblk. The contents of $selblk are then dumped to a
						time-stamped file. The Proc code to do this is in a single form, which can
						be run at any time during the application, or once the application has
						ended. </para>
					<para>This approach ensures that the structure editor is always activated, and
						that the functions stored in the keyboard input buffer by the macro
						statement are never ignored. The form contains a single dummy field; this is
						all that is required for a successful edit session. The form uses component
						variables, so the form can be used without fear of overwriting general
						variables ($1-$99). </para>
					<programlisting role="uniface"><![CDATA[; Execute trigger
: Start structure editor
edit DUMMY_FIELD
; Occurrence Gets Focus trigger
; note the space at the end of the macro
; string. This ensures that the Start Modification
; trigger is activated
macro "^MESSAGE^SELECT^TEXT^SAVE^ACCEPT "
; Start Modification trigger (of DUMMY_FIELD)
$TIME_NOW$ = $clock
$MINUTES$ = $TIME_NOW$[n]
$SECONDS$ = $TIME_NOW$[s]
$HOURS$ = $TIME_NOW$[H]
filedump $selblk,"MF%%$HOURS$_%%$minutes$.%%$SECONDS$"
exit (1) ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_selectlist">
				<title>$selectlist</title>
				<para>Return or set the select list for an entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> $selectlist ( Entity ) {= SelectList} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="italic">Entity </emphasis>—entity name; can be
									a literal name, string, variable, function, parameter, or
									indirect reference to a field. If omitted, the current entity is
									used. </para>
							</listitem>
							<listitem>
								<para>SelectList—indexed list that contains field names to be
									included. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Indexed list of all field names in the select list of Entity. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error.</para>
					<table>
						<title>Table 1. Values of $procerror commonly returned after
							$selectlist</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> An incorrect entity name was provided; either the entity
										name is not valid syntactically or the entity is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in entity service components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>If $selectlist is used within an expression, it returns the select list of
						Entity as an indexed list of unqualified field names. </para>
					<para>When you set a select list, Uniface automatically includes key fields in
						the select list whether or not they are included in SelectList. However, if
						the entity related to the foreign key is not painted on the component, it is
						excluded from the select list. Non-database fields included in the
						SelectList are ignored. For more information on select lists, see <emphasis
							role="italic">Lists of items </emphasis>. </para>
				</sect2>
				<sect2>
					<title>Example: Setting and Displaying a Select List </title>
					<para>The following example sets the select list of the entity, PERSON, and
						displays the list in a message: </para>
					<programlisting role="uniface"><![CDATA[$selectlist (PERSON) = "NAME;ADDRESS"
if ($procerror = 0)
   retrieve
   putmess "The following fields have been retrieved:"
   putmess $selectlist
else
   message/error "Name and/or address cannot be retrieved."
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_sin">
				<title>$sin</title>
				<para> Introduced in: U8 </para>
				<para>Return the sine of X. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$sin</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—angle in radians or a field (or indirect reference to a field), a
						variable, or a function or expression which evaluates to an angle in
						radians. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Sine of X </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the sine of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$sinePiR$ = $sin($pi() * RADIANS)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_sortlist">
				<title>$sortlist</title>
				<para> Introduced in: U9 </para>
				<para>Sort an associative list, an indexed list, or an indexed list of sublists. </para>
				<sect2>
					<title>Syntax</title>
					<para>$sortlist ( List{, SortElement : SortOptions {<emphasis role="underline"
							>;</emphasis> SortElement : SortOptions}} ) </para>
					<para>Syntax of SortOptions: </para>
					<para>Order} {Unique} {Type} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List—field or variable that evaluates to a string containing
									an associative list of items. The current value of List is
									replaced by a list with the same items sorted by the
									representation. </para>
							</listitem>
							<listitem>
								<para>SortElement—element of an associative list, or a sublist
									element, on which to sort <itemizedlist>
										<listitem>
											<para>$idpart—sort on the IdPart of an associative list
											</para>
										</listitem>
										<listitem>
											<para>$valuepart—sort on the ValuePart of an associative
												list </para>
										</listitem>
										<listitem>
											<para>$string( SublistItemId ) </para>
										</listitem>
										<listitem>
											<para>SublistItemNr—sort on the sequence number of an
												indexed sublist </para>
										</listitem>
										<listitem>
											<para>SublistItemId—sort on the IdPart of an associative
												sublist </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>SortOptions—comma-separated or GOLD ; separated list of sort
									options; can be a string, or a field (or indirect reference to a
									field), a variable, or a function that evaluates to a string.
									All sort options are optional. After the SortElement, they can
									be defined in any order. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Sort Options</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Sort Option</entry>
										<entry> Meaning</entry>
										<entry> Valid Values</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> Ordering </entry>
										<entry> Sort order</entry>
										<entry> ascending | A descending | D </entry>
									</row>
									<row>
										<entry> Unique </entry>
										<entry> Keep only unique items; discard duplicates</entry>
										<entry> unique | U </entry>
									</row>
									<row>
										<entry> Type </entry>
										<entry> Sort the data as a specified data type, or apply
											locale-based sorting conventions. It is also possible to
											specify case-insensitive sorting or level-based sorting.
											If not specified, the value of $nlssortorder is used. If
											this is not set, the value of $nlslocale is used. If
											this is not set, a binary sort is performed.</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort using the value of $nlslocale, as set by the
											$NLS_LOCALE assignment setting or $nlslocale Proc
											function.</entry>
										<entry> nlslocale | NLS </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort as a case-sensitive string, ignoring
											locale-based sorting conventions</entry>
										<entry> classic | CaseSensitive | CS |</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort as a case-insensitive string, using the 1-to-1
											character matching for Unicode uppercase and lowercase
											rules.</entry>
										<entry> CaseInsensitive | CI </entry>
									</row>
									<row>
										<entry/>
										<entry> Sort data as level ID (n.n.n), so that 9.2 is sorted
											before 10.1 </entry>
										<entry> level </entry>
									</row>
									<row>
										<entry> </entry>
										<entry>
											<emphasis role="bold"> Note:</emphasis> When specifying
											the following sort options, it is assumed the data is in
											a format that can be interpreted as the specified data
											type:</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Numeric</entry>
										<entry> Numeric </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Float</entry>
										<entry> Float </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Boolean</entry>
										<entry> Boolean </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Date</entry>
										<entry> Date </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Time</entry>
										<entry> Time </entry>
									</row>
									<row>
										<entry> </entry>
										<entry>
											<emphasis role="bold"> Note:</emphasis> When specifying
											the following sort options, Uniface converts the data to
											the specified data type before sorting:</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $number ( String ) </entry>
										<entry> $number </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $float ( String ) </entry>
										<entry> $float </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $boolean ( String ) </entry>
										<entry> $boolean </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $date ( String ) </entry>
										<entry> $date </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $clock ( String ) </entry>
										<entry> $time </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $datim ( String ) </entry>
										<entry> $datim </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as string ( String ) </entry>
										<entry> $string </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the sorted list.</para>
					<table>
						<title>Table 2. Sort List Errors Commonly Returned in $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Error</entry>
									<entry> Error Constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1112 </entry>
									<entry> UPROCERR_OPTION</entry>
									<entry> SortOption: Ascending assumed: When an option starts
										with an "A" and is not "A" / "ASC" / "ASCENDING"</entry>
								</row>
								<row>
									<entry> SortOption: Descending assumed: When an option starts
										with an "D" and is not "D" / "DESC" / "DESCENDING"</entry>
								</row>
								<row>
									<entry> SortOption: Unique assumed: When an option starts with
										an "U" and is not "U" / "UNI" / "UNIQUE"</entry>
								</row>
								<row>
									<entry> SortOption: Invalid option: When an option can't be
										recognized</entry>
								</row>
								<row>
									<entry> SortOption: Duplicate order: When an Ascending is
										defined over a Descending v.v.</entry>
								</row>
								<row>
									<entry> SortOption: Duplicate type: When a DataType or $Typing
										is defined twice.</entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> SortOption: Field does not exist For sort "entity" when
										a fieldname is wrong or excluded </entry>
								</row>
								<row>
									<entry> -1129 </entry>
									<entry> UPROCERR_ITEM</entry>
									<entry> SortOption: SubItemId does not exist</entry>
								</row>
								<row>
									<entry> SortOption: SubItemNr does not exist</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>By default, $sortlist sorts on the value part of a list item, in ascending
						order. Uniface sorts in binary order, but you can apply locale-based sorting
						using $nlssortorder. For more information see Sorting Based on
						Locale.</para>
					<para>For information on sorting lists using the sort options, see Sorting
						Entities and Lists.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[vColors = "1=GREEN;0=RED;3=BLUE"
vResult = $SortList(vColors, "$idpart: ascending")
;vResult = "0=RED;1=GREEN;3=BLUE"
vResult = $SortList(vColors, "$valuepPart: ascending")
;vResult = "3=BLUE;1=GREEN;0=RED"]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_sortlistid">
				<title>$sortlistid</title>
				<para> Introduced in: U9 </para>
				<para>Sort an associative list in which the value part of each list item is an
					indexed list.</para>
				<sect2>
					<title>Syntax</title>
					<para>$sortlistid ( List{, SortElement : SortOptions {<emphasis role="underline"
							>;</emphasis> SortElement : SortOptions}} ) </para>
					<para>Syntax of SortOptions: </para>
					<para>Order} {Unique} {Type} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List—field or variable that evaluates to a string containing
									an associative list of items. The current value of List is
									replaced by a list with the same items sorted by the
									representation. </para>
							</listitem>
							<listitem>
								<para>SortElement—element of an associative list, or a sublist
									element, on which to sort <itemizedlist>
										<listitem>
											<para>$idpart—sort on the IdPart of an associative list
											</para>
										</listitem>
										<listitem>
											<para>$valuepart—sort on the ValuePart of an associative
												list </para>
										</listitem>
										<listitem>
											<para>$string( SublistItemId ) </para>
										</listitem>
										<listitem>
											<para>SublistItemNr—sort on the sequence number of an
												indexed sublist </para>
										</listitem>
										<listitem>
											<para>SublistItemId—sort on the IdPart of an associative
												sublist </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>SortOptions—comma-separated or GOLD ; separated list of sort
									options; can be a string, or a field (or indirect reference to a
									field), a variable, or a function that evaluates to a string.
									All sort options are optional. After the SortElement, they can
									be defined in any order. </para>
							</listitem>
						</itemizedlist>
						<table>
							<title>Table 1. Sort Options</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Sort Option</entry>
										<entry> Meaning</entry>
										<entry> Valid Values</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> Ordering </entry>
										<entry> Sort order</entry>
										<entry> ascending | A descending | D </entry>
									</row>
									<row>
										<entry> Unique </entry>
										<entry> Keep only unique items; discard duplicates</entry>
										<entry> unique | U </entry>
									</row>
									<row>
										<entry> Type </entry>
										<entry> Sort the data as a specified data type, or apply
											locale-based sorting conventions. It is also possible to
											specify case-insensitive sorting or level-based sorting.
											If not specified, the value of $nlssortorder is used. If
											this is not set, the value of $nlslocale is used. If
											this is not set, a binary sort is performed.</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort using the value of $nlslocale, as set by the
											$NLS_LOCALE assignment setting or $nlslocale Proc
											function.</entry>
										<entry> nlslocale | NLS </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort as a case-sensitive string, ignoring
											locale-based sorting conventions</entry>
										<entry> classic | CaseSensitive | CS |</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort as a case-insensitive string, using the 1-to-1
											character matching for Unicode uppercase and lowercase
											rules.</entry>
										<entry> CaseInsensitive | CI </entry>
									</row>
									<row>
										<entry/>
										<entry> Sort data as level ID (n.n.n), so that 9.2 is sorted
											before 10.1 </entry>
										<entry> level </entry>
									</row>
									<row>
										<entry> </entry>
										<entry>
											<emphasis role="bold"> Note:</emphasis> When specifying
											the following sort options, it is assumed the data is in
											a format that can be interpreted as the specified data
											type:</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Numeric</entry>
										<entry> Numeric </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Float</entry>
										<entry> Float </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Boolean</entry>
										<entry> Boolean </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Date</entry>
										<entry> Date </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort data as Time</entry>
										<entry> Time </entry>
									</row>
									<row>
										<entry> </entry>
										<entry>
											<emphasis role="bold"> Note:</emphasis> When specifying
											the following sort options, Uniface converts the data to
											the specified data type before sorting:</entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $number ( String ) </entry>
										<entry> $number </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $float ( String ) </entry>
										<entry> $float </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $boolean ( String ) </entry>
										<entry> $boolean </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $date ( String ) </entry>
										<entry> $date </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $clock ( String ) </entry>
										<entry> $time </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as $datim ( String ) </entry>
										<entry> $datim </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> Sort Data as string ( String ) </entry>
										<entry> $string </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the sorted list.</para>
					<table>
						<title>Table 2. Sort List Errors Commonly Returned in $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Error</entry>
									<entry> Error Constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1112 </entry>
									<entry> UPROCERR_OPTION</entry>
									<entry> SortOption: Ascending assumed: When an option starts
										with an "A" and is not "A" / "ASC" / "ASCENDING"</entry>
								</row>
								<row>
									<entry> SortOption: Descending assumed: When an option starts
										with an "D" and is not "D" / "DESC" / "DESCENDING"</entry>
								</row>
								<row>
									<entry> SortOption: Unique assumed: When an option starts with
										an "U" and is not "U" / "UNI" / "UNIQUE"</entry>
								</row>
								<row>
									<entry> SortOption: Invalid option: When an option can't be
										recognized</entry>
								</row>
								<row>
									<entry> SortOption: Duplicate order: When an Ascending is
										defined over a Descending v.v.</entry>
								</row>
								<row>
									<entry> SortOption: Duplicate type: When a DataType or $Typing
										is defined twice.</entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> SortOption: Field does not exist For sort "entity" when
										a fieldname is wrong or excluded </entry>
								</row>
								<row>
									<entry> -1129 </entry>
									<entry> UPROCERR_ITEM</entry>
									<entry> SortOption: SubItemId does not exist</entry>
								</row>
								<row>
									<entry> SortOption: SubItemNr does not exist</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>In an associative list with sublists, $sortlistid enables to sort on the
						basis of a sublist item. </para>
					<para>By default, $sortlistid sorts on the value part of a list item, in
						ascending order. Uniface sorts in binary order, but you can apply
						locale-based sorting using $nlssortorder. For more information see Sorting
						Based on Locale.</para>
					<para>For information on sorting lists using the sort options, see Sorting
						Entities and Lists.</para>
				</sect2>
				<sect2>
					<title>Example: Sorting on a Sublist Item</title>
					<programlisting role="uniface"><![CDATA[;Construct an associative list of countries and their international calling codes
vList = ""
putitem/id vList "1" , Netherlands    <emphasis role="underline">;</emphasis> 31 "
putitem/id vList "2" , Canada         <emphasis role="underline">;</emphasis> 1  "
putitem/id vList "3" , United Kingdom <emphasis role="underline">;</emphasis> 44 "
putitem/id vList "4" , United States  <emphasis role="underline">;</emphasis> 1  "
putitem/id vList "5" , Japan          <emphasis role="underline">;</emphasis> 81 "
putitem/id vList "6" , Australia      <emphasis role="underline">;</emphasis> 61 "]]></programlisting>
					<para>To sort this list in descending order by calling code, specify the second
						sublist item and the descending sort option: </para>
					<programlisting role="uniface"><![CDATA[VSortedList = $sortlistid (vList, "2: descending"]]></programlisting>
					<para>The result in vSortedList will be:</para>
					<programlisting role="uniface"><![CDATA[VSortedList ="
5 = Japan              <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis> 81 <emphasis role="underline">;</emphasis>
6 = Australia          <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis> 61 <emphasis role="underline">;</emphasis>
3 = United Kingdom     <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis> 44 <emphasis role="underline">;</emphasis>
1 = Netherlands        <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis> 31 <emphasis role="underline">;</emphasis>
2 = Canada             <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis> 1  <emphasis role="underline">;</emphasis>
4 = United States      <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis> 1  "]]></programlisting>
					<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_sqrt">
				<title>$sqrt</title>
				<para> Introduced in: U8 </para>
				<para>Calculate the square root of X. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$sqrt</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—positive numeric constant, or a field (or indirect reference to a
						field), variable, function, or expression that evaluates to a positive
						numeric value. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Square root of X </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$sqrt</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1204 </entry>
									<entry> &lt;UPROCERR_NEGATIVE&gt; </entry>
									<entry> Negative value not allowed. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example computes the square root of 0.5. </para>
					<programlisting role="uniface"><![CDATA[$root$ = $sqrt(1 / 2)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_status">
				<title>$status</title>
				<para>Return or set the current condition code. </para>
				<sect2>
					<title>Syntax</title>
					<para>$status </para>
					<para>$status = Expression </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>An integer value. If a decimal value is assigned to $status, Uniface
						rounds it to the nearest integer. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$status returns a condition code that indicates the result of a Uniface
						operation, such as an I/O request. In general: </para>
					<itemizedlist>
						<listitem>
							<para>A negative value in $status indicates an error. In this case, the
								function $procerror gives further information about the cause of the
								error and $procerrorcontext gives details about the exact location
								where the error occurred. </para>
						</listitem>
						<listitem>
							<para>0 indicates a successful operation. </para>
						</listitem>
						<listitem>
							<para>A positive value indicates a warning or information. </para>
						</listitem>
					</itemizedlist>
					<para>You can also use $status to pass codes to another Proc module or
						component. However, if you assign a value to $status, the current value of
						$procerror is reset, so the Proc error status and context will be lost. </para>
					<para>Each time a Proc module is activated (either by a trigger or by a call
						statement), Uniface initially sets the $status general variable equal to 0
						before sequentially executing each Proc statement. When the Proc module
						ends, Uniface checks $status. </para>
					<para>The end value of $status has different effects with different triggers.
						For example, if the Proc code in a Remove Occurrence trigger ends with
						$status less than 0, the occurrence is not removed. </para>
					<para>In the Debugger, $status can be accessed directly or as variable $100.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example inspects the value of $status, set by the store
						statement in the Store trigger. The check on $status allows the Proc code to
						handle error situations. </para>
					<programlisting role="uniface"><![CDATA[; Store trigger
store
if ($status &lt; 0)
   message "Store error number %%$status."
   rollback
else
   message "Store complete."
   commit
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_storetype">
				<title>$storetype</title>
				<para>Return the type of update for the current occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para> $storetype {( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity name; can be a literal name, string, variable, function,
						parameter, or indirect reference to a field. If omitted, the current entity
						is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The following values are returned prior to the execution of the write
						statement in the Write trigger: </para>
					<table>
						<title>Table 1. Values returned by $storetype</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> The occurrence will be inserted in the database.
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> The occurrence will be updated in the database. </entry>
								</row>
								<row>
									<entry> "" </entry>
									<entry> An error occurred. procerror contains a negative value
										that identifies the exact error.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$storetype</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Write trigger in form, service, and report components,
						. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The function $storetype indicates the type of update of the current
						occurrence in the specified entity. Events that affect the value of
						$storetype are shown in the following table: </para>
					<table>
						<title>Table 3. Statements that change $storetype</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Event</entry>
									<entry> Action</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> creocc </entry>
									<entry> Sets $storetype to 1. </entry>
								</row>
								<row>
									<entry> release/mod </entry>
									<entry> Sets $storetype to 1. </entry>
								</row>
								<row>
									<entry> retrieve </entry>
									<entry> Sets $storetype to 0. </entry>
								</row>
								<row>
									<entry> ^ADD_OCC </entry>
									<entry> Sets $storetype to 1. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The value of $storetype is reset to 0 immediately following a write
						statement in the Write trigger. </para>
					<para>(Prior to V6.1, the value of $storetype remained unchanged until the end
						of the Write trigger.) </para>
				</sect2>
				<sect2>
					<title>Example: Logging Modification Information About Occurrences </title>
					<para>The following example uses the $storetype function in the Write trigger to
						determine whether an occurrence is being inserted or updated. If it is being
						updated, the occurrence already exists; if it is being inserted, the
						occurrence must be a new one. The example logs information about which user
						updated or created a particular occurrence. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Write
if ($storetype = 1)
   putmess "new occurence"
   CREATED_BY = $user
   CREATED_DATE = $date
else
   UPDATED_BY = $user
   putmess "existing occurrence updated by %%$user%%%"
endif
write]]></programlisting>
					<para>Note that the same result can be achieved using $dbocc. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_string">
				<title>$string</title>
				<para> Introduced in: U9 </para>
				<para>Return a string containing the replacement of each named XML entity in the
					input parameter string by the character represented by the entity. (XML entities
					are character mappings; they are not the same as Uniface entitites.) </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$string</command> ( <parameter>String</parameter>)</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>String—string that contains zero or more XML entities. The allowed XML
						entities are:</para>
					<itemizedlist>
						<listitem>
							<para>Unicode in decimal or hexadecimal format </para>
						</listitem>
						<listitem>
							<para>Selected standard XML character entities </para>
						</listitem>
						<listitem>
							<para>Selected Uniface-defined XML character entities </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String with the allowed XML character entities replaced by the characters
						represented by the entities. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The allowed XML entities in $string are described in the following
						tables.</para>
					<table>
						<title>Table 1. Unicode in decimal or hexadecimal format</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Format</entry>
									<entry> Syntax</entry>
									<entry> Description</entry>
									<entry> Example</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Decimal</entry>
									<entry> &amp;#nnnn; </entry>
									<entry> n is a number: 0–9.</entry>
									<entry> $string("&amp;#0065;") returns the string: "A".</entry>
								</row>
								<row>
									<entry> Hexadecimal</entry>
									<entry> &amp;#xnnnn; </entry>
									<entry> n is an alphanumeric character: 0–9 and A–F or
										a–f.</entry>
									<entry> $string("&amp;#x0041;") returns the string: "A".</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Standard XML entities allowed in $string </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> XML entity</entry>
									<entry> Character</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &amp;lt; </entry>
									<entry> &lt; </entry>
									<entry> Less than sign </entry>
								</row>
								<row>
									<entry> &amp;gt; </entry>
									<entry> &gt; </entry>
									<entry> Greater than sign </entry>
								</row>
								<row>
									<entry> &amp;amp; </entry>
									<entry> &amp; </entry>
									<entry> Ampersand </entry>
								</row>
								<row>
									<entry> &amp;apos; </entry>
									<entry> ' </entry>
									<entry> Apostrophe</entry>
								</row>
								<row>
									<entry> &amp;quot; </entry>
									<entry> " </entry>
									<entry> Quotation mark</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Uniface-defined XML entities allowed in $string </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Uniface XML entity</entry>
									<entry> Character</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &amp;uNL; </entry>
									<entry> CR</entry>
									<entry> New line </entry>
								</row>
								<row>
									<entry> &amp;uPG; </entry>
									<entry> FF</entry>
									<entry> New page</entry>
								</row>
								<row>
									<entry> &amp;uTAB; </entry>
									<entry> HT</entry>
									<entry> Tab </entry>
								</row>
								<row>
									<entry> &amp;uALL; </entry>
									<entry> GOLD *</entry>
									<entry> Profile character (match 0-n characters)</entry>
								</row>
								<row>
									<entry> &amp;uONE; </entry>
									<entry> GOLD ?</entry>
									<entry> Profile character (match any single character)</entry>
								</row>
								<row>
									<entry> &amp;uEQ; </entry>
									<entry> GOLD =</entry>
									<entry> Profile character (is equal to) </entry>
								</row>
								<row>
									<entry> &amp;uNOT; </entry>
									<entry> GOLD !</entry>
									<entry> Profile character (logical NOT)</entry>
								</row>
								<row>
									<entry> &amp;uOR; </entry>
									<entry> GOLD |</entry>
									<entry> Profile character (logical OR)</entry>
								</row>
								<row>
									<entry> &amp;uAND; </entry>
									<entry> GOLD &amp;</entry>
									<entry> Profile character (logical AND)</entry>
								</row>
								<row>
									<entry> &amp;uGT; </entry>
									<entry> GOLD &gt;</entry>
									<entry> Profile character (is greater than)</entry>
								</row>
								<row>
									<entry> &amp;uLT; </entry>
									<entry> GOLD &lt;</entry>
									<entry> Profile character (is less than)</entry>
								</row>
								<row>
									<entry> &amp;uSEP; </entry>
									<entry> GOLD ;</entry>
									<entry> Subfield separator</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example</title>
					<para> In the following example, FLD is a String field whose packing code is W*. </para>
					<programlisting role="uniface"><![CDATA[$1=$string("XML has five predeclared entities.") ;0 xml entity
$2=$string("They are: &amp;lt;, &amp;gt;, &amp;amp;, %\
&amp;apos;, and &amp;quot;.")                            ;5 xml entities
FLD="%%$1%%^%%$2"
]]></programlisting>
					<para> After executing this Proc, field FLD contains the following: </para>
					<programlisting role="uniface"><![CDATA[
XML has five predeclared entities.
They are: &lt;, &gt;, &amp;, ', and ".
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>You can generate all characters in the Unicode character set using the
						$string function. The following Proc generates the 26 uppercase Latin 1
						alphabet. FLD is a String field whose packing code is W*.</para>
					<programlisting role="uniface"><![CDATA[$1=65
$2=""
while($1 &lt; 91)
   $2="%%$2%%%&amp;#%%$1;"
   $1=$1+1
endwhile
FLD=$string($2)
]]></programlisting>
					<para>After executing this Proc, field FLD contains:</para>
					<programlisting role="uniface"><![CDATA[ABCDEFGHIJKLMNOPQRSTUVWXYZ
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_stripattributes">
				<title>$stripattributes</title>
				<para> Introduced in: U9 </para>
				<para>Return the result of removing character attributes, frames, and rulers from
					String. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$stripattributes</command> ( <parameter>String</parameter>) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>String—string, or a field (or indirect reference to a field), a variable,
						or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String with character attributes, frames, and ruler removed. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $stripattributes function returns the result of removing character
						attributes (bold, italic, and underline), frames, and rulers from String. </para>
					<para>Characters that are not known in the target character set are not stripped
						from the string, unlike the behavior in Uniface 8 in which they were
						stripped. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc example shows how character attributes are stripped
						from a Unifield, so the text can be used in field EDITBOX: </para>
					<programlisting role="uniface"><![CDATA[MYFIELD = "aaabbb"
EDITBOX = $stripattributes(MYFIELD) ; EDITBOX contains "aaabbb"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_subsetreturn">
				<title>$subsetreturn</title>
				<para>Return only the most recently retrieved occurrences of an entity to its
					operation entity parameter. </para>
				<sect2>
					<title>Syntax</title>
					<para> $subsetreturn ( Entity ) </para>
					<para>$subsetreturn ( Entity ) = Expression </para>
					<para>set | reset $subsetreturn ( Entity ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Entity—entity name; can be a literal name, string, variable, function,
						parameter, or indirect reference to a field. If omitted, the current entity
						is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>$subsetreturn returns the most recently retrieved occurrences of an entity
						to its operation entity parameter. </para>
					<table>
						<title>Table 1. Values returned in $subsetreturn</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> $subsetreturn is not enabled. </entry>
								</row>
								<row>
									<entry> &gt;0 </entry>
									<entry> $subsetreturn is currently enabled. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$subsetreturn</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1113 </entry>
									<entry> &lt;UPROCERR_PARAMETER&gt; </entry>
									<entry> Parameter name not valid or not defined. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in an operation with an entity parameter, Entity, whose direction
						is OUT or INOUT. This operation can be in a form, service, or report
						component </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>An entity parameter usually contains all occurrences of that entity.
						However, $subsetreturn provides the entity parameter, Entity, with only the
						most recently retrieved occurrences of Entity. This is especially useful
						for, but not limited to, retrieving via retrieve/a. Occurrences that are
						removed from the hitlist, or deleted from the database are not returned.
					</para>
				</sect2>
				<sect2>
					<title>Example: Return a Hitlist Using $subsetreturn</title>
					<para>In this example $subsetreturn is used to return a hitlist that includes
						all customers from the USA: </para>
					<programlisting role="uniface"><![CDATA[operation GET_USA_CUSTOMERS
params
   entity CUSTOMER : OUT
endparams
creocc "CUSTOMER", 0
retrieve/a "CUSTOMER"
set $subsetreturn
end ; GET_USA_CUSTOMERS]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_syntax">
				<title>$syntax</title>
				<para>Convert a string to a syntax string. </para>
				<sect2>
					<title>Syntax</title>
					<para> $syntax ( String{, SyntaxMode )} </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>String—string to convert to a syntax string </para>
							</listitem>
							<listitem>
								<para>SyntaxMode—syntax string mode to apply; one of: <itemizedlist>
										<listitem>
											<para>Classic or C (default) </para>
										</listitem>
										<listitem>
											<para>CaseInsensitive, CI, or I </para>
										</listitem>
										<listitem>
											<para>CaseSensitive, CS, or S </para>
										</listitem>
										<listitem>
											<para>NlsLocale, NLS, or N </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns the syntax string if successful, or an empty string if an error
						occurred. In this case, $procerror contains a negative value that identifies
						the exact error.</para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$syntax</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1013 </entry>
									<entry> UPROCERR_SYNTAXSTRING</entry>
									<entry> Not a valid syntax string. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para><emphasis role="bold"> Note:</emphasis> A syntax string is a group of
						characters and syntax codes enclosed in single quotation marks (') that can
						be used to match a string with the particular syntax pattern. For more
						information on syntax codes and the use of syntax strings, see </para>
					<para>Syntax Strings for Pattern Matching </para>
					<para>$syntax converts String to a syntax string. Typically, the syntax string
						is then used in logical expressions (such as if, repeat, or while
						statements) to check whether a string matches the particular syntax pattern. </para>
					<para>$syntax can also be used to perform case-insensitive scans and comparisons
						when the string contains diacritics (for example, an umlaut). </para>
				</sect2>
				<sect2>
					<title>Syntax Modes</title>
					<para>Syntax modes determine how characters and syntax codes are treated when
						performing a pattern-matching search. </para>
					<table>
						<title>Table 2. Syntax String Modes</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Syntax String Mode</entry>
									<entry> Meaning</entry>
									<entry> Example</entry>
									<entry> Resulting Syntax String</entry>
									<entry> Matches</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Classic C </entry>
									<entry> The following characters in String are treated as syntax
										codes for pattern-matching: # * &amp; @ ~ ? ( ) % ^ This is
										the default, and corresponds to behavior prior to Uniface
										9.4.01</entry>
									<entry> $syntax("D&amp;G") </entry>
									<entry> '%[X]D&amp;G' </entry>
									<entry> D&amp;G, DIG, dog, etc.</entry>
								</row>
								<row>
									<entry> CaseSensitive CS S </entry>
									<entry> Match only characters with the same case and treat
										syntax code characters as literals, not codes</entry>
									<entry> $syntax("D&amp;G", CS) </entry>
									<entry> '%[CS]D&amp;G%[X]' </entry>
									<entry> D&amp;G </entry>
								</row>
								<row>
									<entry> CaseInSensitive CI I </entry>
									<entry> Match all characters irrespective of case, and treat
										syntax code characters as literals, not codes Treat the
										characters that follow as case-insensitive. </entry>
									<entry> $syntax("D&amp;G", CI) </entry>
									<entry> '%[CI]D&amp;G%[X]' </entry>
									<entry> D&amp;G, d&amp;g, D&amp;g, d&amp;G </entry>
								</row>
								<row>
									<entry> NlsLocale NLS N </entry>
									<entry> Match all characters irrespective of case according to
										the locale, and treat syntax code characters as literals,
										not codes</entry>
									<entry> $syntax("i#B", NLS) </entry>
									<entry> '%[NLS]%i#B%[X]' </entry>
									<entry> Depends on locale. If $NlsLocale = tr_TR, matches: i#B
										and İ#b, but not I#B </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example: Matching Text Strings </title>
					<para>The following example matches all text entered in the current field that
						starts with "New": </para>
					<programlisting role="uniface"><![CDATA[vString = "New*"
if (@$fieldname = $syntax(vString))
...
endif]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Matching Case</title>
					<para>The following example matches all text that contains one or more uppercase
						or lowercase letters: </para>
					<programlisting role="uniface"><![CDATA[vMatch = "&amp;&amp;*"
if (NAME1 = $syntax(vMatch))
...
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_tan">
				<title>$tan</title>
				<para> Introduced in: U8 </para>
				<para>Return the tangent of X. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$tan</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>X—angle in radians or a field (or indirect reference to a field), a
						variable, or a function or expression which evaluates to an angle in
						radians. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Tangent of X </para>
					<para>If an error occurs , $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror Commonly Returned Following
							$tan</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1208 </entry>
									<entry> &lt;UPROCERR_OVERFLOW&gt; </entry>
									<entry> Overflow. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns the tangent of the given expression: </para>
					<programlisting role="uniface"><![CDATA[$tanPiR$ = $tan($pi() * RADIANS) ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_text">
				<title>$text</title>
				<para>Return the text of a message or help text. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$text</command> ( <parameter>IDStringX</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>IDString—message or help text name; can be the literal name or a string
						that evaluates to the name. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Text associated with the message IDString. </para>
							</listitem>
							<listitem>
								<para>Text of message 8006, if the message identified by IDString
									does not exist or cannot be found. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$text is commonly used to access messages and help text in UAR files
						containing <emphasis role="bold">\msg\*.msg</emphasis> files, in <emphasis
							role="bold">uobj.dol</emphasis>, or in UOBJ.TEXT. </para>
					<para>$text uses the current language and library (in $language and $variation)
						to retrieve the text. If a message or help text cannot be found with the
						current $language and $variation, Uniface also looks for combinations with
						language USA and library USYS. </para>
					<para>You can use the function $textexist to determine if a message or help text
						exists before requesting the text with $text. </para>
					<para>If $text is used in a component that is run on a server, it is the
						developer's or deployment manager's responsibility to ensure that the
						referenced texts are available in a UAR or DOL file. </para>
				</sect2>
				<sect2>
					<title>Example: Displaying Help Text</title>
					<para>The following example displays the string in the message HELPTEXT: </para>
					<programlisting role="uniface"><![CDATA[; Help trigger
help/noborder $text(HELPTEXT),3,4,7,23
]]></programlisting>
					<para>If you use a help message naming convention of <emphasis role="italic"
							>Fieldname </emphasis>_HLP, you can use the following Proc statement in
						the model definition of the Help trigger for the field: </para>
					<programlisting role="uniface"><![CDATA[help $text("%%$fieldname%%%_HLP")
]]></programlisting>
					<para>(Of course, you should not use this Proc code in the entity-level Help
						trigger, since $fieldname is only valid when used in field-level triggers.) </para>
					<para>If you are using a variable that holds <emphasis role="italic"
							>IDString</emphasis>, the value in the variable must be substituted in a
						string. You cannot use the variable name directly. For example: </para>
					<programlisting role="uniface"><![CDATA[$1 = "9004"
help $text("%%$1%%%")]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_textexist">
				<title>$textexist</title>
				<para>Return an indication of whether the specified message or help text exists. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$textexist</command> ( <parameter>IDString</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>IDString—message or help text name; can be the literal name or a string
						that evaluates to the name. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>1, if the message or help text identified by IDString exists.
								</para>
							</listitem>
							<listitem>
								<para>0, otherwise. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $textexist function indicates whether the message or help text
						specified by IDString can be found in UAR files containing <emphasis
							role="bold">\msg\*.msg</emphasis> files, in <emphasis role="bold"
							>uobj.dol</emphasis>, or in UOBJ.TEXT. It is commonly used to determine
						if a message or help text exists before trying to display it on a form, but
						it can be used in a report or service as well. </para>
					<para>$textexist uses the current language and library (in $language and
						$variation) to retrieve the text. If a message or help text cannot be found
						with the current $language and $variation, Uniface also looks for
						combinations with language USA and library USYS. </para>
				</sect2>
				<sect2>
					<title>Example: Initializing a Boilerplate Label Field </title>
					<para>In the following example, the function $textexist is used to initialize a
						boilerplate label field, ensuring that the 8006 message does not appear in
						the label: </para>
					<programlisting role="uniface"><![CDATA[; initialize labels only when message exists
if ($textexist("%%$componentname%%%.LAB1"))
   LAB1/init = $text("%%$componentname%%%.LAB1")
else ; label not found, use default
   LAB1/init = "Default Label"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_time">
				<title>$time [DEPRECATED]</title>
				<para>This function is deprecated use $clock instead.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_totdbocc">
				<title>$totdbocc</title>
				<para>Return the number of occurrences of the entity that have been retrieved from a
					database. </para>
				<sect2>
					<title>Syntax</title>
					<para> $totdbocc {( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $totdbocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Total number of occurrences of the specified entity
											currently fetched from the database. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$totdbocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The following events affect the value of $totdbocc: </para>
					<itemizedlist>
						<listitem>
							<para>read adds 1 to $totdbocc </para>
						</listitem>
						<listitem>
							<para>discard reduces $totdbocc if a database occurrence is discarded
							</para>
						</listitem>
						<listitem>
							<para>clear sets $totdbocc to 0 </para>
						</listitem>
					</itemizedlist>
					<para>The value of $totdbocc equals $hits only when all the occurrences in the
						hitlist have been read. </para>
				</sect2>
				<sect2>
					<title>Example: Calculating Entered but Unstored Occurrences </title>
					<para>In the following example, the number of occurrences in the component is
						compared with the number of occurrences in the database. If there are more
						occurrences in the component, the Proc code assumes that occurrences have
						been added to the component structure. The number of database occurrences is
						subtracted from the number of component occurrences, and the result is
						inserted into a message sent to the user: </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger
if ($totocc &gt; $totdbocc)
   $1 = ($totocc - $totdbocc)
   message "%%$1 customer(s)%%% have been added"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_totkeys">
				<title>$totkeys</title>
				<para>Return the total number of keys for an entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> $totkeys{( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity name; can be a literal name, string, variable, function,
						parameter, or indirect reference to a field. If omitted, the current entity
						is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $totkeys</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "" </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=1 </entry>
									<entry> Total number of primary keys, candidate keys, and
										indexes. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values of $procerror Commonly Returned Following
							$totkeys</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1102</entry>
									<entry> &lt;UPROCERR_ENTITY&gt;</entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Example: Validating Keys in Batch Mode </title>
					<para>The following example uses the $totkeys function to validate primary and
						candidate keys in batch mode: </para>
					<programlisting role="uniface"><![CDATA[$KEYNBR$ = 1
$MAXKEYS$ = $totkeys
while ($KEYNBR$ &lt; $MAXKEYS$)
   if ($keytype($entname, $KEYNBR$) = "P" | $keytype($entname, $KEYNBR$) = "C")
      validatekey $entname, $KEYNBR$
   endif
   $KEYNBR$ = $KEYNBR + 1
endwhile]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_totlines">
				<title>$totlines</title>
				<para>Return the total number of lines available on the page for printing. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$totlines</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $totlines </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Uniface is not printing ($printing = 0); $status is
											set to an empty string ("")</entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Total number of lines available for printing,
												<emphasis role="italic">excluding </emphasis>the
											header and trailer frames. Uniface is printing
											($printing = 1)</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $totlines function is a useful way of logging how a report is
						formatted for print. For example, you might want to warn users if their
						occurrence has spread over two pages. Another use for $totlines is to
						calculate the current line number. </para>
				</sect2>
				<sect2>
					<title>Example: Calculating the Current Line Number </title>
					<para> The following example uses $totlines and $lines to calculate the current
						line number: </para>
					<programlisting role="uniface"><![CDATA[$1 = ($totlines - $lines)]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Checking if Entity Fits on Page</title>
					<para>The following example uses $totlines to check whether an entity can fit on
						a page, and prints a message if it cannot fit on the page: </para>
					<programlisting role="uniface"><![CDATA[; Leave Printed Occurrence trigger
if (($totlines - $framedepth) &lt; 0)
   putmess "%%$entname%%% didn't fit on 1 page: see page %%$page%%%."
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_totocc">
				<title>$totocc</title>
				<para>Return the number of occurrences of an entity in the component. </para>
				<sect2>
					<title>Syntax</title>
					<para> $totocc {( Entity )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para><emphasis role="italic">Entity </emphasis>—entity name; can be a literal
						name, string, variable, function, parameter, or indirect reference to a
						field. If omitted, the current entity is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $totocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> "" </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> Component is empty (1 empty occurrence in the
											component). Entity does not exist or is not drawn on the
											component. </entry>
									</row>
									<row>
										<entry> &gt;1 </entry>
										<entry> Number of occurrences in the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned Following
								$totocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The following structure editor functions and statements affect the value
						of $totocc: </para>
					<itemizedlist>
						<listitem>
							<para>^ADD_OCC adds 1 to $totocc. </para>
						</listitem>
						<listitem>
							<para>^INS_OCC adds 1 to $totocc. </para>
						</listitem>
						<listitem>
							<para>^REM_OCC subtracts 1 from $totocc. </para>
						</listitem>
						<listitem>
							<para>read adds 1 to $totocc. </para>
						</listitem>
						<listitem>
							<para>discard reduces $totocc by the number of discarded occurrences.
							</para>
						</listitem>
						<listitem>
							<para>clear sets $totocc to 1. </para>
						</listitem>
					</itemizedlist>
					<para>Activity on a form that displays a single occurrence of an entity affects
						the values returned by $totocc, $totdbocc, $curhits, and $hits. For example,
						after the form is started, the user enters a retrieve profile which matches
						exactly ten occurrences in the database. ^NEXT_OCC is used to scan through
						each of the retrieved occurrences, perhaps making changes. After the last
						occurrence is reached, a new occurrence is added and all changed occurrences
						are stored. </para>
					<para>The following table illustrates the differences between the values of
						$totocc, $totdbocc, $curhits, and $hits. </para>
					<table>
						<title>Table 3. Sequence of Values for $totocc, $totdbocc, $curhits, and
							$hits </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Activity </entry>
									<entry> Value of $totocc </entry>
									<entry> Value of $totdbocc </entry>
									<entry> Value of $curhits </entry>
									<entry> Value of $hits </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Form starts. </entry>
									<entry> 1 </entry>
									<entry> 0 </entry>
									<entry> 0 </entry>
									<entry> 0 </entry>
								</row>
								<row>
									<entry> ^RETRIEVE </entry>
									<entry> 1 </entry>
									<entry> 1 </entry>
									<entry> -10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> 2 </entry>
									<entry> 2 </entry>
									<entry> -10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> 3 </entry>
									<entry> 3 </entry>
									<entry> -10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry>...</entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> 9 </entry>
									<entry> 9 </entry>
									<entry> -10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> 10 </entry>
									<entry> 10 </entry>
									<entry> -10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> 10 </entry>
									<entry> 10 </entry>
									<entry> 10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry> Last occurrence message appears. </entry>
								</row>
								<row>
									<entry> ^ADD_OCC </entry>
									<entry> 11 </entry>
									<entry> 10 </entry>
									<entry> 10 </entry>
									<entry> 10 </entry>
								</row>
								<row>
									<entry> ^STORE </entry>
									<entry> 11 </entry>
									<entry> 11 </entry>
									<entry> 11 </entry>
									<entry> 11 </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example: Calculating Entered but Unstored Occurrences </title>
					<para>In the following example, the number of occurrences in the component is
						compared with the number of occurrences in the database. If there are more
						occurrences in the component, the Proc code assumes that occurrences have
						been added to the component structure. The number of database occurrences is
						subtracted from the number of component occurrences, and the result is
						inserted into a message sent to the user: </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger
if ($totocc &gt; $totdbocc)
   $1 = ($totocc - $totdbocc)
   message "%%$1 customer(s)%%% have been added"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_typed">
				<title>$typed</title>
				<para> Introduced in: U8 </para>
				<para>Convert data according to type. </para>
				<sect2>
					<title>Syntax</title>
					<para> $typed ( TypedValue ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>TypedValue—data to convert. </para>
					<table>
						<title>Table 1. Allowed Uniface Data Type Functions for $typed</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Data type function</entry>
									<entry> Returns</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> $boolean()</entry>
									<entry> Boolean type </entry>
								</row>
								<row>
									<entry> $clock() </entry>
									<entry> Time type </entry>
								</row>
								<row>
									<entry> $date() </entry>
									<entry> Date type </entry>
								</row>
								<row>
									<entry> $datim() </entry>
									<entry> DateTime type </entry>
								</row>
								<row>
									<entry> $float()</entry>
									<entry> Float type</entry>
								</row>
								<row>
									<entry> $number() </entry>
									<entry> Number type</entry>
								</row>
								<row>
									<entry> $string() </entry>
									<entry> Constant string type</entry>
								</row>
								<row>
									<entry> $syntax() </entry>
									<entry> Syntax string type</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Converted data. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The TypedValue is usually obtained from a typed list. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following code is an example of the Proc function $typed: </para>
					<programlisting role="uniface"><![CDATA[$1 = $typed("$number(0010)")
;$1= 10
$2 = $typed("$string(0010)")
;$2="0010"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_ude">
				<title>$ude</title>
				<para> Introduced in: U9 </para>
				<para>Perform actions on Repository data, including compiling, exporting, importing,
					and converting. </para>
				<para>Switches $ude copy $ude delete $ude exist $ude export $ude getReferenceList
					$ude import $ude import symboltable $ude load </para>
				<sect2>
					<title>Syntax</title>
					<para>$ude Operation , Argument1 , Argument2 , Argument3 {, OptionList} )
					</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Operation—action to perform; one of: <itemizedlist>
										<listitem>
											<para>"compile"—see $ude compile </para>
										</listitem>
										<listitem>
											<para>"copy"—see $ude copy </para>
										</listitem>
										<listitem>
											<para>"delete"—see $ude delete </para>
										</listitem>
										<listitem>
											<para>"exist"—see $ude exist </para>
										</listitem>
										<listitem>
											<para>"export"—see $ude export </para>
										</listitem>
										<listitem>
											<para>"getReferenceList"—see $ude getReferenceList
											</para>
										</listitem>
										<listitem>
											<para>"import" "misc"—see $ude import </para>
										</listitem>
										<listitem>
											<para>"import" "symboltable"—see $ude import symboltable
											</para>
										</listitem>
										<listitem>
											<para>"load"—see $ude load </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>Argument1-3—operation-specific arguments. </para>
							</listitem>
							<listitem>
								<para>OptionList—associative list containing one or more options
									that are appropriate to the Operation </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $ude</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> =&gt;0</entry>
									<entry> Success. $ude returns the number of records where an
										attempt was made to write them. This may differ from what is
										expected. $procreturncontext contains detailed information
										about the actual results of the instruction.</entry>
								</row>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error
										and $procerrorcontext provides the details. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Possible Values of $procerror Returned Following
							$ude</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error Constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1 through -25</entry>
									<entry> Various. See $procerror </entry>
									<entry> Database I/O and network communication errors</entry>
								</row>
								<row>
									<entry> -9</entry>
									<entry> UIOSERR_LOGON_ERROR</entry>
									<entry> DBMS logon error; for example, the maximum number of
										DBMS logons has already been reached. </entry>
								</row>
								<row>
									<entry> -1700</entry>
									<entry> UDEERR_UDE_NOT_AVAILABLE</entry>
									<entry> Function is not available at runtime</entry>
								</row>
								<row>
									<entry> -1701 </entry>
									<entry> UDEERR_OPERATION </entry>
									<entry> Invalid operation name Occurs when the first argument of
										the $ude function is incorrect. </entry>
								</row>
								<row>
									<entry> -1702 </entry>
									<entry> UDEERR_OPERATION_NOT_ALLOWED </entry>
									<entry> Operation not allowed in combination with Object Occurs
										when the first argument of the $ude function is incorrect.
									</entry>
								</row>
								<row>
									<entry> -1703 </entry>
									<entry> UDEERR_OBJECTTYPE </entry>
									<entry> Invalid ObjectType Occurs when the second argument of
										the $ude function is incorrect. </entry>
								</row>
								<row>
									<entry> -1704 </entry>
									<entry> UDEERR_OBJECTTYPE_NOT_ALLOWED </entry>
									<entry> ObjectType is not supported Occurs when the second
										argument of the $ude function is incorrect. </entry>
								</row>
								<row>
									<entry> -1706 </entry>
									<entry> UDEERR_COMPILE </entry>
									<entry> Failed to compile</entry>
								</row>
								<row>
									<entry> -1715 </entry>
									<entry> UDEERR_TEMPLATE </entry>
									<entry> Failed to find @Template</entry>
								</row>
								<row>
									<entry> -1717 </entry>
									<entry> UDEERR_OPERAND </entry>
									<entry> Invalid operand</entry>
								</row>
								<row>
									<entry> -1718 </entry>
									<entry> UDEERR_COPY </entry>
									<entry> Invalid copy / import / export Occurs when the copy,
										import, or export operation failed. </entry>
								</row>
								<row>
									<entry> -1720 </entry>
									<entry> UDEERR_GENERAL </entry>
									<entry> Failed to process</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>With the exception of error -9 &lt;UIOSERR_LOGON_ERROR&gt;, errors from -1
						through -15 do not stop the copy, import, or export processing. </para>
					<para>To get detailed information about messages, warnings, and errors
						encountered during processing, specify the option prcadditional=true and
						examine the results using $procreturncontext.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>$ude requires a fully configured Development Environment and Repository to
						be available.</para>
					<para>Allowed in form, report, and server page components (and in service
						components that are not self-contained) </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $ude function enables you to create components that support your own
						development processes, for example, in automating exports and backups,
						managing sources, compiling and building applications, and so on. It works
						only in the Development Environment (<emphasis role="bold"
							>idf.exe</emphasis>) and is not intended for use in applications in the
						runtime environment, for example to export application data. For this
						purpose, you can use entitycopy.</para>
				</sect2>
				<sect2>
					<title>Processing Information and Error Handling</title>
					<para>$ude is usually used as a batch processing function, so it is possible for
						errors to occur either in executing $ude itself, or while processing an
						operation that it invokes. For example, if you specify an import file that
						does not exist, $ude itself returns an error -1718.</para>
					<para>However, if $ude returns 0, this indicates the $ude executed successfully,
						but does not indicate that the operation itself succeeded. For example, the
						following instructions could all result in 0 being returned, but the reasons
						may vary:</para>
					<itemizedlist>
						<listitem>
							<para>
								<programlisting role="uniface"><![CDATA[$return$ = $ude("import", "misc", "myexport.xml","","supersede=false<emphasis role="underline">;</emphasis>,"","prcadditional=true""]]></programlisting>
							</para>
							<para>Returns 0 if the contents of <emphasis role="bold"
									>myexport.xml</emphasis> are already in the Repository. </para>
						</listitem>
						<listitem>
							<para>
								<programlisting role="uniface"><![CDATA[$return$ = $ude("export", "component", "myf<emphasis role="underline">*</emphasis>","","prcadditional=true")]]></programlisting>
							</para>
							<para>Returns 0 if no components matched the profile. </para>
						</listitem>
						<listitem>
							<para>
								<programlisting role="uniface"><![CDATA[$return$ = $ude("compile", "form", "my<emphasis role="underline">*</emphasis>","","prcadditional=true")]]></programlisting>
							</para>
							<para>Returns 0 if the forms matching the profile were compiled, but
								also if no forms were compiled. </para>
						</listitem>
					</itemizedlist>
					<para>To get more detail about the actual processing, examine the information
						returned in $procreturncontext. </para>
					<para>For example, if $ude("compile") successfully compiled the forms,
						$procreturncontext returns the following: </para>
					<programlisting role="uniface"><![CDATA[Context=UDE Compile·;Release=9.1·;InputComponents=4·;OutputComponents=4·;Infos=5·;Warnings=19·;
AdditionalInfo=COMP1=ID=0·!·!·!·;
MESSAGE=Compile Form: 'MYCALENDAR'·!·!·;ID=0·!·!·!·;
MESSAGE=Form: MYCALENDAR·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  2: Model definitions·!·!·;ID=0·!·!·!·;
MESSAGE= warning: 1016 - (Fields for) entity ENTITYEX not found in application model, generating now...·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  3: Prep. structure·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  4: Form definitions·!·!·;ID=0·!·!·!·;
MESSAGE= warning: 1043 - Field CAL assumed maximum length of 40.·!·!·;ID=0·!·!·!·;
MESSAGE= warning: 1043 - Field SELDATE assumed maximum length of 40.·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  5: Background text·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  6: Component variables ·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  7: Procs compilation·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  8: Structure tables·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  9: Descriptor·!·!·;ID=0·!·!·!·;
MESSAGE=Phase 10: Save form·!·;COMP2=ID=0·!·!·!·;
MESSAGE=Compile Form: 'MYCAR'·!·!·;ID=0·!·!·!·;
MESSAGE=Form: MYCAR·!·!·;ID=0·!·!·!·;
MESSAGE=Phase  2: Model definitions·!·!·;ID=0·!·!·!·;
MESSAGE= warning: 1016 - (Fields for) entity BANS not ...
MESSAGE=Phase 10: Save form·!·;
SUMMARY=ID=0·!·!·!·;
MESSAGE=Compile done:  Components compiled 4 out of 4; Messages: [info 5, warnings 19, errors 0]]]></programlisting>
					<para>However, if $ude("compile") executed successfully but no forms were
						compiled, $procreturncontext returns the following: </para>
					<programlisting role="uniface"><![CDATA[Context=UDE Compile]]></programlisting>
					<para>This could be because no forms matched the profile.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_underline">
				<title>$underline</title>
				<para> Introduced in: U9 </para>
				<para>Return the result of applying the underline character attribute to a
					string.</para>
				<sect2>
					<title>Syntax</title>
					<para> $underline ( String ) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>String—A string, or a field (or indirect reference to a field), a
						variable, or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The $underline function returns the result of applying the underline
						character attribute to String </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types, but only applicable to unifields.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The result of $underline is visible only in a displayed unifield.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the result of applying $underline to a string
						and storing it in a unifield: </para>
					<programlisting role="uniface"><![CDATA[MY_UNIFIELD = $underline("aaabbb")]]></programlisting>
					<para>Afterwards, MY_UNIFIELD contains "<emphasis role="underline"
							>aaabbb</emphasis>". </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_uppercase">
				<title>$uppercase</title>
				<para> Introduced in: U8 </para>
				<para>Return the value of converting a string to uppercase.</para>
				<sect2>
					<title>Syntax</title>
					<para>$uppercase ( String {, "NlsLocale" | "classic" } ) </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>String—string to convert to lowercase; can be a string, field
									(or indirect reference to a field), variable, or function that
									evaluates to a string. </para>
							</listitem>
							<listitem>
								<para>NlsLocale—apply locale-based rules based on the value of the
									$nlslocale, as specified by $nlslocale or $NLS_LOCALE. </para>
							</listitem>
							<listitem>
								<para>classic—apply one-to-one character conversion according to
									Unicode definitions. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>String converted to uppercase.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The way in which strings are converted depends on the NLS settings in
						effect. If the second argument is omitted, the value of $nlscase is used to
						determine case conversion behavior. For more information, see Case
						Conversion.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>For example, if the nlslocale qualifier is used, the German lowercase ß,
						which is a single character, is converted to two characters: SS. (This is
						known as case folding.)</para>
					<programlisting role="uniface"><![CDATA[FIELD1 = $uppercase (" Groß-Gerau", "nlslocale")
;Result: FIELD1 =  GROSS-GERAU]]></programlisting>
					<para>If the qualifier is set as classic, the conversion is on a
						character-by-character basis:</para>
					<programlisting role="uniface"><![CDATA[FIELD2 = $uppercase (" Groß-Gerau", "classic")
;Result: FIELD2 = GROß-GERAU]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_user">
				<title>$user</title>
				<para>Return the user name used to log on to a path. </para>
				<sect2>
					<title>Syntax</title>
					<para> $user{( Path )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Path—path name, without leading dollar sign ($); can be a literal name,
						string, variable, function, parameter, or indirect reference to a field.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<itemizedlist>
						<listitem>
							<para>User name used to log on to Path. (Uniface does not support spaces
								in user names; any characters following a space are ignored.)
							</para>
						</listitem>
						<listitem>
							<para>Empty string (""), if no user name was required. </para>
						</listitem>
						<listitem>
							<para>Operating system user name, if Path was omitted and if this is
								supported by the operating system. </para>
						</listitem>
					</itemizedlist>
					<para>In a Web environment, if Path is omitted, $user returns: </para>
					<itemizedlist>
						<listitem>
							<para>Authenticated user name used when connecting to the Web server
							</para>
						</listitem>
						<listitem>
							<para>Empty string (""), if no user authentication has taken place
								between server and browser or if there is a license problem </para>
							<para>(Within the Web environment, Uniface <emphasis role="italic"
									>does</emphasis> support spaces in user names; this is handled
								by the authentication process.) </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $user function is supported only for DBMSs which require a user name
						to log on and for those operating systems which support a user name. It is
						not supported for network drivers. </para>
					<para>If you want to close and then open a database or network connection, you
						can use $user and $password to get these values before closing. Then use
						these values to open the database or network. This avoids prompting the user
						for information they may have already entered. </para>
				</sect2>
				<sect2>
					<title>Example: Logging Modification Information About an Occurrence </title>
					<para>The following example uses the $user function in the Write trigger. The
						example logs information about which user updated or created a particular
						occurrence. </para>
					<programlisting role="uniface"><![CDATA[; Write trigger
; $dbocc = 0 when the occurrence has
; just been created
if ($dbocc = 0)
   CREATED_BY = $user
   CREATED_DATE = $date
else
   UPDATED_BY = $user
endif
write]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_uuid">
				<title>$uuid</title>
				<para> Introduced in: U8 </para>
				<para>Generate a global unique identifier. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$uuid</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Global unique identifier (UUID) as a string, in the format of 8-4-4-4-12
						hexadecimal characters. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>On Microsoft Windows platforms, where a UUID is usually called a GUID
						(Globally Unique IDentifier), the API UuidCreate() is used. On Unix, an
						algorithm is used by the Uniface Web Request Dispatcher (WRD). </para>
					<para>For more information on how a UUID is built up (consisting of the time and
						the computer's Ethernet address), see the Open Group Web site: <link
							xlink:href="http://www.opengroup.org/products/publications/catalog/catalog.htm"
							>http://www.opengroup.org/products/publications/catalog/catalog.htm</link></para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_valrep">
				<title>$valrep</title>
				<para>Return or set the ValRep used by a widget for a field. </para>
				<sect2>
					<title>Syntax</title>
					<para>$valrep{( Field )} </para>
					<para>$valrep{( Field )} = List </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Field—field name; optional; can be a literal name, a string,
									or a variable, function, parameter or indirect reference to a
									field. Field can optionally contain a qualified field name, for
									example, MYFLD.MYENT. If omitted, the current field is used.
								</para>
							</listitem>
							<listitem>
								<para>List—associative list that contains the desired ValRep items
									for the specified field </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>ValRep list used by a widget for the specified field. </para>
							</listitem>
							<listitem>
								<para>Empty string (""), if no ValRep list has been declared or if
									the field cannot be found. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form and report components (and in service components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$valrep returns or sets the ValRep list for the specified field in all
						occurrences in the component. The ValRep list set with $valrep: </para>
					<itemizedlist>
						<listitem>
							<para>Overrides the ValRep list defined for the widget widget properties
								dialog box. </para>
						</listitem>
						<listitem>
							<para>Is reset to the compiled list each time that a component (with
								Keep Data in Memory set <emphasis role="italic">off </emphasis>) is
								restarted. </para>
						</listitem>
						<listitem>
							<para>Can be overridden for the field in a single occurrence by using
								$fieldvalrep. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Setting the ValRep for a Radio Group</title>
					<para>The following example sets the ValRep for the radio group for field
						GENDER. The underlined semicolon ( <emphasis role="underline">;</emphasis> )
						represents the Uniface subfield separator (by default, GOLD ;).</para>
					<programlisting role="uniface"><![CDATA[$valrep(GENDER.PERSON) = "M=Male<emphasis role="underline">;</emphasis>F=Female"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_valuepart">
				<title>$valuepart</title>
				<para> Introduced in: U8 </para>
				<para>Return the value part of an associative list item. </para>
				<sect2>
					<title>Syntax</title>
					<para>$valuepart ( AssociativeListItem ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Value part of an associative list item. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>For more information on the structure of lists, see Lists and Sublists.
					</para>
				</sect2>
				<sect2>
					<title>Example: Extracting the ID and Value of an Associative List Item</title>
					<para>The following example shows how the $valuepart function can be used to
						extract the value part of an associative list item: </para>
					<programlisting role="uniface"><![CDATA[$1 = $idpart("Key=TheData")
$2 = $valuepart("Key=TheData")
; results:
; $1 = "Key"
; $2 = "TheData"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_variation">
				<title>$variation</title>
				<para>Return or set the variation code of the library. </para>
				<sect2>
					<title>Syntax</title>
					<para>$variation </para>
					<para>$variation = String </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Name of the current library.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$variation defines the variation code of the library to be used for the
						following global objects: </para>
					<itemizedlist>
						<listitem>
							<para>Messages </para>
						</listitem>
						<listitem>
							<para>Help texts </para>
						</listitem>
						<listitem>
							<para>Menus </para>
						</listitem>
						<listitem>
							<para>Keyboard translation tables </para>
						</listitem>
						<listitem>
							<para>Device translation tables </para>
						</listitem>
						<listitem>
							<para>Language setups </para>
						</listitem>
						<listitem>
							<para>Glyphs </para>
						</listitem>
						<listitem>
							<para>Panels </para>
						</listitem>
					</itemizedlist>
					<para>Changing the value of $variation does not affect the global Procs and
						global variables used at application run time. These global objects are
						stored in 4GL libraries. The library is a declarative part of the component
						or start-up shell and cannot be changed without recompiling the component or
						start-up shell. </para>
					<para>Explicitly defining a value for $variation means that any assignment file
						setting for $VARIATION is ignored. </para>
				</sect2>
				<sect2>
					<title>Example: Setting a Variation </title>
					<para>The following example saves the current variation in general variable $1,
						and sets the current variation to PROJECT: </para>
					<programlisting role="uniface"><![CDATA[$1 = $variation
$variation = "PROJECT"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_web">
				<title>$web</title>
				<para> Introduced in: U8 </para>
				<para>Return an indication of whether the current application was started by the Web
					Request Dispatcher or JTi. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $web</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> JTI</entry>
										<entry> The form was activated by JTi </entry>
									</row>
									<row>
										<entry> URD</entry>
										<entry> The form was activated by the WRD</entry>
									</row>
									<row>
										<entry> ERR </entry>
										<entry> Error determining the context </entry>
									</row>
									<row>
										<entry> "" </entry>
										<entry> The form was not activated by the WRD </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in server page components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $web function returns a string that indicates whether the current
						application was started by the WRD or by JTi. This allows developers to
						write applications that are suitable for use from a Web browser and from
						JTi. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_webinfo">
				<title>$webinfo</title>
				<para> Introduced in: U8 </para>
				<para>Return or set information about the current Web request. </para>
				<sect2>
					<title>Syntax</title>
					<para>$webinfo (" TopicType ") {= String} </para>
					<para>String = $webinfo (" TopicType ") </para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>TopicType—keyword specifying a Web information property or
									channel </para>
							</listitem>
							<listitem>
								<para>String—value associated with TopicType </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values Commonly Returned by $procerror Following
								$webinfo </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -31 </entry>
										<entry> &lt;UGENERR_LICENSE&gt; </entry>
										<entry> No license for requested action. Contact your
											Uniface representative. </entry>
									</row>
									<row>
										<entry> -250 </entry>
										<entry> &lt;UWEBERR_SKELETON&gt; </entry>
										<entry> Skeleton file not found or is incorrect. </entry>
									</row>
									<row>
										<entry> -251 </entry>
										<entry> &lt;UWEBERR_OUTFILE&gt; </entry>
										<entry> When $web="", the output file is not specified or is
											the same as the skeleton file. </entry>
									</row>
									<row>
										<entry> -252 </entry>
										<entry> &lt;UWEBERR_IO&gt; </entry>
										<entry> Output file could not be written. </entry>
									</row>
									<row>
										<entry> -253 </entry>
										<entry> &lt;UWEBERR_IO_IMAGE&gt; </entry>
										<entry> Image file could not be written. </entry>
									</row>
									<row>
										<entry> -254 </entry>
										<entry> &lt;UWEBERR_ITERATION&gt; </entry>
										<entry> Nested iteration over the same entity. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in server page components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The $webinfo function provides information about requested from the
						browser to the server page, and it is used to prepare information sent to
						the browser. This information is specified by a topic type keyword that
						designates a <emphasis role="italic">channel</emphasis> of information.
						These channels function as the interface to the USYSHTTP component, which is
						responsible for communication between Uniface and the Web server.</para>
					<table>
						<title>Table 2. $webinfo Channel</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Keyword</entry>
									<entry> Direction</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> CSS </entry>
									<entry> OUT</entry>
									<entry> Cascading style sheet definitions; filled by
										webdefinitions with the CSS definitions found in <emphasis
											role="bold">uweb.ini</emphasis>. </entry>
								</row>
								<row>
									<entry> DATA </entry>
									<entry> OUT</entry>
									<entry> JSON formatted data created by websave.</entry>
								</row>
								<row>
									<entry> LAYOUT </entry>
									<entry> OUT</entry>
									<entry> HTML layouts sent to the Web browser. Populated by the
										weblayout statement.</entry>
								</row>
								<row>
									<entry> USERCONTEXT </entry>
									<entry> OUT</entry>
									<entry> Associatiave list specifying information for a single,
										unnamed cookie.</entry>
								</row>
								<row>
									<entry> COOKIESIN </entry>
									<entry> IN</entry>
									<entry> Associative list of cookies present in the
										request</entry>
								</row>
								<row>
									<entry> COOKIESOUT </entry>
									<entry> OUT</entry>
									<entry> Associative list of multiple, named cookies to be set in
										the response.</entry>
								</row>
								<row>
									<entry> DEFINITIONS </entry>
									<entry> OUT</entry>
									<entry> Component definitions, such as properties, initial
										values and valrep lists; filled by webdefinitions with the
										component definitions from the current component. </entry>
								</row>
								<row>
									<entry> HTTPRESPONSEHEADERS </entry>
									<entry> OUT</entry>
									<entry> Returned HTTP headers, excluding cookie headers.
									</entry>
								</row>
								<row>
									<entry> HTTPREQUESTHEADERS </entry>
									<entry> IN</entry>
									<entry> Incoming HTTP headers from the browser, excluding cookie
										headers </entry>
								</row>
								<row>
									<entry> HTTPREQUESTPARAMS </entry>
									<entry> IN</entry>
									<entry> Associative list of request parameters present in the
										request URL; it can include the entity names and occurrence
										IDs that are used by websetocc to set the current occurrence
										for the current component. </entry>
								</row>
								<row>
									<entry> INPUT </entry>
									<entry> IN</entry>
									<entry> Associated list containing the input of the HTML
										request, which can be read by webgen and webload reads its
										input from this channel. </entry>
								</row>
								<row>
									<entry> OUTPUT </entry>
									<entry> OUT</entry>
									<entry> Data returned to the Web browser. (This is required for
										compatiblity reasons. websave uses the DATA
										channel.)</entry>
								</row>
								<row>
									<entry> JAVASCRIPT </entry>
									<entry> OUT</entry>
									<entry> JavaScript definitions; popupated by webdefinitions
										statement with the JavaScript definitions found in the
											<emphasis role="bold">uweb.ini</emphasis> file. </entry>
								</row>
								<row>
									<entry> STATUS </entry>
									<entry> OUT</entry>
									<entry> Status code for the response.</entry>
								</row>
								<row>
									<entry> STATUSREASON </entry>
									<entry> OUT</entry>
									<entry> Default value placed in the first line of the response
										when the status code is 200.</entry>
								</row>
								<row>
									<entry> WEBSERVERCONTEXT </entry>
									<entry> OUT</entry>
									<entry> Associative list of server context properties.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The following sections provide more information about these
						channels.</para>
				</sect2>
				<sect2>
					<title>Cookie Channels (USERCONTEXT, COOKIESIN, and COOKIESOUT)</title>
					<para>The USERCONTEXT channel contains a Uniface list specifying information for
						a single, unnamed cookie. The first element is the data of the cookie;
						subsequent elements specify the cookie attributes. For descriptions of the
						attributes, see COOKIESOUT below.</para>
					<para>A cookie is set at the browser only if you explicitly set it by a
						$webinfo("UserContext").</para>
					<para>Use these channels to set the properties of a cookie and write state
						information to a cookie. For more information, see Uniface Cookies and Using
						Uniface Default Cookies for State Management.</para>
					<para>The COOKIESIN channel contains an associative list of cookies present in
						the request: </para>
					<para>CookieName1 = Value1 <emphasis role="underline">; </emphasis>CookieName2 =
						Value2... </para>
					<para>TheCOOKIESOUT channel contains an associative list of multiple, named
						cookies to be set in the response. The first element in each cookie is the
						value of the cookie, which can also be an associative list; subsequent
						elements specify the cookie attributes, which can occur in any order. The
						list for each cookie has the form: </para>
					<para>CookieValue { <emphasis role="underline">;</emphasis>expires= Seconds} {
							<emphasis role="underline">;</emphasis>domain= Domain} { <emphasis
							role="underline">;</emphasis>path= Path} { <emphasis role="underline"
							>;</emphasis>secure= SecurityFlag} { <emphasis role="underline"
							>;</emphasis>version= CookieVersion} { <emphasis role="underline"
							>;</emphasis>encodingversion= EncodingVersion}</para>
					<para>where:</para>
					<itemizedlist>
						<listitem>
							<para>CookieValue—cookie data </para>
						</listitem>
						<listitem>
							<para>Seconds—number of seconds that the new user context remains valid.
								If a request is made after the expiration time has elapsed, no
								cookie will be sent with the request. </para>
						</listitem>
						<listitem>
							<para>Domain—Web server domain for which the new user context is valid
							</para>
						</listitem>
						<listitem>
							<para>Path—Web server path on the domain for which the new user context
								is valid </para>
						</listitem>
						<listitem>
							<para>SecurityFlag—T or F (default) </para>
						</listitem>
						<listitem>
							<para>CookieVersion—cookie version: <itemizedlist>
									<listitem>
										<para>0—Netscape specification (the default) </para>
									</listitem>
									<listitem>
										<para>1—RFC 2109 specification </para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>EncodingVersion—encoding version, used only when encoding is
								needed: <itemizedlist>
									<listitem>
										<para>0—Use default. If encoding is needed, encoding version
											2 is used. </para>
									</listitem>
									<listitem>
										<para>1—URL encoded. Encodes the UTF-8 byte array of the
											cookie value, when needed. </para>
									</listitem>
									<listitem>
										<para>2—Base64 encoded, when needed. </para>
									</listitem>
								</itemizedlist></para>
							<para>When encoding is in effect, the cookie value is modified as
								follows: <itemizedlist>
									<listitem>
										<para>The cookie value is prefixed with ENC#1: or ENC#2: to
											indicate the encoding used. </para>
									</listitem>
									<listitem>
										<para>For ENC#1:, the list separator 'GOLD ;' ( <emphasis
												role="underline">;</emphasis> ) is replaced by
											'&amp;'. </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
					<para>There is no limit on the length of this string, but limitations are
						imposed by some Web servers. (4 Kb is a widely accepted maximum size for
						cookies). This value can be set and is available in the next request. </para>
					<para>The cookie is stored on the client browser. If a cookie does not change,
						it should not be present in the list.</para>
					<para>A simple example of two named cookies follows: </para>
					<para>cookie1=name=John<emphasis role="underline"
							>!!;</emphasis>birthday=19840911<emphasis role="underline"
							>!;</emphasis>expires=3600<emphasis role="underline"
							>!;</emphasis>version=1<emphasis role="underline">!;</emphasis> ...
							<emphasis role="underline">;</emphasis>cookie2=... </para>
				</sect2>
				<sect2>
					<title>HTTP Header Channels (HTTPRESPONSEHEADERS, HTTPREQUESTHEADERS, and
						HTTPREQUESTPARAMS)</title>
					<para>HTTPREQUESTPARAMS—associative list of request parameters present in the
						request URL; it can include the entity names and occurrence IDs that are
						used by websetocc to set the current occurrence for the current component. </para>
					<para>It contains an associative list of request parameters present in the
						request URL: </para>
					<para>ParameterName1 = Value1 ; ParameterName2 = Value2... </para>
					<para>These parameters contain the entity names and occurrence IDs that are used
						by websetocc to set the current occurrence for the current component. </para>
					<para>For more information, see HTTP Headers.</para>
				</sect2>
				<sect2>
					<title>STATUS and STATUSREASON</title>
					<para>The STATUS topic type contains the status code for the response. The
						default is 200, but it can be set to something else. It is placed in the
						first line of the response sent to the browser.</para>
					<para>You can specify the default value for status 200 in the STATUSREASON topic
						type. </para>
				</sect2>
				<sect2>
					<title>INPUT and OUTPUT</title>
					<para>The INPUT channel contains an associated list containing the input of the
						HTML request, which can include:</para>
					<itemizedlist>
						<listitem>
							<para>For HTTP GET requests, the contents of the query string </para>
						</listitem>
						<listitem>
							<para>For HTTP POST requests, the data of the component </para>
						</listitem>
						<listitem>
							<para>For HTTP PUT request, both the contents of the query string (with
								querystring as the key), and the data from the component (with the
								content type of the page as the key). If the user has specified URL
								encoding in the HTTP header, the content type (like text/plain) will
								not be used as a key. </para>
						</listitem>
						<listitem>
							<para>For HTTP DELETE requests, the contents of the query string, as
								with GET. The query string is used to identify the resource to
								delete. </para>
						</listitem>
					</itemizedlist>
					<para>Use webget to load data from this list and then manipulate it from Proc
						using getitem /id. </para>
					<para>The data in this channel is read by the webload statement to populate the
						current component.</para>
					<para>The OUTPUT channel contains data returned to the Web browser. Initially
						this is empty, and the webgen command fills it. A user can manipulate this
						or supply an HTML page from Proc. </para>
					<para>For more information, see Calling Operations on Static Server Pages
					</para>
				</sect2>
				<sect2>
					<title>WEBSERVERCONTEXT</title>
					<para>The WEBSERVERCONTEXT channel contains an associative list of the following
						properties</para>
					<itemizedlist>
						<listitem>
							<para>OPERATION—name of the operation to be executed in the component
							</para>
						</listitem>
						<listitem>
							<para>COMP—name of the component to be executed </para>
						</listitem>
						<listitem>
							<para>SESSION—unique session identifier </para>
						</listitem>
						<listitem>
							<para>AUTHORIZATION—key that is the result of authorization </para>
						</listitem>
						<listitem>
							<para>SESSIONCOOKIE—indicates whether cookies are used for state
								management: true, false, or dynamic. </para>
						</listitem>
						<listitem>
							<para>SERVERVARIABLES—all Web server variables that are supported by the
								WRD. </para>
						</listitem>
					</itemizedlist>
					<para>Not all server variables are supported by all servers. For more
						information about the server variables supported by your Web server, see the
						documentation for your Web server.</para>
					<table>
						<title>Table 3. Server Variables Supported by the WRD</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Server Variable </entry>
									<entry> Description </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> AUTH_TYPE </entry>
									<entry> The authentication method used by the server (such as
										Basic or NTLM). Empty when no authentication method is used
									</entry>
								</row>
								<row>
									<entry> CONTENT_LENGTH </entry>
									<entry> The length of data </entry>
								</row>
								<row>
									<entry> CONTENT_TYPE </entry>
									<entry> MIME type of message content Mime types starting with
										'text/' or the prefix 'text:' will be seen as textual output
										and so converted to a string. All others will be considered
										to be raw data. The 'text:' prefix will be stripped from the
										Mime type by the WRD, so it will not be part of the text
										sent to the Web browser.</entry>
								</row>
								<row>
									<entry> PATH_INFO </entry>
									<entry> Last part of the URI, without the server and protocol
									</entry>
								</row>
								<row>
									<entry> PATH_TRANSLATED </entry>
									<entry> Physical path of PATH_INFO on server </entry>
								</row>
								<row>
									<entry> QUERY_STRING </entry>
									<entry> Query part of the URI; the client's query string
									</entry>
								</row>
								<row>
									<entry> REMOTE_ADDR </entry>
									<entry> IP address of the client sending the request </entry>
								</row>
								<row>
									<entry> REMOTE_HOST </entry>
									<entry> Fully qualified domain name of the client sending the
										request </entry>
								</row>
								<row>
									<entry> REMOTE_USER </entry>
									<entry> The user ID sent by the client issuing the request
									</entry>
								</row>
								<row>
									<entry> REQUEST_METHOD </entry>
									<entry> Method in which the request was made, such as GET, POST,
										PUT, DELETE, or HEAD </entry>
								</row>
								<row>
									<entry> REQUEST_URI </entry>
									<entry> Returns the part of the URL after the host identifier,
										including the servlet engine application name, servlet
										mapping name (default), and anything thereafter (not
										including the query string). </entry>
								</row>
								<row>
									<entry> SERVLET_PATH </entry>
									<entry> Returns the servlet instance requested. Note that this
										can be different than the string in the URL because the
										servlet mapping can map a URL string to a servlet with a
										different name. </entry>
								</row>
								<row>
									<entry> SERVER_NAME </entry>
									<entry> The host identifier of the Web server machine. </entry>
								</row>
								<row>
									<entry> SERVER_PROTOCOL </entry>
									<entry> Name and revision number of the information protocol of
										the incoming request. </entry>
								</row>
								<row>
									<entry> SERVER_PORT </entry>
									<entry> The port of the Web server. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>For more information, see Using Default Temporary Tables to Maintain State
					</para>
				</sect2>
				<sect2>
					<title>Example: Constructing Encoded Cookies</title>
					<para>The following Proc fragment builds up two named cookies, COOKIE1 with
						cookie version 1 and encoding version 1, and COOKIE2 with only a simple
						value.</para>
					<programlisting role="uniface"><![CDATA[$COOKIEVALUE$ = ""
$COOKIE1$ = ""
putitem/id $COOKIEVALUE$, "name", "John Bunyan"
putitem/id $COOKIEVALUE$, "birthday", "19700416"
putitem $COOKIE1$, -1, $COOKIEVALUE$
putitem/id $COOKIE1$, "version", "1"
putitem/id $COOKIE1$, "encodingversion", "1"
putitem/id $webinfo("COOKIESOUT"), "COOKIE1", $COOKIE1$
putitem/id $webinfo("COOKIESOUT"), "COOKIE2", "VALUEONLY"]]></programlisting>
					<para>Various cookie values, with encoding version set to 1, are shown in the
						following examples:</para>
					<para>name=John (no encoding needed)</para>
					<para>ENC#1:name=John%20Bunyan (cookie version 0, space replaced by hex
						value)</para>
					<para>name=John Bunyan (cookie version 1, space allowed, encoding not
						needed)</para>
					<para>ENC#1:name=John Bunyan&amp;birthday=19700416 (cookie version 1, ‘GOLD ;’
							(<emphasis role="underline">;</emphasis>) replaced by ‘&amp;’)</para>
				</sect2>
				<sect2>
					<title>Example: Inspecting Server Variables</title>
					<para>Server variables are in a nested list. To retrieve a server variable, use
						$webinfo("WEBSERVERCONTEXT") and SERVERVARIABLES as the id to obtain the
						list of server variables, and then use getitem/id to extract the desired
						server variable from the list.</para>
					<para>For example, to obtain the SERVER_PROTOCOL variable:</para>
					<programlisting role="uniface"><![CDATA[variables
string server_vars, server_protocol
endvariables
getitem/id server_vars, $webinfo("WEBSERVERCONTEXT"), "SERVERVARIABLES"
getitem/id server_protocol, server_vars, "SERVER_PROTOCOL"
message/info "The server protocol is %%server_protocol%%%."]]></programlisting>
					<para> </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_webrequesttype">
				<title>$webrequesttype</title>
				<para> Introduced in: U9 </para>
				<para>Returns a value indicating the type of request from the browser. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$webrequesttype</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns a value indicating the type of request from the browser. The value
						determines the meaning of $webinfo ("input") values.</para>
					<table>
						<title>Table 1. Valid Values Returned by $webrequesttype</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "STATIC" </entry>
									<entry> The input is a normal get/post request. </entry>
								</row>
								<row>
									<entry> "DYNAMIC" </entry>
									<entry> The input is for an AJAX-type request, to be processed
										using the webload statement </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Use in dynamic server pages only</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$webrequesttype is typically used in a Get State trigger to determine
						whether or not to invoke the webload statement. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The default code of the DSP Get State trigger uses webload to load the
						data from the browser, only when $webrequesttype returns DYNAMIC. </para>
					<programlisting role="uniface"><![CDATA[;Get State trigger
selectcase $webrequesttype
case "DYNAMIC"
  webload                         ; Get Data
  if ($procerror &lt; 0)
    webmessage/error "webload failed (Get State)%%^$procerror = %%$procerror%%%"
    return (0)
  endif
 ... &lt;snip&gt; ...
endselectcase]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_webresponsetype">
				<title>$webresponsetype</title>
				<para> Introduced in: U9 </para>
				<para>Returns a value indicating the response expected by the browser for the
					current DSP component instance.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$webresponsetype</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Returns a value indicating the response expected by the browser for the
						current component instance. The value determines the meaning of $webinfo
						("input") values.</para>
					<table>
						<title>Table 1. Valid Values Returned by $webrequesttype</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "FULLPAGE" </entry>
									<entry> The expected output is a full set of data, definitions,
										and layout </entry>
								</row>
								<row>
									<entry> "DYNAMIC" </entry>
									<entry> The expected output is data only. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Use in dynamic server pages only.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>This function is typically used in a Set State trigger to determine
						whether to invoke the weblayout and webdefinitions statements. </para>
				</sect2>
				<sect2>
					<title>Example: Set State for DSP</title>
					<para>The default code of the DSP Set State trigger generates the initial page
						or a page updated, depending on the value of $webresponsetype. The following
						example shows a simplified version of this code (excluding the error
						handling.)</para>
					<programlisting role="uniface"><![CDATA[selectcase $webresponsetype
case "UPDATE"         ; Update page
  websave               ; Generate data
case "FULLPAGE"       ; Initial page
  weblayout             ; Generate layout
  webdefinitions        ; Generate component definitions
  websave               ; Generate data
endselectcase]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dollar_windowproperties">
				<title>$windowproperties</title>
				<para> Introduced in: U8 </para>
				<para>Return or set the current window properties of a form instance. </para>
				<sect2>
					<title>Syntax</title>
					<para>$windowproperties ( InstanceName {, PropertyList}) </para>
					<para>$windowproperties ( InstanceName {, PropertyList}) {=} PropertyValuesList
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>InstanceName—name of a form instance; can be a string, or a
									variable, function, or parameter that evaluates to a string, or
									a field (or indirect reference to a field) containing a string.
								</para>
							</listitem>
							<listitem>
								<para>PropertyList—list of window property names, separated by GOLD
									; ( <emphasis role="underline">;</emphasis> ); can be a string,
									or a variable, function, or parameter that evaluates to a
									string, or a field (or indirect reference to a field). </para>
							</listitem>
							<listitem>
								<para>PropertyValuesList—associative list of Property=PropertyValue
									pairs (separated by GOLD ; ), where PropertyValue is the value
									to be assigned to the window property identified by
									Property.</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Associative list of Property = PropertyValue pairs (separated by GOLD ;)
						containing the window properties and their values for the specified form
						instance. </para>
					<para>If the function is used in an assignment it returns the defined property
						string. </para>
					<para>If an error occurs, $procerror contains a negative value that identifies
						the exact error. </para>
					<table>
						<title>Table 1. Values of $procerror commonly returned by
							$windowproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -57</entry>
									<entry> &lt;UACTERR _NO_INSTANCE&gt;</entry>
									<entry> The named instance cannot be found in the component
										pool. </entry>
								</row>
								<row>
									<entry> -1105</entry>
									<entry> &lt;UPROCERR _INSTANCE&gt; </entry>
									<entry> The instance name provided is not valid. For example,
										the argument contains incorrect characters.</entry>
								</row>
								<row>
									<entry> -1110 </entry>
									<entry> &lt;UPROCERR _TOPIC&gt; </entry>
									<entry> Topic name not known (in either PropertyList or
										PropertyValuesList)</entry>
								</row>
								<row>
									<entry> -1132 </entry>
									<entry> &lt;UPROCERR _UNRESOLVED_TOPIC&gt; </entry>
									<entry> Topic not resolved. Property not specified in
										PropertyValuesList </entry>
								</row>
								<row>
									<entry> -1302 </entry>
									<entry> &lt;UPROCERR_SERVICE&gt;</entry>
									<entry> Function not allowed on service </entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> &lt;UPROCERR _UNKNOWN_ CONTEXT&gt;</entry>
									<entry> Function not allowed, unknown context. The InstanceName
										argument was omitted and one of the following occurred: --
										There is no current instance, for example in the Application
										Execute trigger. -- The current instance is a form started
										with run. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>$windowproperties returns or sets the window properties for the specified
						form instance, in terms relative to the position and size of the form's
						parent window, for example, the Uniface application window. </para>
				</sect2>
				<sect2>
					<title>Window Properties</title>
					<para>The following properties can be set using $windowproperties.</para>
					<table>
						<title>Table 2. Properties set by $windowproperties</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Physical Property</entry>
									<entry> Property</entry>
									<entry> Description</entry>
									<entry> Read/Write</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> BACKCOLOR </entry>
									<entry> Background Color </entry>
									<entry> Background color of the window. </entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> BACKIMAGE </entry>
									<entry> Background Image </entry>
									<entry> Background image of the window. </entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> HALIGN </entry>
									<entry> Horizontal Alignment </entry>
									<entry> Horizontal alignment of the background image</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> VALIGN </entry>
									<entry> Vertical Alignment </entry>
									<entry> Vertical alignment of the background image</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> HSCALE </entry>
									<entry> Horizontal Image Scaling </entry>
									<entry> Horizontal scaling of the background image</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> VSCALE </entry>
									<entry> Vertical Image Scaling </entry>
									<entry> Vertical scaling of the background image</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> PreserveAspect </entry>
									<entry> Preserve Aspect Ratio </entry>
									<entry> Indicates whether the aspect ratio of the image should
										be preserved.</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> STATE </entry>
									<entry> State </entry>
									<entry> The window state: NORMAL (default), MAXIMIZED,
										MINIMIZED, or CENTERED </entry>
									<entry> W only </entry>
								</row>
								<row>
									<entry> OKButton </entry>
									<entry> OK Button (Mobile) </entry>
									<entry> Displays and OK button to save anc close the application
										instead of an X button to minimize. </entry>
									<entry> R/W</entry>
								</row>
								<row>
									<entry> XPOS </entry>
									<entry> </entry>
									<entry> The horizontal window position, in pixels, relative to
										the parent window</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> YPOS </entry>
									<entry> </entry>
									<entry> The vertical window position, in pixels, relative to the
										parent window</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> XSIZE </entry>
									<entry> </entry>
									<entry> The horizontal window size, in pixels</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> YSIZE </entry>
									<entry> </entry>
									<entry> The vertical window size, in pixels</entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> XPOSPERC </entry>
									<entry> </entry>
									<entry> The horizontal window position, as a percentage relative
										to the parent window </entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> YPOSPERC </entry>
									<entry> </entry>
									<entry> The vertical window position, as a percentage relative
										to the parent window </entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> XSIZEPERC </entry>
									<entry> </entry>
									<entry> The horizontal window size, as a percentage relative to
										the parent window </entry>
									<entry> R/W </entry>
								</row>
								<row>
									<entry> YSIZEPERC </entry>
									<entry> </entry>
									<entry> The vertical window size, as a percentage relative to
										the parent window </entry>
									<entry> R/W </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The property name is not case-sensitive; you can use uppercase or
						lowercase letters, or any combination of these, to increase readability. If
						you specify the property names in PropertyList as literals, a compile check
						is performed to check that they are correct. </para>
					<para>If PropertyList is present, <emphasis role="italic">only</emphasis> those
						properties specified in PropertyList are set to the corresponding
						PropertyValue in PropertyValuesList. All other property values are ignored
						and the other properties remain unchanged. </para>
					<para>If the PropertyList list is <emphasis role="italic">not</emphasis>
						specified, or is an empty list, the property values, if any, specified in
						PropertyValuesList are assigned to the specified Property. All other
						properties are restored to their default values, that is, to the values in
						effect at the moment of instantiation. </para>
					<para>A runtime error (returned in $procerror) occurs if PropertyValuesList does
						not contain an item for a property specified in PropertyList. </para>
				</sect2>
				<sect2>
					<title>Restrictions and Precedence of Properties</title>
					<para>Implicit data type conversion is used to convert any non-numeric values to
						numeric values. Values outside the allowed boundaries of the underlying
						operating system are corrected by the operating system. For example, if you
						set XPOS to a value of 1000000, the operating system would change this value
						to the maximum allowed value for XPOS. </para>
					<para>The settings for position and size properties of a form that you specify
						in the Form Editor are not the same as the absolute position and size that
						you can set using $windowproperties at run time. </para>
					<itemizedlist>
						<listitem>
							<para>The form geometry is expressed in columns and rows, whereas
								$windowproperties is expressed in pixels. </para>
						</listitem>
						<listitem>
							<para>The form size property does not take into account the size of
								panel and/or menus, whereas $windowproperties does. </para>
						</listitem>
					</itemizedlist>
					<para>For forms that have the window property Overlay Previous Form, such as Tab
						pages, setting window property values is ignored. </para>
					<para>In case of conflicting values, setting State takes precedence over setting
						position and size properties. Setting the percentage properties for position
						and size takes precedence over setting the absolute properties for position
						and size.</para>
				</sect2>
				<sect2>
					<title>Example: Returning the Values of Window Properties</title>
					<para>The following example returns the values of the XPOS and YPOS window
						properties:</para>
					<programlisting role="uniface"><![CDATA[variables
   string pos ; a list
   numeric Xpos, Ypos
   string color
endvariables
pos = $windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS")
Xpos = $item("XPOS", pos)
Ypos = $item("YPOS", pos)
color = $windowproperties("MYFORM", "BACKCOLOR")
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Setting the Values of Window Properties</title>
					<para>The following examples set the XPOS property to 6 (pixels) in two
						different ways (the values are determined using implicit type
						conversion):</para>
					<programlisting role="uniface"><![CDATA[$windowproperties("MYFORM", "XPOS") = "XPOS=6"
$1 = "XPOS=6<emphasis role="underline">;</emphasis>YPOS=20<emphasis role="underline">;</emphasis>XSIZE=600<emphasis role="underline">;</emphasis>YSIZE=450"
$windowproperties("MYFORM", "XPOS") = $1 ; Other properties unchanged
]]></programlisting>
					<para>The following examples set the values of the XPOS and YPOS
						properties:</para>
					<programlisting role="uniface"><![CDATA[$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = "XPOS=6<emphasis role="underline">;</emphasis>YPOS=20"
$1 = "XPOS=6<emphasis role="underline">;</emphasis>YPOS=20<emphasis role="underline">;</emphasis>XSIZE=600<emphasis role="underline">;</emphasis>YSIZE=450"
$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = $1
; XPOS = 6 and YPOS = 20, other properties unchanged
$1 = "YSIZE=450<emphasis role="underline">;</emphasis>XSIZE=600<emphasis role="underline">;</emphasis>YPOS=20<emphasis role="underline">;</emphasis>XPOS=6" ; Changed order!
$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = $1
; XPOS = 6 and YPOS = 20, other properties unchanged
]]></programlisting>
					<para>Each of the following statements sets the color of the form to light
						blue:</para>
					<programlisting role="uniface"><![CDATA[$windowproperties ("MYFORM", "BACKCOLOR") = "BACKCOLOR=lightblue"
$windowproperties ("MYFORM", "BACKCOLOR") = "BACKCOLOR=#ADD8E6"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Setting the Values of Window properties for Two Forms</title>
					<para>The following Proc example sets the dimensions of FORM2 to the same
						dimensions as FORM1:</para>
					<programlisting role="uniface"><![CDATA[$windowproperties("FORM2", "XSIZE<emphasis role="underline">;</emphasis>YSIZE") =
$windowproperties("FORM1", "XSIZE<emphasis role="underline">;</emphasis>YSIZE")
]]></programlisting>
					<para>The following Proc example vertically tiles two non-secondary forms, FORM1
						and FORM2:</para>
					<programlisting role="uniface"><![CDATA[$1 = "XPOSPERC=0<emphasis role="underline">;</emphasis>XSIZEPERC=50<emphasis role="underline">;</emphasis>YPOSPERC=0<emphasis role="underline">;</emphasis>YSIZEPERC=100"
$2 = "XPOSPERC=50<emphasis role="underline">;</emphasis>XSIZEPERC=50<emphasis role="underline">;</emphasis>YPOSPERC=0<emphasis role="underline">;</emphasis>YSIZEPERC=100"
$windowproperties("FORM1", "XPOSPERC<emphasis role="underline">;</emphasis>YPOSPERC<emphasis role="underline">;</emphasis>
XSIZEPERC<emphasis role="underline">;</emphasis>YSIZEPERC") = $1
$windowproperties("FORM2", "XPOSPERC<emphasis role="underline">;</emphasis>YPOSPERC<emphasis role="underline">;</emphasis>
XSIZEPERC<emphasis role="underline">;</emphasis>YSIZEPERC") = $2
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Restoring the Default Window Properties</title>
					<para>The following example restores all window properties to their default
						values:</para>
					<programlisting role="uniface"><![CDATA[$windowproperties(MYFIELD) = ""
]]></programlisting>
					<para>The following example restores all window properties to their default
						values and sets XPOS to 10:</para>
					<programlisting role="uniface"><![CDATA[$windowproperties(MYFIELD) = "XPOS=10"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Unresolved Topic Errors</title>
					<para>The following examples generate a runtime error, returned in $procerror as
						-1132 (&lt;UPROCERR_UNRESOLVED_TOPIC&gt;):</para>
					<programlisting role="uniface"><![CDATA[$windowproperties("MYFORM", "XPOS") = 6
; XPOS not specified
$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = 8
; XPOS and YPOS not specified
$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = "8<emphasis role="underline">;</emphasis>20"
; XPOS and YPOS not specified
$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = "XPOS=8"
; YPOS not specified
$1 = XPOS=8<emphasis role="underline">;</emphasis>XSIZE=600<emphasis role="underline">;</emphasis>YSIZE=450"
$windowproperties("MYFORM", "XPOS<emphasis role="underline">;</emphasis>YPOS") = $1
; YPOS not specified
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.abs">
				<title>abs [DEPRECATED]</title>
				<warning>
					<para> The command <function>abs</function> was replaced by <link
							linkend="langref.dollar_abs">
							<function>$abs</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'abs' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_abs">
							<function>$abs</function>
						</link> was introduced to replace . </para>
					<para> Deprecated since: U8. <literal>absc</literal></para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.acos">
				<title>acos [DEPRECATED]</title>
				<warning>
					<para> The command <function>acos</function> was replaced by <link
							linkend="langref.dollar_acos">
							<function>$acos</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'acos' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_acos">
							<function>$acos</function>
						</link> was introduced to replace <literal>acos</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.activate">
				<title>activate</title>
				<para>Starts an operation on a specified component. </para>
				<sect2>
					<title>Syntax</title>
					<para>activate {/list | /sync | /async | /stateless} InstName {.
						LitOperationName ( {ArgumentList}) } </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/list—calls activate with two parameters containing a
									TypedList of parameters to be passed to the operation. </para>
								<para>An operation with three parameters can be called in the
									following way:
									<programlisting role="uniface"><![CDATA[$1="$date(19980203)<emphasis role="underline">;</emphasis>$number(1)<emphasis role="underline">;</emphasis>"
activate/list "SERV2".ADD_WEEK($1,$2)]]></programlisting></para>
								<para>After calling this activate, $2 has the value "<emphasis
										role="underline">;;</emphasis>$date(19980210)" </para>
							</listitem>
							<listitem>
								<para>/stateless—invokes a component operation in a stateless
									manner. When stateless operations are invoked on Uniface
									components, a temporary instance is created that is
									automatically deleted when the operation is finished. Stateless
									operation invocation is also supported in the communication to
									Uniface servers. Stored procedure components are stateless by
									default. </para>
							</listitem>
							<listitem>
								<para>/async and /sync—specify the communications mode for the
									operation; that is, the operation communicates either
									synchronously or asynchronously. This switch takes precedence
									over the switch on the newinstance statement and the component
									property as specified in the Signature Editor. </para>
								<para>Asynchronous operation invocation is only supported for
									components that are executed in a Uniface server or in an
									external middleware environments such as CORBA. Operations that
									are asynchronously invoked are not allowed to have OUT or INOUT
									parameters. They do not return a return value. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>InstName—name of a component instance that holds the definition
								for the requested operation. It is a string, field (or indirect
								reference to a field), variable, or function that evaluates to a
								string; maximum length of 16 bytes. </para>
							<para>If an instance with this name cannot be found, an implicit
								newinstance statement is executed to create an instance, using
								InstName as the name of the component; default properties are used
								for the new instance. For example, if no instance named A can be
								found in this statement"
								<programlisting role="uniface"><![CDATA[activate "A"</programlisting></para>
							<para>the following statements are executed implicitly:
								<programlisting role="uniface"><![CDATA[newinstance "A", "A"
activate "A".EXEC()]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>LitOperationName—literal name of an operation that is part of the
								specified component instance, or a variable containing the name of
								an operation as a string. The value can be EXEC, ACCEPT, QUIT, or a
								named operation in the Operations trigger. If no operation and
								arguments are specified, .EXEC() is assumed; that is, the Execute
								trigger of the component InstName is started with no parameters. Do
								not enclose the name in quotation marks ("). </para>
							<para>The argument LitOperationName should be in one of the following
								forms:
								<programlisting role="uniface"><![CDATA[activate $$INST1.COMPUTE()</programlisting><programlisting role="uniface"><![CDATA[$operation$ = "just_do_it"
activate "services".$operation$()]]></programlisting></para>
							<para>Activating the EXEC operation in a form is similar to using a run
								statement to start the form; however, activate allows you to use
								parameters when the form is started. </para>
						</listitem>
						<listitem>
							<para>ArgumentList—a comma-separated list of arguments to the operation.
								The number of arguments supplied must match the number and type of
								parameters defined with the params statement for the operation
								LitOperationName. If the data type of an argument does not match the
								type of the corresponding parameter, Uniface attempts to convert the
								data to the proper type. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Operations that are asynchronously invoked are not allowed to have OUT or
						INOUT parameters. They will not return a return value. </para>
					<para>If no return or exit statement is present, activate returns default values
						in $status. </para>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 10 </entry>
									<entry> The user used ^QUIT to leave the form that was started
										with activate. </entry>
								</row>
								<row>
									<entry> 9 </entry>
									<entry> The user used ^ACCEPT to leave the form that was started
										with activate. </entry>
								</row>
								<row>
									<entry> 0</entry>
									<entry> $status has not been assigned a value by the activated
										operation, or if there is no return statement
										present</entry>
								</row>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
										When a negative value is returned for $status, the values of
										parameters with direction OUT and INOUT must be considered
										to be undefined in the component that activated
										LitOperationName. </entry>
								</row>
								<row>
									<entry> &gt;0</entry>
									<entry> Value returned by the operation that was activated. In
										this case, $procerror is set to zero. (Since Uniface
										considers a negative value to be an error, it is not a good
										idea to return a negative value from the activated
										operation.) </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							activate</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -50 </entry>
									<entry> &lt;UACTERR_NO_SIGNATURE&gt; </entry>
									<entry> Signature descriptor for the current component not found
										(in ULANA.DICT, USYSANA.DICT, URR file, or resource file).
										For example, the component name provided is not valid.
									</entry>
								</row>
								<row>
									<entry> -51 </entry>
									<entry> &lt;UACTERR_SIGNATURE_ID&gt; </entry>
									<entry> The identifier of the compiled component does not match
										the identifier in the signature descriptor (in ULANA.DICT,
										USYSANA.DICT, URR file, or resource file). </entry>
								</row>
								<row>
									<entry> -52 </entry>
									<entry> &lt;UACTERR_PROTOCOL&gt; </entry>
									<entry> Protocol error (wrong sequence of operations). </entry>
								</row>
								<row>
									<entry> -53 </entry>
									<entry> &lt;UACTERR_ENTITY_GET&gt; </entry>
									<entry> An error occurred while copying the occurrences of an
										entity parameter to occurrences of the activated operation.
										This occurs at the start of processing for the activate
										statement on either the client or the server. </entry>
								</row>
								<row>
									<entry> -54 </entry>
									<entry> &lt;UACTERR_ENTITY_PUT&gt; </entry>
									<entry> An error occurred while copying occurrences of the
										entity parameter in the activated operation to occurrences
										of the component instance. This occurs at the end of
										processing for the activate statement on either the client
										or the server. </entry>
								</row>
								<row>
									<entry> -55 </entry>
									<entry> &lt;UACTERR_PARAMETER_GET&gt; </entry>
									<entry> An error occurred while getting an OUT or INOUT
										parameter from the activated operation. For example, the
										actual parameter provided cannot be used to receive output
										because it is a constant string. This occurs at the end of
										processing for the activate statement on either the client
										or the server. </entry>
								</row>
								<row>
									<entry> -56 </entry>
									<entry> &lt;UACTERR_PARAMETER_PUT&gt; </entry>
									<entry> An error occurred while putting an IN or INOUT parameter
										into the activated operation. This error occurs at the start
										of processing for the activate statement on either the
										client or the server. </entry>
								</row>
								<row>
									<entry> -57 </entry>
									<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
									<entry> The named instance cannot be found in the component
										pool. </entry>
								</row>
								<row>
									<entry> -58 </entry>
									<entry> &lt;UACTERR_NO_COMPONENT&gt; </entry>
									<entry> The named component cannot be found. </entry>
								</row>
								<row>
									<entry> -59 </entry>
									<entry> &lt;UACTERR_NO_OPERATION&gt; </entry>
									<entry> No definition found for operation. </entry>
								</row>
								<row>
									<entry> -60 </entry>
									<entry> &lt;UACTERR_ACTION_ON_MODALFORM&gt; </entry>
									<entry> An attempt was made by an instance other than the
										current modal form instance to start an operation other than
										the EXEC operation. </entry>
								</row>
								<row>
									<entry> -61 </entry>
									<entry> &lt;UACTERR_ENTITY_DUMMY&gt; </entry>
									<entry> The entity specified as an entity parameter is a dummy
										entity. </entry>
								</row>
								<row>
									<entry> -62 </entry>
									<entry> &lt;UACTERR_ENTITY_PARAM_MISMATCH&gt; </entry>
									<entry> The entity specified as an entity parameter must be the
										same entity as that specified in the operation. That is, one
										is a supertype and the other is a subtype of that supertype,
										or both are subtypes of the same supertype. </entry>
								</row>
								<row>
									<entry> -104 </entry>
									<entry> &lt;UNS_UNSPATH_ERROR&gt; </entry>
									<entry> The path to the remote component is not specified in the
										Name Server assignment file. </entry>
								</row>
								<row>
									<entry> -154</entry>
									<entry> &lt;UACTERR_INSTANCE_NAME_EXISTS&gt; </entry>
									<entry>
										<para>An instance with this name already exists. This error
											code is returned, for example, in the following cases: </para>
										<itemizedlist>
											<listitem>
												<para>when a modal form which is already active is
												activated again </para>
											</listitem>
											<listitem>
												<para>when an attempt is made to activate a modal
												form from a non-modal form </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
								<row>
									<entry> -155 </entry>
									<entry> &lt;UACTERR_CREATE_INSTANCE&gt; </entry>
									<entry> An error occurred while creating an instance: The
										component could not be loaded. An exit statement was
										executed in the operation INIT. </entry>
								</row>
								<row>
									<entry> -164 </entry>
									<entry> &lt;UACTERR_DEL_POSTPONED_PROC&gt; </entry>
									<entry> The instance is in the process of being deleted. For
										example, between a deleteinstance or exit and the time the
										instance is actually deleted, an attempt is made to activate
										an operation in the instance being deleted. </entry>
								</row>
								<row>
									<entry> -1105 </entry>
									<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
									<entry> The instance name provided is not valid. (See
										new_instance for more information.) For example, the
										argument contains incorrect characters. </entry>
								</row>
								<row>
									<entry> -1120 </entry>
									<entry> &lt;UPROCERR_OPERATION&gt; </entry>
									<entry> The operation name provided is not valid, (See
										-operation- for more information.) </entry>
								</row>
								<row>
									<entry> -1122 </entry>
									<entry> &lt;UPROCERR_NARGUMENTS&gt; </entry>
									<entry> Wrong number of arguments. </entry>
								</row>
								<row>
									<entry> -1123 </entry>
									<entry> &lt;UPROCERR_NPARAMETERS&gt; </entry>
									<entry> Wrong number of parameters. </entry>
								</row>
								<row>
									<entry> -1411 </entry>
									<entry> &lt;UPROCERR_EDITTWICE&gt; </entry>
									<entry> activate was performed on a modal form that is already
										in edit mode and that has an empty Execute trigger (an
										implicit edit). </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Specifying Argument Lists</title>
					<para>If the operation expects an entity or occurrence parameter (that is, a
						constructed parameter), the ArgumentList must be a string, or a field (or
						indirect reference to a field), a variable, or a function that evaluates to
						a string. This string should contain the name of a model entity (database or
						non-database) that is painted on the component. </para>
					<para>For example, if the model entity PO_ITEMS is painted on the current
						component, you could use the following statements to send all the
						occurrences of the entity PO_ITEMS to the operation TOTAL_LNS in the service
						SERV2: </para>
					<programlisting role="uniface"><![CDATA[setocc "PO_ITEMS", -1
activate "SERV2".TOTAL_LNS("PO_ITEMS")]]></programlisting>
					<para>When the operation expects a basic parameter (that is, a field, component
						variable, or named parameter) with direction IN, the corresponding argument
						in ArgumentList must be a constant, a field, a variable, or a function. The
						argument's value is placed in the operation’s parameter at the start of the
						operation. </para>
					<para>If the operation expects a basic parameter with direction INOUT, the
						corresponding ArgumentList must be a field, a variable, or a function to
						which a value can be assigned. The argument's value is placed in the
						operation's parameter at the start of the operation; the value in the
						operation at its end is returned to the field, variable, or function. </para>
					<para>If the operation expects a basic parameter with direction OUT, the
						corresponding argument in ArgumentList must be a field, a variable, or a
						function to which a value can be assigned. The value in the operation at its
						end is returned to the field, variable, or function. </para>
					<para>For example, the operation ADD_WEEK in the service SERV2 expects to find
						three parameters, with data types Date, Numeric, and Date. </para>
					<programlisting role="uniface"><![CDATA[operation ADD_WEEK
params
date INDATE : IN
numeric ADDWKS : IN
date OUTDATE : OUT
endparams
...
end ; ADD_WEEK]]></programlisting>
					<para>When the operation ADD_WEEK is activated with the following statement, the
						string constant supplied as the first argument is converted to a Date for
						the operation: </para>
					<programlisting role="uniface"><![CDATA[activate "SERV2".ADD_WEEK ("19-jul-96", 5, $DELIV_DATE$)]]></programlisting>
					<para>At run time, the operation requirements are obtained from the signature
						descriptor in the Uniface Runtime Repository or in ULANA.DICT and
						USYSANA.TEXT.</para>
				</sect2>
				<sect2>
					<title>Parameters for Operations in 3GL Services</title>
					<para>When you activate an operation in a 3GL service, consider the following: </para>
					<itemizedlist>
						<listitem>
							<para>If a parameter is declared as IN or INOUT, Uniface handles the
								memory management for the parameter. </para>
						</listitem>
						<listitem>
							<para>If a parameter is declared as OUT, the 3GL program is responsible
								for managing the memory required. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Activating Operations in Modal Forms</title>
					<para>An operation in a modal form can be started only in the following
						circumstances: </para>
					<itemizedlist>
						<listitem>
							<para>A modal form instance starts an operation contained within itself.
								This can be an operation in the Operations trigger or a special
								operation like ACCEPT or QUIT. </para>
						</listitem>
						<listitem>
							<para>A component instance starts the EXEC operation of a modal form.
								This is equivalent to using the run statement to start a modal form
								(with the additional possibility of using parameters). </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Activating Operating System Operations</title>
					<para>You can activate commands on the operating system command line by creating
						a signature for an operating system service with the Implementation Type set
						to Operating System Command. This implementation provides the default
						operations COMMAND and COMMANDOUT. You can then use the activate command to
						pass an operating system command to one of these operations. You can use
						your assignment file to redirect the OS service components to a Uniface
						server. The maximum length of a command is 511 bytes. For an example, see
						Implementing an OS Service.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, the Execute trigger starts two attached,
						non-modal forms: </para>
					<programlisting role="uniface"><![CDATA[; trigger: &lt;Execute&gt;
newinstance/attached "NMF2A", "NMF2A", "MODALITY=NON-MODAL"
activate "NMF2A".EXEC()
newinstance/attached "NMF2B", "NMF2B", "MODALITY=NON-MODAL"
activate "NMF2B".EXEC()]]></programlisting>
					<para>If the forms NMF2A and NMF2B are both defined with their window property
						Modality &amp; Attachment set to Non-Modal, Attached, these properties do
						not need to be explicitly stated on a newinstance statement. In this case,
						the Execute trigger can be simplified as follows: </para>
					<programlisting role="uniface"><![CDATA[; trigger: &lt;Execute&gt;
activate "NMF2A"
activate "NMF2B"]]></programlisting>
					<para>Even though the required Proc code is longer, for documentation purposes,
						it can be helpful to use newinstance to explicitly state the properties when
						creating instances. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.addmonths">
				<title>addmonths</title>
				<para>Adds the specified number of months to the date, storing the result of the
					calculation in $result. </para>
				<sect2>
					<title>Syntax</title>
					<para>addmonths Months , Date{, ReferenceDate} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Months—constant, field (or indirect reference to a field),
								variable, or function that can be converted to a whole (integer)
								number; the value will be truncated to form an integer. Use a
								negative value to subtract months. </para>
						</listitem>
						<listitem>
							<para>Date—constant, or field (or indirect reference to a field),
								variable, or function that can be converted to a Datetime value.
							</para>
						</listitem>
						<listitem>
							<para>ReferenceDate—constant, or field (or indirect reference to a
								field), variable, or function that can be converted to a Datetime
								value; optional. </para>
						</listitem>
					</itemizedlist>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>No effect on $status </para>
					<para>The resulting date is stored in $result. The data type of $result depends
						on the data type of the Date argument: </para>
					<itemizedlist>
						<listitem>
							<para>If Date is given as a string, $result is returned as a Datetime
								field with the time part set to 0. </para>
						</listitem>
						<listitem>
							<para>If Date is given as a field, global variable, or component
								variable, the data type in $result depends on the data type of Date.
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The addmonths statement operates in one of the following ways: </para>
					<itemizedlist>
						<listitem>
							<para>Months are added to Date, with no other date taken as reference
								point. For example, 28-Feb-1994 plus one month becomes 28-Mar-1994.
							</para>
						</listitem>
						<listitem>
							<para>Months are added to Date, using ReferenceDate to normalize the
								result. The resulting date remains in line with ReferenceDate. This
								can be used to preserve the eventual expiration date of a specific
								period of time. For example, if the reference date is 31-Jan-2006,
								one month added to 28-Feb-2006 results in a date of 31-Mar-2006.
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Conversion to Datetime format</title>
					<para>Converting strings and numbers to Datetime values is governed by the
						default Date-Time Format for the current language setup. The language setup
						is governed by the values of the functions $language and $variation. </para>
					<para><emphasis role="bold"> Note:</emphasis> It is good practice to use either
						$date or $datim to convert any dates specified as strings into Uniface
						dates. See the examples below for more information. </para>
					<para>When Uniface converts a string (from a constant, field, or variable) to a
						Datetime value, the default Datetime format (from the current language
						setup) is used to determine the result. For example, if the default
						Date-Time Format is 'dd-mmm-yy hh:nn', the string "01-02-1910" is converted
						to the Datetime value '01-FEB-19 10:00:00'. However, if the default
						Date-Time Format is 'dd-mmm-yyyy hh:nn', the same string is converted to the
						Datetime value "01-feb-1910 00:00:00". </para>
					<para>Consider the following Proc statement: </para>
					<programlisting role="uniface"><![CDATA[addmonths 1, "01-02-1910"]]></programlisting>
					<para>If the default Date-Time Format is 'dd-mmm-yy hh:nn', after this statement
						is executed, the value of $result is "01-MAR-19 10:00". If the default
						Date-Time Format is 'dd-mmm-yyyy hh:nn', the value of $result is
						"01-MAR-1910 00:00". </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>These examples assume that the default Date-Time Format is 'dd-mmm-yyyy
						hh:mm'. The following examples show the use of the addmonths statement: </para>
					<programlisting role="uniface"><![CDATA[addmonths 1, $date("28-feb-90")
; $result = 28-mar-90
addmonths 1, $date("28-feb-90"), $date("31-dec-89")
; $result = 31-mar-90
addmonths 2, $date("31-jan-90"), $date("1-dec-89")
; $result = 1-mar-90
addmonths -1, $date("28-feb-90")
; $result = 28-jan-90
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.apexit">
				<title>apexit</title>
				<para>Ends the application session immediately. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$apexit</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The apexit statement ends the application session immediately. It has the
						same effect as pressing Control+C or Break. </para>
					<para>It is recommended that you use a close statement before apexit, to ensure
						all data is stored or updated. </para>
					<para>Terminating the application results in any triggers that would normally be
						reactivated (such as Application Execute) not being activated. </para>
					<para>If the component that issues the apexit statement has any child instances
						that were started with the newinstance (or with activate and an implicit
						newinstance), these instances are deleted before the application session
						ends. Before they are removed, any CLEANUP operation that is present is
						executed. <emphasis role="bold"> Note:</emphasis> If this statement is
						executed while testing a component from within the Development Environment,
						the Development Environment application is terminated. This is also true
						when you enter quit in the debugger. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the apexit statement to exit an application
						from the Quit trigger: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Quit
askmess "Do you want to leave this application?"
if ($status = 1)
   rollback
   close
   apexit
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.apstart">
				<title>apstart</title>
				<warning>
					<para>Deprecated since: U8.3, but was reintroduced in Uniface 9.</para>
					<para>Pass control of the application to the component manager.</para>
				</warning>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$apstart</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The values returned in $status following apstart are: </para>
					<itemizedlist>
						<listitem>
							<para>-1 if an error occurred. In this case, $procerror contains the
								exact error. </para>
						</listitem>
						<listitem>
							<para>Otherwise, the value returned by the last component or operation
								that ends. (It is not a good idea to return -1 from components or
								operations, since this situation cannot be distinguished from the
								statement occurring in an incorrect trigger.) </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Values of $procerror that are commonly returned by apstart </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error Constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1402 </entry>
									<entry> &lt;UPROCERR_STATEMENT&gt; </entry>
									<entry> Statement not allowed in this trigger. (The apstart
										statement is allowed only in the Application Execute
										trigger.)</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Application Execute trigger of startup shells. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The apstart is required in the Application Execute trigger of the startup
						shells of a Uniface Server. It is usually not required in the startup shells
						of other applications. (In prior versions, it was needed in the Application
						Execute trigger after activating a sequence of non-modal forms before
						allowing the user to take control of the application session. Since Uniface
						8.3, Uniface automatically detects the activation of a sequence of non-modal
						forms and, after the last activate, passes control to the user.) </para>
					<para>The apstart statement allows the component manager to take control of the
						application, waiting for user input. It can be used only in the Application
						Execute trigger. </para>
					<para>The Application Execute trigger is typically used to start a number of
						non-modal forms before allowing the user to take control of the application
						session. If no forms are present in the component pool when apstart is
						encountered, the application terminates. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.asin">
				<title>asin [DEPRECATED]</title>
				<para>
					<warning>
						<para> The command <function>asin</function> was replaced by <link
								linkend="langref.dollar_asin">
								<function>$asin</function>
							</link> in Uniface 8. Compiling this statement will result in a compile
							warning: <literal>warning: 1000 - Deprecated function 'asin'
								used</literal>. </para>
						<para> In U8 the function <link
								linkend="langref.dollar_asin">
								<function>$asin</function>
							</link> was introduced to replace <literal>asin</literal>. </para>
						<para> Deprecated since: U8. </para>
					</warning>
				</para>
			</sect1>
			<sect1 xml:id="langref.askmess">
				<title>askmess</title>
				<para>Display a message and wait for the user's response. </para>
				<sect2>
					<title>Syntax</title>
					<para>askmess{/nobeep}{/question | /info | /warning | /error} %\ </para>
					<para>MessageText{, Replies} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/nobeep—the terminal does not beep when the dialog box
									containing MessageText appears. This has no effect in the Web
									environment. </para>
							</listitem>
							<listitem>
								<para>/question, /info, /warning and /error—these switches allow the
									severity of the message text to be graphically shown. </para>
								<para>The severity levels are mapped to the appropriate glyphs for
									the GUI under which the component is running. If you specify
									several levels of severity, the most severe switch of those
									specified is used. These switches are ignored in the Web
									environment. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>MessageText—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string. The
									string has a maximum length of 512 bytes or ten lines. </para>
							</listitem>
							<listitem>
								<para>Replies—string, or field (or indirect reference to a field),
									variable, or function that evaluates to a string. The contents
									of the string should be as described as </para>
								<para>Reply 1 , Reply 2 , ..., Reply n . If Replies is longer than
									512 bytes, it is truncated to that length. It can contain up to
									25 replies. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The values returned in $status are: </para>
					<table>
						<title>Return Values</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Value</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> When Replies argument omitted, reply was equivalent to
										No</entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> When Replies argument omitted, reply was equivalent to
										Yes</entry>
								</row>
								<row>
									<entry> n </entry>
									<entry> Number of the reply entered by the user. The first reply
										is 1, the second reply is 2, and so on.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The askmess statement displays MessageText in a dialog box, along with the
						specified replies. In character mode, MessageText appears on a single line.
						In GUIs, a word-wrap mechanism is used for very long messages. </para>
					<para>Alternatively, you may include the string %%^ within MessageText to
						separate text that you want to appear on separate lines. In character mode,
						word-wrapping is not performed and %%^ is ignored; only a single line of
						text appears.</para>
					<para>The maximum number of lines allowed in the message text depends on the GUI
						in use. </para>
				</sect2>
				<sect2>
					<title>Number of Replies</title>
					<para>The way in which the replies for MessageText appear in the dialog box
						depends on the number of replies specified: </para>
					<itemizedlist>
						<listitem>
							<para>If Replies is omitted, the default replies (as specified in the
								language setup for the current language) appear as command buttons.
								The user responds by choosing a button. For example, the standard
								default replies for the language NL are 'Ja' and 'Nee'. </para>
						</listitem>
						<listitem>
							<para>If five or fewer replies are provided in Replies, each reply is
								available as a command button. The user responds by choosing a
								button. </para>
						</listitem>
						<listitem>
							<para>If between six and 25 replies are provided in Replies, the
								possible replies are presented as a radio group, with each reply
								displayed alongside an associated radio button. The user responds by
								choosing the desired reply and clicking the Accept button. </para>
						</listitem>
						<listitem>
							<para>If more than 25 replies are provided in Replies, only the first 25
								are displayed (as a radio group); any remaining replies are ignored.
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>In a Web Application</title>
					<para>The askmess statement is not supported in Web applications. However, its
						behavior can be emulated using predefined confirmation pages, or hyperlink
						answers. </para>
				</sect2>
				<sect2>
					<title>In a Character-Mode Application</title>
					<para>In a character mode application, you can use the assignment setting
						$OLDASKMESS to restore V5.1 functionality to the askmess statement. For more
						information, see $OLD_ASKMESS. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example displays a dialog box with two buttons when the user
						selects a menu item to leave the application. The Cancel button gives the
						user a chance to change their mind about leaving the application. </para>
					<programlisting role="uniface"><![CDATA[; trigger: &lt;Option&gt;
askmess/question "Are you sure you want to leave the application?","Quit,Cancel"
if ($status = 1)     ;user really wants to leave
   apexit
else
   if ($status = 2)  ;user clicked Cancel
       return
   endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.atan">
				<title>atan [DEPRECATED]</title>
				<warning>
					<para> The command <function>atan</function> was replaced by <link
							linkend="langref.dollar_atan">
							<function>$atan</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'atan' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_atan">
							<function>$atan</function>
						</link> was introduced to replace <literal>atan</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.blockdata">
				<title>blockdata</title>
				<para>Defines a constant block of text. </para>
				<sect2>
					<title>Syntax</title>
					<para>BlockName :blockdata Delimiter </para>
					<para>... </para>
					<para>... text ... </para>
					<para>... </para>
					<para>Delimiter </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Label—string identifying the block of text; maximum of 8
									characters. </para>
							</listitem>
							<listitem>
								<para>Delimiter—character that inidicates the beginning and end of
									the text block </para>
							</listitem>
							<listitem>
								<para>text—all lines are considered part of the text until the
									character Delimiter is encountered. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The blockdata statement is often used to define long sql statements. </para>
					<para>The following rules apply to the use of blockdata: </para>
					<itemizedlist>
						<listitem>
							<para>The blockdata statement must be in the same Proc module as the
								statement that references the BlockName. </para>
						</listitem>
						<listitem>
							<para>The blockdata statement must be at the end of the Proc module.
							</para>
						</listitem>
						<listitem>
							<para>More than one blockdata statement is allowed in the Proc module.
							</para>
						</listitem>
						<listitem>
							<para>In a Proc statement (for example, assignment or putmess), refer to
								BlockName as $ BlockName. </para>
						</listitem>
						<listitem>
							<para>BlockName cannot exceed eight characters in length. </para>
						</listitem>
						<listitem>
							<para>Substituting variables (using two percent signs (%%)) is not
								possible within text. </para>
						</listitem>
						<listitem>
							<para>The hash character (#) is not allowed as Delimiter. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the blockdata statement to define
						the text of a letter: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
TEXT = $reject
message "Standard refusal loaded in TEXT field."
reject:blockdata +
Dear sir,
We regret to inform you that you are in no way suitable
for the vacancy and that we have hired somebody else. By way of
consolation, however, we are pleased to inform you that your submission
has been filed for future reference. Thank you for considering us.
Yours sincerely,+
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.break">
				<title>break</title>
				<para>Set or clear a break point</para>
				<sect2>
					<title>Syntax</title>
					<para>Break {Module} {Line}</para>
					<para>Break {Module}: {Line}</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Module—name of a global Proc, entry, operation, or an
									internally-generated label. If omitted, the current module is
									assumed. </para>
							</listitem>
							<listitem>
								<para>Line—logical line number in Module; if omitted, the first line
									is assumed. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The debugger is invoked when the named line is reached in the specified
						module.</para>
					<para>If both Module and Line are omitted, the current breakpoint is
						cleared</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>Set a breakpoint at the second line in the GP_STORE global Proc
						module:</para>
					<programlisting role="uniface"><![CDATA[b Gp_store 2]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>Other examples:</para>
					<programlisting role="uniface"><![CDATA[break y2 4]]></programlisting>
					<programlisting role="uniface"><![CDATA[b gp_store 15]]></programlisting>
					<programlisting role="uniface"><![CDATA[break]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.call">
				<title>call</title>
				<para>Execute the specified entry or global Proc. </para>
				<sect2>
					<title>Syntax</title>
					<para>call {Library :}LitEntryName{( ArgumentList )} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Library—library containing the global Proc module. If not
									specified, the default library is used. </para>
							</listitem>
							<listitem>
								<para>LitEntryName—literal name of a module declared on an entry
									statement; do not enclose LitEntryName in double quotation marks
									("). </para>
							</listitem>
							<listitem>
								<para>ArgumentList—comma-separated list of arguments to the module.
									The number of arguments supplied must match the number and type
									of parameters defined with the params statement for the
									LitEntryName. If the data type of an argument does not match the
									type of the corresponding parameter, Uniface attempts to convert
									the data to the proper type. </para>
								<para>The ArgumentList is of the form: </para>
								<para>Argument 1 , Argument 2 , ... , Argument n </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para><table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1</entry>
										<entry> An error occurred. The error is returned in
											$procerror. Values of parameters with direction OUT and
											INOUT must be considered to be undefined in the
											component that called LitEntryName. </entry>
									</row>
									<row>
										<entry> 0</entry>
										<entry> $status has not been assigned a value, no value is
											returned by the called module, or there is no return
											statement present. </entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Value returned by the Proc module that was called.
											(Since Uniface expects -1 to be an error, it is not a
											good idea to return that value from the called Proc
											module.) </entry>
									</row>
								</tbody>
							</tgroup>
						</table> The value in $status can affect the way the structure editor
						behaves when it is activating a sequence of triggers. If you call a Proc
						module in a trigger, make sure that the value returned by the Proc module
						does not adversely affect the structure editor. <table>
							<title>Table 2. Values returned in $procerror following call</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Symbolic error </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1109 </entry>
										<entry> UPROCERR_ENTRY</entry>
										<entry> The entry name specified cannot be found. </entry>
									</row>
									<row>
										<entry> -1113 </entry>
										<entry> UPROCERR_PARAMETER</entry>
										<entry> Parameter name not valid or not defined. </entry>
									</row>
									<row>
										<entry> -1122</entry>
										<entry> UPROCERR_NARGUMENTS </entry>
										<entry> Wrong number of arguments. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components; however, calling a global
						Proc is not allowed in self-contained services and reports. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>In specifying the argument list:</para>
					<itemizedlist>
						<listitem>
							<para>When the module expects a basic parameter (that is, a field,
								component variable, or a named parameter) with direction IN, the
								corresponding argument in ArgumentList can be a constant, a field,
								an indirect reference to a field, a variable, or a function. The
								argument's value is placed in the module's parameter at the start of
								the module. </para>
						</listitem>
						<listitem>
							<para>When the module expects a basic parameter with direction INOUT,
								the corresponding argument in ArgumentList can be a field, an
								indirect reference to a field, a variable, or a function to which a
								value can be assigned. The argument's value is placed in the
								module's parameter at the start of the module; the value in the
								module at its end is returned to the field, variable, or function.
							</para>
						</listitem>
						<listitem>
							<para>When the module expects a basic parameter with direction OUT, the
								corresponding argument in ArgumentList can be a field, an indirect
								reference to a field a variable, or a function to which a value can
								be assigned. The value in the module at its end is returned to the
								field, variable, or function. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Locating the Called Module</title>
					<para>When resolving a call statement, the called module is searched for in this
						order: </para>
					<orderedlist>
						<listitem>
							<para>In the triggers of the component (for a local Proc module).
							</para>
						</listitem>
						<listitem>
							<para>In the library specified in the component properties (for a global
								Proc). </para>
						</listitem>
						<listitem>
							<para>In the library specified in the start-up shell properties (for a
								global Proc). </para>
						</listitem>
						<listitem>
							<para>In the library SYSTEM_LIBRARY (for a global Proc). </para>
						</listitem>
					</orderedlist>
					<para>For more information, see Compilation Process. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to use the call statement: </para>
					<programlisting role="uniface"><![CDATA[; Local Proc 
entry LSTORE
  store
  if ($status &lt; 0)
      message "Store error!"
      rollback
else
      message "Store done."
      commit
endif
end ; module LSTORE]]></programlisting>
					<programlisting role="uniface"><![CDATA[; trigger: Store
call LSTORE
return ($status)]]></programlisting>
					<programlisting role="uniface"><![CDATA[; trigger: Accept
if ($formdbmod = 1)
  call LSTORE
endif
return ($status)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.callfieldtrigger">
				<title>callfieldtrigger</title>
				<para>Explicitly calls a trigger on a field. </para>
				<para> Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para> callfieldtrigger TriggerName, FieldName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>TriggerName—detail, or the name of an extended field-level
									trigger that has no parameters. </para>
							</listitem>
							<listitem>
								<para>FieldName—field of the trigger to be called </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values Returned by calltrigger in $status</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &gt;=0</entry>
										<entry> Success. Value returned by the trigger.</entry>
									</row>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values of $procerror Commonly Returned by
								calltrigger</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Error Constant</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1101 </entry>
										<entry> PROCERR_FIELD</entry>
										<entry> Specified field does not exist</entry>
									</row>
									<row>
										<entry> -1120 </entry>
										<entry> PROCERROR_OPERATION</entry>
										<entry> Specified extended trigger does not exist on field
											level or on entity level</entry>
									</row>
									<row>
										<entry> -1123 </entry>
										<entry> PROCERR_NPARAMETERS</entry>
										<entry> Specified extended trigger has one or more
											parameters</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>All components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The callfieldtrigger statement explicitly calls the named trigger for the
						specified field. Only triggers that have no implicit processing can be
						called.</para>
					<para>If the trigger is not defined at field level, the callfieldtrigger
						statement falls back to the same trigger on entity level. For the Menu
						trigger, it can also fall back to the component-level trigger. </para>
					<para>For most DSP widgets it is possible for the user to trigger an event, such
						as onclick, ondblclick, onblur, and so on. DSP widgets can use these to a
						call a trigger on the field to which the widget is bound. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.case">
				<title>case</title>
				<para>Defines a case in a selectcase block.</para>
				<sect2>
					<title>Syntax</title>
					<para>See selectcase.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.clear">
				<title>clear</title>
				<para>Clear data from the component or entity. </para>
				<sect2>
					<title>Syntax</title>
					<para> clear{/e Entity} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>/e—clears data from the specified entity, rather than the
								component </para>
						</listitem>
						<listitem>
							<para>Entity—entity to be cleared. Can be a string, or a field,
								variable, function, or parameter that evaluates to a string
								containing the entity name. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by clear in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Data was successfully cleared, or no entities are
											painted on the component. </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								clear</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components, except in the Occurrence
						Gets Focus and Start Modification triggers. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> If the argument Entity is omitted, all data in the component is
						cleared.</para>
					<para>The clear statement clears all data from the component (by default) or,
						when the /e switch is given, from Entity. Data in the database is not
						affected by the clear statement; any locked occurrences remain locked. The
						active path for the component is reset. </para>
					<para>One use for the clear statement is when data has been added in a different
						component and the data displayed on the current form needs to be
						redisplayed. </para>
					<para><emphasis role="bold"> Caution:</emphasis> Never use the clear/e statement
						in the Occurrence Gets Focus or Start Modification triggers. This can cause
						Uniface to enter an infinite loop. </para>
				</sect2>
				<sect2>
					<title>Component with Record behavior</title>
					<para>Use clear/e with care on a component with Record behavior. A Record
						component has only one outermost entity. If you have painted more than one
						outermost entity, when the Record component is compiled, Uniface expands the
						first outermost entity painted (that is, the upper, left-most) so that all
						other outermost entities become inner to the first. This means that using
						clear/e to clear data from the first outmost entity on a Record component
						clears data from all the entities painted on the component. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the example shown in following figure, form X calls service Z to create
						a new occurrence of entity C: </para>
					<para>Figure 1. Using the clear statement to refresh updated data</para>
					<para><mediaobject>
							<imageobject>
								<imagedata fileref="images/fig13_2.jpg"/>
							</imageobject>
						</mediaobject> The Proc code for the Detail trigger is as follows: </para>
					<programlisting role="uniface"><![CDATA[; trigger Detail
; save foreign key for occurrences displayed in entity C
; set up foreign key, ready for retrieve
; retrieve new data entered on service Z
$1 = FOREIGN_KEY.C
activate "Z".EXEC($1)
clear/e "C"
FOREIGN_KEY.C = $1
retrieve/e "C"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.close">
				<title>close</title>
				<para>Log off from the specified path or from all paths. </para>
				<sect2>
					<title>Syntax</title>
					<para> close {" PathString "} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>PathString—a string constant that contains the name of a DBMS or network
						path; for example, "$ORA". (Although the leading dollar sign ($) is not
						required, it is recommended that you include it as part of the path named in
						PathString.)</para>
					<itemizedlist>
						<listitem>
							<para>If PathString is omitted, close closes all DBMS paths and all
								network paths, including paths to remote components. </para>
						</listitem>
						<listitem>
							<para>If PathString is a DBMS path, close closes all open tables and
								files for all the entities on PathString, and logs off from the
								database. </para>
						</listitem>
						<listitem>
							<para>If PathString is a network path to a Uniface File Server, close
								closes all the entities on PathString, logs off from the databases
								accessed using PathString, and closes the network connection.
							</para>
						</listitem>
						<listitem>
							<para>If PathString is a network path to a Uniface Application Server,
								close closes all remote component instances on the path; stops the
								synchronous Application Server, if applicable; and closes the
								network connection. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by close in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> The path was successfully closed. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							close</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -1107 </entry>
									<entry> &lt;UPROCERR_PATH&gt; </entry>
									<entry> The path name is not correct or the path does not exist,
										for example, no assignment is found for the path. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When you close a path that leads to DBMS tables or files, it is
						recommended that a commit or rollback be performed before the close. In this
						way, the application does not rely on the behavior of the DBMS and behaves
						consistently. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the close statement to log off from
						all DBMSs: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
if ($status = 1)
    rollback
    close
    apexit
endif
]]></programlisting>
					<para>The following statement closes the database identified by path $RMS: </para>
					<programlisting role="uniface"><![CDATA[close "$RMS"
]]></programlisting>
					<para>The following statement closes the user-defined path $MY_PATH: </para>
					<programlisting role="uniface"><![CDATA[close "$MY_PATH" ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.clrmess">
				<title>clrmess</title>
				<para>Clear all text from the message frame and message line. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$clrmess</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The clrmess statement clears all text from the message frame. The store
						and erase statements also clear the message frame. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> In the Debugger, clrmess is disabled
						by default. To enable it, choose <emphasis role="bold">View &gt; Settings
							&gt; Message frame</emphasis>. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the clrmess statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
clrmess
putmess "Form %%$formname%%% loaded at %%$time%%%."
edit]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.commit">
				<title>commit</title>
				<para>Commit a transaction to a DBMS or path. </para>
				<sect2>
					<title>Syntax</title>
					<para> commit {" PathString "} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>PathString—a string constant that contains the required path name: </para>
					<itemizedlist>
						<listitem>
							<para>If PathString does not start with a dollar sign ($), the argument
								is assumed to be a DBMS (driver path) defined in the application
								model. Modifications to all entities assigned to that DBMS are
								committed. In this case, the model definition determines which
								entities are committed. </para>
						</listitem>
						<listitem>
							<para>If PathString starts with a dollar sign, the argument is assumed
								to be a path name. Modifications to all entities accessed through
								that path are committed. In this case, assignments determine which
								entities are committed. </para>
						</listitem>
						<listitem>
							<para>If PathString is omitted, all pending updates for all databases
								used in the transaction are written (committed) and all locked
								occurrences are unlocked. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by commit in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> The data was successfully committed. </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -9 </entry>
										<entry> An attempt to open a DBMS failed because the maximum
											number of DBMS logons has already been reached. </entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								commit</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1107 </entry>
										<entry> &lt;UPROCERR_PATH&gt; </entry>
										<entry> The path name is not correct or the path does not
											exist, for example, no assignment is found for the path.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>If a target DBMS does not support database locking, the commit statement
						is ignored. For information about your DBMS, see the appropriate DBMS Driver
						Guide. </para>
					<para>To avoid currency problems, add a commit (or rollback) statement at the
						highest level of the component 'tree' for the current transaction, unless
						the component has the property Keep Data in Memory selected. In this case,
						you should use commit at that level. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the commit statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Store
call CENSTORE
return ($status)
]]></programlisting>
					<programlisting role="uniface"><![CDATA[entry CENSTORE
store
if ($status &lt; 0)
   message "Store error!"
   rollback
else
   message "Store complete."
   commit
   if ($status &lt; 0)
      message "Commit error, rollback performed."
      rollback
   endif
endif
end
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Committing DEF versus $DEF</title>
					<para>Consider the application model MYMODEL. In the model definitions of
						MYMODEL, all entities are assigned to the default DBMS. At run time,
						assignments are used to redirect the entity FRODO to another DBMS: </para>
					<programlisting role="uniface"><![CDATA[$DEF = $ORA
FRODO.MYMODEL = $SYB
]]></programlisting>
					<para>If the following commit statement is used, <emphasis role="italic"
							>all</emphasis> entities in MYMODEL (which are assigned to the default
						DBMS) are committed: </para>
					<programlisting role="uniface"><![CDATA[commit "DEF"]]></programlisting>
					<para>If the following commit statement is used, all entities except FRODO are
						committed: </para>
					<programlisting role="uniface"><![CDATA[; commit all entities of MYMODEL except FRODO
commit "$DEF"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.compare">
				<title>compare</title>
				<para>Compare fields of two adjacent occurrences. </para>
				<sect2>
					<title>Syntax</title>
					<para>compare{/previous | /next} (FieldList) {from Entity} </para>
				</sect2>
				<sect2>
					<title>Switches and Clauses</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/previous—compare the fields of the active occurrence with
									those of the previous occurrence. </para>
							</listitem>
							<listitem>
								<para>/next—compares the fields in the active occurrence with those
									of the next occurrence. This is the default behavior of compare.
									However, it is recommended that you use the /next switch for
									clarity. </para>
							</listitem>
							<listitem>
								<para>from—specifies an entity containing the fields to compare. If
									omitted, the active occurrence of the current entity (available
									in $entname) is used. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FieldList—list of field names. The FieldList is of the form: </para>
								<para>LitFieldName 1 , LitFieldName 2 , ... LitFieldName n . </para>
							</listitem>
							<listitem>
								<para>LitFieldName—literal name of a field in the entity being
									compared. Do not enclose the name in double quotation marks (")
									or qualify the name with the entity and application model name.
									If FieldList contains only one LitFieldName, the surrounding
									parentheses (()) are not required. </para>
							</listitem>
							<listitem>
								<para>Entity—string, or field, variable, function, or parameter that
									evaluates to a string that contains the name of an entity. For
									example: <itemizedlist>
										<listitem>
											<para>String: "INVOICES". </para>
										</listitem>
										<listitem>
											<para>Field: FIELD1, where FIELD1 contains "INVOICES"
											</para>
										</listitem>
										<listitem>
											<para>Variable: $1, where $1 contains "INVOICES" </para>
										</listitem>
										<listitem>
											<para>Function: $entname, where $entname contains
												"INVOICES" </para>
										</listitem>
										<listitem>
											<para>Parameter: PARAM1, where PARAM1 contains
												"INVOICES"</para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The compare statement sets both $status and $result. </para>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1</entry>
									<entry> An error occurred. $procerror contains the exact error.
										In this situation, $result is always 0. </entry>
								</row>
								<row>
									<entry> 0</entry>
									<entry> No error occurred. This can be returned even when there
										is no next or previous occurrence. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values returned by compare in $result </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> Perfect match of all specified fields. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Fields do not match. (This value is also returned if
										$status is -1.) </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> No previous or next occurrence. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Values commonly returned by $procerror following
							compare</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The compare statement compares the contents of fields listed in FieldList
						with the corresponding fields in the next or previous occurrence. The
						compare statement first formats the data in the listed fields before
						comparing them. This allows the assignment to be done in Proc code without a
						compare error occurring. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the compare statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Printed Occurrence
compare/next (INVDATE) from "INVOICE"
if ($result &lt;= 0)
   printbreak "SUBTOTAL"
   if ($result = 0)
      eject
      printbreak "TITLE"
   endif
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.creocc">
				<title>creocc</title>
				<para>Creates an empty occurrence of the specified entity. </para>
				<sect2>
					<title>Syntax</title>
					<para>creocc Entity , OccurrenceNumber </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—name of an entity where an occurrence is to be created.
									Can be a string, or a field, variable, function, or parameter
									that evaluates to a string. </para>
							</listitem>
							<listitem>
								<para>OccurrenceNumber—position of the new occurrence; can be a
									constant, or field (or indirect reference to a field), variable,
									or function that can be converted to a whole (integer) number;
									the value will be truncated to form an integer . </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> &gt;=0</entry>
										<entry> Statement executed successfully</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								creocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
									<row>
										<entry> -1203</entry>
										<entry> &lt;UPROCERR_RANGE&gt; </entry>
										<entry> The occurrence number is out of range.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The creocc statement creates an empty occurrence of Entity at the position
						indicated by OccurrenceNumber. </para>
					<para>If OccurrenceNumber is: </para>
					<itemizedlist>
						<listitem>
							<para>&lt; 0—occurrence is added (appended) after the last occurrence in
								the hitlist ($hits+1). </para>
						</listitem>
						<listitem>
							<para>0—empty occurrence is created, using the current occurrence
								number. The new occurrence is inserted before the old active
								occurrence, so the effect is to increase all subsequent occurrence
								sequence numbers by 1. </para>
						</listitem>
						<listitem>
							<para>From 1 to the current number of occurrences of Entity, plus 1
								(inclusive)—an empty occurrence is created at the indicated
								position. </para>
						</listitem>
						<listitem>
							<para>Greater than the current number of occurrences of Entity plus
								one—$status is set to -1 and no occurrence is created. </para>
						</listitem>
					</itemizedlist>
					<para>If the component contains only the default (empty) occurrence for an
						entity, the first use of creocc does not add an additional empty occurrence,
						while subsequent uses do. If the default occurrence contains either an
						initial value declared on the Define Component Field Properties form or a
						field assigned a value with the /init switch, it is treated as an existing
						occurrence and a second occurrence is created. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the creocc statement to create
						empty occurrences of an entity. The data originated as a text dump of a
						database of video tapes. The following Proc code shows the conversion from
						the raw (unformatted) text into more meaningful data: </para>
					<programlisting role="uniface"><![CDATA[; trigger: &lt;Execute&gt;
retrieve "VIDEO_DONE"   ; get video data (text)
setocc "VIDEO_DATA", 1  ; position at first occurrence
$10 = 0                 ; zero counter
repeat
   message/nobeep "loop counter = %%$10"
   creocc "VIDEO_DONE", -1  ; make an empty occurrence
   if ($status &lt; 0)
      break
   endif
   V_NUM.VIDEO_DONE = TAPE_NUM.VIDEO_DATA
   $1 = START         ; load start time (text) into $1
   call TEXT_TO_TIME  ; convert to time storage, --&gt; $2
   V_START = $2
   $1 = end           ; do the same for end time
   call TEXT_TO_TIME
   V_END = $2
   V_TITLE_1.VIDEO_DONE = "%%TITLE_1.VIDEO_DATA%%TITLE_1A.VIDEO_DATA"
   V_TITLE_2.VIDEO_DONE = "%%TITLE_2.VIDEO_DATA%%TITLE_2A.VIDEO_DATA"
   $10 = $10 + 1
   setocc "VIDEO_DATA", ($curocc + 1)
   if ($status &lt; 0)
      break
   endif
until ($10 = $hits)
edit]]></programlisting>
					<para>If you want to change the behavior of the Add/Insert Occurrence trigger,
						you can include a creocc statement in the trigger. For example: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Add/Insert Occurrence
if ($rettype = 65)
   creocc "INVOICE", $curocc + 1  ; add occurrence after current
else
   creocc "INVOICE", $curocc      ; insert occurrence before current
endif
numgen "INV_COUNT", 1, $variation ; generate new invoice number
INV_NUM/init = $result            ; set new invoice number ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.condition">
				<title>condition [DEPRECATED]</title>
				<para>
					<warning>
						<para> The command <function>condition</function> was replaced by <link
								linkend="langref.dollar_condition">
								<function>$condition</function>
							</link> in Uniface 8. Compiling this statement will result in a compile
							warning: <literal>warning: 1000 - Deprecated function 'condition'
								used</literal>. </para>
						<para> In U8 the function <link
								linkend="langref.dollar_condition">
								<function>deleteinstance</function>
							</link> was introduced to replace <literal>condition</literal>. </para>
						<para> Deprecated since: U8. </para>
					</warning>
				</para>
			</sect1>
			<sect1 xml:id="langref.cos">
				<title>cos [DEPRECATED]</title>
				<para>
					<warning>
						<para> The command <function>cos</function> was replaced by <link
								linkend="langref.dollar_cos">
								<function>$cos</function>
							</link> in Uniface 8. Compiling this statement will result in a compile
							warning: <literal>warning: 1000 - Deprecated function 'cos'
								used</literal>. </para>
						<para> In U8 the function <link
								linkend="langref.dollar_cos">
								<function>$cos</function>
							</link> was introduced to replace <literal>cos</literal>. </para>
						<para> Deprecated since: U8. </para>
					</warning>
				</para>
			</sect1>
			<sect1 xml:id="langref.curocc_video">
				<title>curocc_video [DEPRECATED]</title>
				<para>
					<warning>
						<para> The command <function>curocc_video</function> was replaced by <link
								linkend="langref.curoccvideo">
								<function>curocc_video</function>
							</link> in Uniface 8. Compiling this statement will result in a compile
							warning: <literal>warning: 1000 - Deprecated function 'curocc_video'
								used</literal>. </para>
						<para> In U8 the function <link
								linkend="langref.curoccvideo">
								<function>curoccvideo</function>
							</link> was introduced to replace <literal>curocc_video</literal>. </para>
						<para> Deprecated since: U8. </para>
					</warning>
				</para>
			</sect1>
			<sect1 xml:id="langref.curoccvideo">
				<title>curoccvideo</title>
				<para> Introduced in: U8 </para>
				<para>Set the video properties for fields of the current occurrence. </para>
				<warning>
					<para>This function is deprecated (or is it?) please ues $curoccvideo</para>
				</warning>
				<sect2>
					<title>Syntax</title>
					<para>curoccvideo {/inner | /up} {/off} {Entity}{, AttributeList} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/inner—apply the video properties to all inner entities of the
									current occurrence, but not to the specified entity itself.
								</para>
							</listitem>
							<listitem>
								<para>/up—apply the video properties only to inner entities that are
									painted as up entities within the specified entity. </para>
							</listitem>
							<listitem>
								<para>/off—turn off video highlighting for the current occurrence;
									if the /inner switch is present, video highlighting is turned
									off for inner entities only. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—name of an entity. Can be a string, or a field,
									variable, function, or parameter that evaluates to a string. If
									Entity is "*", the video properties are applied to all entities
									in the form. If Entity is omitted, only the current entity is
									affected. </para>
							</listitem>
							<listitem>
								<para>AttributeList—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string. The
									string should evaluate to: <itemizedlist>
										<listitem>
											<para>DEF, to set the default video attributes for the
												current occurrence. (The default video attributes
												are determined by the assignment setting
												$DEF_CUROCC_VIDEO.) </para>
										</listitem>
										<listitem>
											<para>NON, to set no special video attributes for the
												current occurrence. In character mode, this means
												that fields, which appear in inverse by default,
												appear in normal video; this can create a sort of
												highlighting effect. </para>
										</listitem>
										<listitem>
											<para>One or more video attributes, separated by GOLD
												semicolons ( <emphasis role="underline">;</emphasis>
												) or by commas (,). </para>
										</listitem>
									</itemizedlist></para>
								<para>If AttributeList is omitted, DEF is assumed. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Any video properties defined for the active field (with the assignment
						setting $ACTIVE_FIELD) override those defined for the current occurrence.
						This allows the active field to be visible within the active occurrence, if
						you have chosen appropriate video properties. Video properties set with the
						fieldvideo instruction override the video properties for the active field as
						well as for the active occurrence. </para>
					<para>You can use the assignment setting $CUROCC_VIDEO to enable the
						highlighting of the active occurrence in all forms of the application, using
						the default video attributes defined with $DEF_CUROCC_VIDEO. This acts as if
						the following Proc statement were executed for each form: </para>
					<programlisting role="uniface"><![CDATA[curoccvideo "*","DEF"]]></programlisting>
				</sect2>
				<sect2>
					<title>Setting Video Properties</title>
					<para>The curoccvideo statement sets the video properties for the fields of the
						current occurrence. Used without a switch, curoccvideo applies these
						properties to fields of Entity. </para>
					<para>Using the /inner or /up switch excludes the calling entity, so only inner
						or upper entities, respectively, are altered with these switches. For
						example, the following statement affects only the inner entities of
						MyOuterEntity:</para>
					<programlisting role="uniface"><![CDATA[curoccvideo/inner "MyOuterEntity", "BRI"]]></programlisting>
					<para><emphasis role="bold">Note:</emphasis> The curoccvideo statement does not
						affect an entity that is painted with a single occurrence, unless that
						entity is painted as an up entity and the outer entity is painted with
						multiple occurrences.</para>
				</sect2>
				<sect2>
					<title>Video Attributes</title>
					<table>
						<title>Table 1. Video attribute codes</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Code </entry>
									<entry> Description </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> BLI </entry>
									<entry> Blinking </entry>
								</row>
								<row>
									<entry> BOR </entry>
									<entry> Border </entry>
								</row>
								<row>
									<entry> BRI </entry>
									<entry> Bright </entry>
								</row>
								<row>
									<entry> HLT </entry>
									<entry> Use system highlight color</entry>
								</row>
								<row>
									<entry> INV </entry>
									<entry> Inverse </entry>
								</row>
								<row>
									<entry> UND </entry>
									<entry> Underline </entry>
								</row>
								<row>
									<entry> COL= <emphasis role="italic">n </emphasis></entry>
									<entry> Set color to color code n, the sum of the color numbers
										for foreground and background. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example causes the fields of the current occurrences of all
						inner entities that are painted as up entities within the entity Customer to
						appear with white letters on a blue background. The color number is
						determined by adding 56 (black foreground) and 1 (blue background). </para>
					<programlisting role="uniface"><![CDATA[curoccvideo/up "CUSTOMER", "COL=57"]]></programlisting>
					<para>The following example turns off highlighting of fields of the current
						occurrences of all inner entities within the entity ENT1, but not of ENT1
						itself.</para>
					<programlisting role="uniface"><![CDATA[curoccvideo/inner/off "ENT1"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.debug">
				<title>debug</title>
				<para>Start the interactive Debugger. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$debug</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The debug statement causes the component to enter debug mode. On the
						client in a GUI environment, it starts the Debugger form enabling you to
						enter debugging commands. On a client running in character mode, a debug
						command line appears at the bottom of the screen.</para>
					<para>During the development process, it is quite common to place the debug
						statement in the application-level Switch Keyboard trigger. This statement
						should be removed once the system goes into production, or embedded in a
						conditional instruction so that it can only be invoked in specific
						circumstances. Alternatively, you can use the /deb switch to start the
						application and the Debugger. </para>
				</sect2>
				<sect2>
					<title>Debugging the Uniface Server</title>
					<para>The debug statement is not implemented for the Uniface Server. The
						Debugger is neither started nor stopped at a debug statement. This is
						because a server process on Windows NT is not able to start a windowing
						application that needs a desktop to run on. </para>
					<para>To debug the server application shell, you must start the Debugger before
						the Uniface Server is started, either manually or by means of the Uniface
						Router. If you want to run the Debugger on a different machine, you should
						configure a unique TCP port for the communication. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the debug statement: </para>
<programlisting role="uniface"><![CDATA[;Exec trigger 
debug
edit
end ; end trigger
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Enabling the Debugger in a Deployed Application</title>
					<para>To enable the debugger to be started in a deployed application:</para>
					<orderedlist>
						<listitem>
							<para>Add the following Proc code to the Switch Keyboard trigger of the
								application shell:
<programlisting role="uniface"><![CDATA[; Switch keyboard trigger
if ($logical("SwitchKeyboard") = "debug")
debug
endif]]></programlisting></para>
						</listitem>
						<listitem>
							<para>If debugging is required for some reason in the deployed
								application, add SwitchKeyboard=debug to the [LOGICALS] section of
								the assignment file, and activate the trigger by pressing GOLD Y.
							</para>
						</listitem>
					</orderedlist>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.delete">
				<title>delete</title>
				<para>Deletes the current occurrence from the database. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$delete</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by delete in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Data was successfully deleted. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> No entities are painted on the component. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> Occurrence not found. </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -5 </entry>
										<entry> Update request for nonupdatable occurrence. </entry>
									</row>
									<row>
										<entry> -6 </entry>
										<entry> Exceptional I/O error on write request; for example,
											lack of disk space, no write permission, or violation of
											a database constraint. Check the message frame for
											details. </entry>
									</row>
									<row>
										<entry> -11 </entry>
										<entry> Occurrence already locked. </entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								delete</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> &lt;UGENERR_ERROR&gt; </entry>
										<entry> An error occurred. No entities are painted on the
											component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The delete statement deletes the current occurrence from the database.
						This statement should only be used in the Delete trigger and, with extreme
						caution, in the Delete Up trigger. If you do place it in another trigger,
						make sure that you lock the occurrence as soon as possible. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the delete statement: </para>
					<programlisting role="uniface"><![CDATA[trigger _delete delete
end ;end trigger]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.delete_instance">
				<title>delete_instance [DEPRECATED]</title>
				<warning>
					<para> The command <function>delete_instance</function> was replaced by <link
							linkend="langref.deleteinstance">
							<function>deleteinstance</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated statement 'delete_instance'
							used</literal>. </para>
					<para> In U8 the function <link
							linkend="langref.deleteinstance">
							<function>deleteinstance</function>
						</link> was introduced to replace <literal>delete_instance</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.deleteinstance">
				<title>deleteinstance</title>
				<para> Introduced since: U8 </para>
				<para>Deletes an instance of a component. </para>
				<sect2>
					<title>Syntax</title>
					<para> deleteinstance InstanceName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>InstanceName—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string. The
									string should contain the name of the instance to be removed.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0</entry>
										<entry> The instance was successfully deleted. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								deleteinstance</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -162 </entry>
										<entry> &lt;UACTERR_DELETE_INSTANCE&gt; </entry>
										<entry> Deleting the instance has been postponed because the
											instance is busy. For example, operation A1 in INSTA
											activates operation B1 in INSTB. Operation B1, in turn,
											activates operation A2 in INSTA. Operation A2 performs
											an exit, but INSTA cannot be deleted until operations B1
											and A1 complete. </entry>
									</row>
									<row>
										<entry> -163 </entry>
										<entry> &lt;UACTERR_DEL_POSTPONED_CHILD&gt; </entry>
										<entry> Deleting the instance has been postponed because the
											instance has at least one busy child instance. The
											instance will be deleted when it no longer has busy
											children. For example, non-modal form FRMX starts an
											attached non-modal form FRMY. While the application is
											idle, the user clicks on FRMY, activating a trigger
											which sends a message to FRMX. This message results in
											an exit (on FRMX), but FRMX cannot be deleted until its
											child instance FRMY is not busy. </entry>
									</row>
									<row>
										<entry> -164</entry>
										<entry> UACTERR_DEL_POSTPONED_PROC </entry>
										<entry> The instance is in the process of being deleted. For
											example, between a deleteinstance or exit and the time
											the instance is actually deleted, an attempt is made to
											activate an operation in the instance being deleted.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The deleteinstance statement removes the instance named InstName, and all
						child instances, from the component pool. </para>
					<para>If the Operations trigger of any of the instances being removed contains
						an operation named CLEANUP, that operation is executed before the instance
						is removed. </para>
				</sect2>
				<sect2>
					<title>Example: Creating and Deleting Instances</title>
					<para>In the following example, the Application Execute trigger starts a
						sequence of non-modal forms before allowing the user to take control of the
						application. When control returns to this trigger, the Proc code removes any
						detached instances that are still in the component pool. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Application Execute
; start the initial forms
newinstance "form10",$1,"MODALITY=NON-MODAL"
newinstance "form20",$2,"MODALITY=NON-MODAL"
newinstance "form40",$3,"MODALITY=NON-MODAL"
; show them
$1-&gt;EXEC()
$2-&gt;EXEC()
$3-&gt;EXEC()
; let the user play
; control returns to me, so clean up any detached instances
getitem $1, $detachedinstances, 1
while ( $status &gt; 0 )
   deleteinstance $1
   getitem $1, $detachedinstances, 1
endwhile ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.delitem">
				<title>delitem</title>
				<para>Deletes an item from a list. </para>
				<sect2>
					<title>Syntax</title>
					<para>delitem List , N </para>
					<para>delitem/id{/case} List , Index </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/id—delete the item with the value Index from an associative list.
							</para>
						</listitem>
						<listitem>
							<para>/case—match the case specified in Index. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>List—field, indirect reference to a field, variable, or
									assignable function that can accept a string value. The string
									should contain the list from which an item is to be deleted.
								</para>
							</listitem>
							<listitem>
								<para>N—constant, or field (or indirect reference to a field),
									variable, or function that can be converted to a whole (integer)
									number; the value will be truncated to form an integer. The
									integer represent the number of the item in an indexed list.
									(Items are numbered starting with 1.) </para>
							</listitem>
							<listitem>
								<para>Index—string, or field (or indirect reference to a field),
									variable, or function that evaluates to a string representing a
									value in an associative list; it cannot be an expression.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> No item was deleted</entry>
								</row>
								<row>
									<entry> &gt;0</entry>
									<entry> Item number of the item that was deleted from List
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The delitem statement deletes an item from List. (For information on the
						structure of lists, see Lists and Sublists .) </para>
					<para>To delete all items from a list, set the list equal to an empty string
						("") using an assignment; for example, if the variable $1 contains a list,
						the following statement creates an empty list: </para>
					<programlisting role="uniface"><![CDATA[$1 = ""
]]></programlisting>
				</sect2>
				<sect2>
					<title>Indexed lists</title>
					<para>Use the delitem statement without switches to delete the N th item from
						List. </para>
					<para>If List contains an associative list, the entire ValRep for the N th item
						is deleted. If N is -1, the last item in List is deleted. Otherwise, if N
						does not refer to an existing item, no item is deleted. </para>
				</sect2>
				<sect2>
					<title>Associative lists</title>
					<para>Use the /id switch to delete the item whose value is Index from an
						associative list. </para>
					<para>By default, matching Index with item values is not case-sensitive. For
						example, the following statement deletes from $LIST$ the first item
						encountered whose value is ab, Ab, aB, or AB: </para>
					<programlisting role="uniface"><![CDATA[delitem/id $list$,"ab"
]]></programlisting>
					<para>Use the /case switch with /id to cause the matching to be case-sensitive.
						For example, the following statement only deletes an item whose value is ab: </para>
					<programlisting role="uniface"><![CDATA[delitem/id/case $list$,"ab"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para><emphasis role="bold"> Note:</emphasis> In the examples below, an
						underlined semicolon ( <emphasis role="underline">; </emphasis>) represents
						the Uniface subfield separator (by default, GOLD ;). </para>
					<para>The following example deletes the third item from an indexed list. </para>
					<programlisting role="uniface"><![CDATA[$valrep(DBMSFLD) = "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb"
; ValRep is "rms;ora;syb;rdb"
delitem $valrep(DBMSFLD), 3
; ValRep is "rms;ora;rdb"
]]></programlisting>
					<para>The same item could also be deleted by treating the list as an associative
						list: </para>
					<programlisting role="uniface"><![CDATA[$valrep(DBMSFLD) = "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb"
; ValRep is "rms;ora;syb;rdb"
delitem/id $valrep(DBMSFLD), "syb"
; ValRep is "rms;ora;rdb"
]]></programlisting>
					<para>The following example deletes the item with the value 'tue' from an
						associative list: </para>
					<programlisting role="uniface"><![CDATA[$valrep(DATEFLD) = "mon=monday<emphasis role="underline">;</emphasis>tue=tuesday<emphasis role="underline">;</emphasis>wed=wednesday"
; ValRep is "mon=monday;tue=tuesday;wed=wednesday"
delitem/id $valrep(DATEFLD), "TUE"
; ValRep is "mon=monday;wed=wednesday"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dircreate">
				<title>dircreate</title>
				<para>Create the specified directory in the working directory.</para>
				<para> Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para>dircreate NewDirPath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>NewDirPath—directory name, optionally preceded by the path to the
						directory, which can be in a zip archive. Must end with a directory
						separator. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The dircreate statement creates the specified directory in the current
						working directory using any file redirections in the assignment file.
					</para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if NewDirPath:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Does not permit user-creation due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Unix</title>
					<para>On Unix, the directory is created with read and write access on world,
						group, and user level.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On iSeries, dircreate creates a library or a file in a library or, when
						the IFS prefix is used, a directory in the IFS.</para>
					<para>If used without the IFS prefix, a library, or a file in a library, is
						created. Libraries cannot have sublibraries, so no more than one directory
						separator is allowed. That is, the only allowed syntax is library/ or file
						or library/file. </para>
					<para>If used with the IFS prefix, an IFS directory is created. Directories in
						the IFS can have subdirectories, but the different file systems existing in
						the IFS have their own rules and limitations. </para>
					<para>For more information, see File-Naming Considerations on iSeries.</para>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On z/OS, dircreate can create a directory in an HFS system or a PDS in a
						partioned dataset system. However it does not create a prefix (the dataset
						structure to which the concept of directory is mapped) in a sequential
						dataset.</para>
					<para>If used with the HFS: prefix, dircreate creates a directory as
						expected.</para>
					<para>If used with the prefixes DNS:, TSO:, or ! prefix: </para>
					<itemizedlist>
						<listitem>
							<para>If the specified name ends with () or starts with @ to indicate a
								PDS, dircreate creates an empty PDS. For example:
<programlisting role="uniface"><![CDATA[
dircreate("@DSN:A/B/C")
dircreate ("DSN:A/B/C()")
]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>Otherwise, it does nothing but reports success. An error status is
								returned only if there is already a dataset that starts with
								specified name. </para>
							<para>For example, the following instruction to create a directory path
									<emphasis role="bold">A.B.C</emphasis> does nothing because
								sequential datasets use file name prefixes. The concept of a
								directory as container of files does not exist.
								<programlisting role="uniface"><![CDATA[dircreate("DSN:A/B/C")]]></programlisting></para>
						</listitem>
					</itemizedlist>
					<para>If no prefix is specified, Uniface sets it to TSO:, for example, a/b/c
						becomes TSO:a.b.c. and dircreate behaves as described above. </para>
					<para>For more information, see File-Naming Considerations on z/OS.</para>
				</sect2>
				<sect2>
					<title>Example: Creating a Directory in the Current Working Directory</title>
					<para>The following Proc code creates a directory with the name <emphasis
							role="bold">coffee</emphasis> in the current working directory:</para>
					<programlisting role="uniface"><![CDATA[dircreate "coffee"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Creating a Directory in an Existing Directory</title>
					<para>The following Proc code creates a directory with the name <emphasis
							role="bold">coffee</emphasis> in the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory:</para>
					<programlisting role="uniface"><![CDATA[dircreate "sub1dir\coffee\"
]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[dircreate "[.sub1dir.coffee.]"
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dirdelete">
				<title>dirdelete</title>
				<para> Introduced in: U9 </para>
				<para>Delete the specified directory. </para>
				<sect2>
					<title>Syntax</title>
					<para> dirdelete DirPath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>DirPath—directory name, optionally preceded by the path to the directory.
						The directory can be located in a ZIP archive. Must end with a directory
						separator. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The dirdelete statement deletes the specified directory DirPath, using any
						file redirections in the assignment file. </para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if DirPath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a directory </para>
						</listitem>
						<listitem>
							<para>Is the current directory or root </para>
						</listitem>
						<listitem>
							<para>Is not empty </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-deletion due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>When used without the IFS prefix, deleting libraries is only possible for
						libraries that are not in use and not on your own or somebody else’s library
						list. The same applies for files in libraries. Negative return values can be
						expected.</para>
					<para>When used with an IFS prefix, directories are deleted as expected.</para>
					<para>For more information, see File-Naming Considerations on iSeries.</para>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On z/OS, ldirdelete can delete an empty directory in an HFS system or an
						empty PDS in a partioned dataset system. However it does not delete a prefix
						(the dataset structure to which the concept of directory is mapped) in a
						sequential dataset.</para>
					<para>If used with the HFS: prefix, ldirdelete deletes a directory as
						expected.</para>
					<para>If used with the prefixes DNS:, TSO:, or ! prefix: </para>
					<itemizedlist>
						<listitem>
							<para>If the specified name starts with @ or ends with () to indicate a
								PDS, ldirdelete deletes an empty PDS. For example:
								<programlisting role="uniface"><![CDATA[ldirdelete("@DSN:A/B/C")
ldirdelete ("DSN:A/B/C()")]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>Otherwise, it does nothing but reports success. An error status is
								returned only if there is already a dataset that starts with
								specified name, in which case it is considered to be not empty.
							</para>
						</listitem>
					</itemizedlist>
					<para>If no prefix is specified, Uniface sets it to TSO:, for example, a/b/c
						becomes TSO:a.b.c. and ldirdelete behaves as described above. </para>
					<para>For more information, see File-Naming Considerations on z/OS.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc code deletes the directory <emphasis role="bold"
							>tea</emphasis> if it is empty and the user confirms that it may be
						deleted:</para>
					<programlisting role="uniface"><![CDATA[$dir$ = "drinks\tea\"
; or $dir$ = "drinks/tea/"
; or $dir$ = "[drinks.tea]"
if ($dirlist($dir$,"dir") = "" &amp; $dirlist($dir$,"file") = "")
   askmess/warning "Do you want to delete '%%$dir$'?", "Yes, No"
   if ($status = 1) 
      ldirdelete $dir$
   else
   message/error "Directory '%%$dir$' is not empty!"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.dirrename">
				<title>dirrename</title>
				<para> Introduced in: U9 </para>
				<para>Rename the specified directory.</para>
				<para>
					<warning>
						<para>DVO: I was expecting some references to iSeries and z/OS same as in
							dirdelete and dircreate. Furthermore this has a reference to AS400 which
							is kiackin in the dirdelete and dircreate section </para>
					</warning>
				</para>
				<sect2>
					<title>Syntax</title>
					<para>dirrename DirPath , NewDirName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>DirPath—directory name, optionally preceded by the path to the
								directory.Must end with a directory separator. </para>
						</listitem>
						<listitem>
							<para>NewDirPath—new directory name, optionally preceded by the path to
								the directory. Must end with a directory separator. </para>
						</listitem>
					</itemizedlist>
					<para>The directory can be located in a zip archive. See Syntax of File and
						Directory Names.</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The dirrename statement renames the specified directory DirPath to
						NewDirName, taking file redirections in the assignment file into account. </para>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Operation failure</title>
					<para>The operation fails if DirPath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a directory </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is not empty </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Is the current directory or root </para>
						</listitem>
						<listitem>
							<para>Does not permit user-renaming due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if NewDirName:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>AS/400</title>
					<para>Renaming libraries is only possible for libraries that are not in use and
						not on somebody else's library list. Therefore, the Proc programmer must be
						prepared for a negative return value when renaming libraries. The same
						applies for files in libraries. IFS directories can be renamed in the same
						way as on Unix systems.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc code renames the directory <emphasis role="bold"
							>drinks\coffee</emphasis> to <emphasis role="bold"
						>drinks\tea</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[dirrename "drinks\coffee\", "tea"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[dirrename "[drinks.coffee]", "tea"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.discard">
				<title>discard</title>
				<para>Remove one or more occurrences from the component and the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para> discard {Entity}{, FromOccurrence{, ToOccurrence}} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity to be discarded. Can be a string, or a field,
									variable, function, or parameter that evaluates to a string
									containing the entity name. If omitted, occurrences are removed
									from the current entity. </para>
							</listitem>
							<listitem>
								<para>FromOccurrence and ToOccurrence—position of the occurrence in
									the hitlist; can be a constant, or field (or indirect reference
									to a field), variable, or function that can be converted to a
									whole (integer) number; the value will be truncated to form an
									integer. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by discard in $status</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &gt;0 </entry>
										<entry> The sequence number of the occurrence that is now
											current after discarding an occurrence. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> No next occurrence is available. The occurrence is
											the last occurrence or there is only one occurrence.
										</entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> The FromOccurrence was greater than the number of
											available occurrences. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> Entity EntityName does not exist or is not painted
											in the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								discard</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The discard statement removes one or more occurrences of Entity from the
						component and from the hitlist. </para>
					<para>The main use of the discard statement is to release memory in large batch
						jobs, resulting in better performance. For optimum use of such a process, it
						is recommended that the time between the occurrence being processed and the
						occurrence being discarded is not too long. </para>
					<para>The behavior following discard is governed by the location of the
						discarded occurrence: </para>
					<itemizedlist>
						<listitem>
							<para>If the discarded occurrence is not the last occurrence, the
									<emphasis role="italic">next</emphasis> occurrence is made
								active after a discard. </para>
						</listitem>
						<listitem>
							<para>If the discarded occurrence is the last occurrence, the <emphasis
									role="italic">previous</emphasis> occurrence is made active
								after discard. </para>
						</listitem>
						<listitem>
							<para>If the component contains only one occurrence, that occurrence is
								discarded and a new, empty occurrence becomes the <emphasis
									role="italic">current</emphasis> occurrence. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> The values of $curocc, $curhits,
						$dbocc, $hits, $totdbocc, and $totocc are all altered by discard. </para>
				</sect2>
				<sect2>
					<title>Discarding a Range of Occurrences</title>
					<para>Use FromOccurrence and ToOccurrence to specify a range of occurrences to
						be discarded: </para>
					<itemizedlist>
						<listitem>
							<para>If both FromOccurrence and ToOccurrence are specified, that range
								of occurrences, inclusive, is discarded. </para>
						</listitem>
						<listitem>
							<para>If ToOccurrence is omitted, FromOccurrence is discarded. If
								FromOccurrence is -1, the last occurrence is discarded. </para>
						</listitem>
						<listitem>
							<para>If both FromOccurrence and ToOccurrence are omitted, the current
								occurrence is discarded. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> The discard statement affects
						currency in the same way as remocc. An implicit setocc in the affected
						entity is performed. This results in a change in the active path, which can
						cause the structure editor to activate certain data validation triggers. For
						more information, see Trigger Activation. </para>
				</sect2>
				<sect2>
					<title>Using discard in the Read Trigger</title>
					<para>After discarding an occurrence, Uniface makes another occurrence active.
						If this occurrence is not available in the component, the Read trigger for
						that entity is activated to get the data for the newly active occurrence. If
						the discard statement being executed occurs in the Read trigger of the
						entity being discarded, the Read trigger would be called recursively. After
						some number of these calls, a stack overflow error can occur, ending the
						application. </para>
					<para>To prevent this problem, <emphasis role="italic">in the Read trigger of
							the entity being discarded only </emphasis>, any code following a
						discard statement is ignored; the trigger ends immediately after the
						occurrence is discarded. If necessary, the trigger is reactivated to obtain
						data for the new active occurrence, but it is not called in a recursive
						manner. In the following example, the putmess statements are never executed
						because the Read trigger ends following the discard statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read
read
$1 = PKEY
if ( INVDATE &lt; $date("1-jan-96") )
   discard
   putmess "Discarded: %%$1"
endif
putmess "Kept: %%$1"
]]></programlisting>
					<para><emphasis role="bold"> Note:</emphasis> If the discard statement occurs in
						an operation or in a local or global Proc that is called from the Read
						trigger, this behavior is circumvented, leading to the possibility of a
						stack overflow error. </para>
					<para>In the following example, the putmess statements <emphasis role="italic"
							>are </emphasis>executed because the discard statement occurs in a local
						Proc module. Be aware that this situation can result in a stack overflow
						error since the Read trigger may be called recursively. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read
read
call CHECK_DISCARD
; trigger: Local Proc Modules
entry CHECK_DISCARD
$1 = PKEY
if ( INVDATE &lt; $date("1-jan-96") )
   discard
   putmess "Discarded: %%$1"
endif
putmess "Kept: %%$1"
]]></programlisting>
					<para>It is recommended that you avoid situations in which a discard statement
						occurs in the Read trigger of an inner entity and the entity being discarded
						is an outer entity. This kind of action has a serious impact on the active
						path and can have unpredictable results. If this kind of behavior is
						required, a better approach would be to use a variable to set a flag and
						have the Read trigger of the outer entity perform the discard. </para>
					<para>For example, consider a report component where you want to show only
						customers who have not placed an order since a certain cutoff date; the
						entity ORDER is painted inside the entity CUSTOMER. The decision whether to
						keep a customer for the report or discard it is based on the values of the
						field DATE_OF_ORDER for occurrences of the inner entity. Rather than
						performing the discard in the Read trigger of an inner entity, you can
						arrange to discard the CUSTOMER occurrence from the Read trigger of an outer
						entity. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read (of outer entity CUSTOMER)
; assume customer guilty till proven innocent
; retrieve all orders for this customer
; "setocc" changed current entity to ORDER
; trigger: Read (of inner entity ORDER)
; found a recent order
$RECENT_ORDER$ = FALSE
read
setocc "ORDER", -1
if ($RECENT_ORDER$ = TRUE)
   discard "CUSTOMER"
endif
read
if (DATE_OF_ORDER &gt; $CUTOFF_DATE$) ; found a recent order
   $RECENT_ORDER$ = TRUE
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to get optimum use of the discard
						statement in a batch process: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
retrieve
if ($status &lt;0)
   return ($status)
endif
repeat
   discard "ENTITY"
until ($status &lt;=0)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.display">
				<title>display</title>
				<para>Presents the form on the screen as display-only. </para>
				<sect2>
					<title>Syntax</title>
					<para> display{/menu}{LitFieldName} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/menu—activates the &lt;Menu&gt; trigger at field, entity, form, or
						application level (the one at the lowest level that contains Proc code) when
						the form appears.</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>LitFieldName—literal name of the field in which to position the cursor; do
						not enclose the name in double quotation marks ("). The cursor is positioned
						in the field named.</para>
					<para>If LitFieldName is omitted or is not painted on the form, the cursor is
						positioned on the first painted field (that is, in the field nearest the top
						left corner of the form). </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The following values are returned in a normal client/server environment
						(that is, when $web =""). In a Web environment, the values returned by
						display are the same as those returned by webgen and webget. In this case,
						-16 is returned only if there is a network error. </para>
					<table>
						<title>Table 1. Values Returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 10 </entry>
									<entry> The user used ^QUIT to leave the form that was started
										with display. </entry>
								</row>
								<row>
									<entry> 9 </entry>
									<entry> The user used ^ACCEPT to leave the form that was started
										with display. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Success. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> The application is running in batch mode. Use a test on
										$batch to avoid this. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							$display</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -33 </entry>
									<entry> &lt;UGENERR_BATCH_ONLY&gt; </entry>
									<entry> Statement not allowed in batch mode. Use a test on
										$batch to avoid this. </entry>
								</row>
								<row>
									<entry> -1401 </entry>
									<entry> &lt;UPROCERR_PROMPT&gt; </entry>
									<entry> Prompted field not valid. </entry>
								</row>
								<row>
									<entry> -1402 </entry>
									<entry> &lt;UPROCERR_STATEMENT&gt; </entry>
									<entry> Statement not allowed in this trigger. The display
										statement is not in an Execute trigger. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in the Execute trigger of form components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The display statement presents the current form as display-only. Data in
						the form cannot be modified. (You can also use newinstance with the instance
						property DISPLAY=TRUE or run/display to start a form in display-only mode.)
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to use the display statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
CUST_NBR = $1
retrieve
message "%%$hits customers match search profile"
display CUSTNAME
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.displaylength">
				<title>displaylength</title>
				<para> Introduced since: U8 </para>
				<para>Return the display length of a String when displayed in the system character
					set. </para>
				<warning>
					<para>Why are there two of these commands. IMHO this one is deprecated and
						$displaylength should be used.</para>
				</warning>
				<sect2>
					<title>Syntax</title>
					<para>displaylength String </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Setting $status has no effect on subsequent processing. </para>
					<para>Setting $result returns the length of String when displayed in the system
						character set. The length is expressed in bytes.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.done">
				<title>done</title>
				<para>Exit from the Proc module without changing $status.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$done</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The done statement does not affect $status. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The statement done immediately exits from the Proc module. If you want to
						return a value, use the return statement rather than done. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to use the done statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Quit
if ($formmod = 0)
   done
else
   message "Data modified!! Use STORE before QUIT."
   return (-1)
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.e">
				<title>e [DEPRECATED]</title>
				<para>
					<warning>
						<para> The command <function>e</function> was replaced by <link
								linkend="langref.dollar_e">
								<function>$e</function>
							</link> in Uniface 8. Compiling this statement will result in a compile
							warning: <literal>warning: 1000 - Deprecated function 'e'
							used</literal>. </para>
						<para> In U8 the function <link linkend="langref.dollar_e">
								<function>$e</function>
							</link> was introduced to replace <literal>e</literal>. </para>
						<para> Deprecated since: U8. </para>
					</warning>
				</para>
			</sect1>
			<sect1 xml:id="langref.edit">
				<title>edit</title>
				<para>Present the form and start the structure editor for user input. </para>
				<sect2>
					<title>Syntax</title>
					<para>edit /modal {/deferred} | /nonmodal </para>
					<para>edit{/menu | /nowander} {LitFieldName} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/modal—displays the form and starts the structure editor. When
									the structure editor session is terminated, any statements after
									the edit/modal statement are executed. Currently, the edit/modal
									statement can be used only in modal forms. </para>
							</listitem>
							<listitem>
								<para>/deferred—displays the form and starts the structure editor
									only after the operation containing the edit statement has
									returned control to the Proc code that invoked the operation.
								</para>
							</listitem>
							<listitem>
								<para>/nonmodal—displays the form and starts the structure editor.
									The statements following the edit/nonmodal are immediately
									executed, that is, processing continues while the structure
									editor is running. Currently, the edit/nonmodal statement can be
									used only in non-modal forms. </para>
							</listitem>
							<listitem>
								<para>/menu—activates the &lt;Menu&gt; trigger at field, entity,
									form, or application level (whichever is lowest) when the form
									appears. </para>
							</listitem>
							<listitem>
								<para>/nowander—restricts the movement of cursor keys on the form.
									Structure editor functions such as ^NEXT_FIELD, ^PREV_FIELD, and
									so on, work as normal, but the cursor keys (including next and
									previous screen) work only within a field. In this case, the
									field acts as if it were in Zoom mode; that is, cursor keys
									scroll the field contents and cannot be used to leave a field. </para>
								<para>If the form is used with a GUI driver, the mouse <emphasis
										role="italic">cannot </emphasis>be used to change the
									location of the cursor. Automatic scroll bars are also disabled. </para>
								<para>If LitFieldName is omitted when the /nowander switch is given,
									the prompt is positioned on the first field of the form, that
									is, on the field nearest the top left corner of the form.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>LitFieldName—literal name of a field on the form in which the cursor
						should be positioned; do not enclose the name in double quotation marks (").
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The following values are returned by edit in a normal client/server
						environment (that is, when $web =""). In a Web environment, the values are
						the same as those returned by webgen and webget. In this case, -16 is
						returned only if there is a network error. </para>
					<table>
						<title>Table 1. Values Returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Success. </entry>
								</row>
								<row>
									<entry> 9 </entry>
									<entry> The user used ^ACCEPT to leave the form that was started
										with edit. </entry>
								</row>
								<row>
									<entry> 10 </entry>
									<entry> The user used ^QUIT to leave the form that was started
										with edit. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> The edit statement is not in an Execute trigger or there
										are no promptable fields on the form. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> An edit is attempted when in batch mode. Use a test on
										$batch to avoid this. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							edit</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -33 </entry>
									<entry> &lt;UGENERR_BATCH_ONLY&gt; </entry>
									<entry> Statement not allowed in batch mode. Use a test on
										$batch to avoid this. </entry>
								</row>
								<row>
									<entry> -1401 </entry>
									<entry> &lt;UPROCERR_PROMPT&gt; </entry>
									<entry> Prompted field not valid. </entry>
								</row>
								<row>
									<entry> -1402 </entry>
									<entry> &lt;UPROCERR_STATEMENT&gt; </entry>
									<entry> Statement not allowed in this trigger. The edit
										statement is not in an Execute trigger. The edit statement
										is not allowed in a service. Use edit/modal or
										edit/nonmodal, as appropriate, to avoid this error. </entry>
								</row>
								<row>
									<entry> -1411 </entry>
									<entry> &lt;UPROCERR_EDITTWICE&gt; </entry>
									<entry> An edit statement was encountered when the structure
										editor was already active. This error also occurs when an
										activate is performed on a modal form that is already in
										edit mode and that has an empty Execute trigger (an implicit
										edit). </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>The first syntax format can be used only in operations defined in form
						components. The second syntax format is allowed only in the Execute trigger
						of form components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The edit instruction displays the form and starts the structure editor for
						user input. It can be placed either in an operation or in an Execute
						trigger. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If a form's Execute trigger is
						empty, it acts as if a simple edit statement (without any switch or
						argument) is present, a so called ‘implicit edit’. </para>
					<para>If LitFieldName is omitted or not painted on the form, the cursor is
						positioned in the first painted field (that is, in the field nearest the top
						left corner of the form). </para>
					<para>If LitFieldName is present or if the /nowander switch is used, the edit
						statement causes the Occurrence Gets Focus trigger to be activated.</para>
				</sect2>
				<sect2>
					<title>edit Statements in Operations</title>
					<para>Although the edit statement can be used in triggers, it is recommended
						that it be used only in operations. When a modal form is invoked via edit in
						its Execute trigger, that particular instance of the form can no longer be
						addressed once processing in the Execute trigger completes. </para>
					<para>However, if the form is invoked via edit in an operation, the form will
						remain instantiated even after the operation has completed. This means that
						the structure editor can be started on a form without the need to recreate
						the form, and also that the form can be displayed as necessary using the
						show statement. </para>
					<para>When using the edit statement in an operation, you must specify the
						modality using either edit/modal or edit/nonmodal. </para>
					<para>If an edit/modal or edit/nonmodal statement is executed while the
						structure editor is running (that is, $interactive returns 1), an error is
						returned. </para>
				</sect2>
				<sect2>
					<title>edit Statements in a Web Application</title>
					<para>When the first syntax format of the edit statement is used in a Web
						environment, an HTML document is prepared and returned to the user's
						browser. </para>
					<para>When edit is encountered (explicitly or implicitly) in a form that is
						running in a Web environment, it acts as a webgen followed by a webget, and
						an HTML document is prepared and sent to the Web. The LitFieldName argument
						and the /menu and /nowander switches have no effect. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of edit in an Execute trigger:</para>
					<programlisting role="uniface"><![CDATA[trigger _exec
CUST_NBR = $1
retrieve
message "Selected customer ready for editing."
edit CUSTNAME
end ; end trigger
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Use of edit with parameters </title>
					<para>The following example shows how to use the edit statement in the Execute
						trigger, using parameter passing to make the form component self-contained: </para>
					<programlisting role="uniface"><![CDATA[trigger _exec
params
  string CustomerNumber: IN
endparams
CUST_NBR = CustomerNumber
retrieve
edit
end  ; end trigger
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Use of the edit/nonmodal</title>
					<para>The following example shows how to use the edit/nonmodal statement from an
						operation of a form component: </para>
					<programlisting role="uniface"><![CDATA[operation editCustomer
params
   string CustomerNumber: IN
endparams
   CUST_NBR = CustomerNumber
   retrieve
   edit/nonmodal
end
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.eject">
				<title>eject</title>
				<para>Eject a page when printing. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>eject</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0</entry>
										<entry> eject was successful. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								eject</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1404 </entry>
										<entry> &lt;UPROCERR_NO_PRINTING&gt; </entry>
										<entry> Not printing (that is, $printing is 0). The eject
											statement is ignored. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in presentation components (and in service components that are not
						self-contained), except in the Frame Gets Focus trigger of a header or
						trailer frame. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The eject statement forces a page break and causes Uniface to continue
						printing on the following page. It is recommended to place the eject
						statement in either the Occurrence Gets Focus trigger or Leave Printed
						Occurrence. </para>
					<para>The eject statement is ignored in the following circumstances: </para>
					<itemizedlist>
						<listitem>
							<para>Uniface is not printing (that is, $printing is 0). </para>
						</listitem>
						<listitem>
							<para>In the second or later occurrence of an entity that is painted
								with horizontal repetition. </para>
						</listitem>
						<listitem>
							<para>On an empty page. </para>
						</listitem>
						<listitem>
							<para>In the Frame Gets Focus trigger of a header or trailer
								frame.</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example starts a new page when the contents of the INVDATE
						field change: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Printed Occurrence
compare/next (INVDATE) from "INVOICE"    ;test if next date the same (or exists)
if ($result = 0)                         ;if next date exists and not the same
   eject                                 ;start printing on new page
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.else">
				<title>else</title>
				<para>Introduces a logical expression in an if/ednif conditional block.</para>
				<sect2>
					<title>Syntax</title>
					<para>See if.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.elsecase">
				<title>elsecase</title>
				<para>Marks the Proc code to be executed if none of the case expressions match in a
					selectcase block</para>
				<sect2>
					<title>Syntax</title>
					<para>See selectcase.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.elseif">
				<title>elseif</title>
				<para>Defines a condition to be evaluated in an if/endif conditional block.</para>
				<sect2>
					<title>Syntax</title>
					<para>See if.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.end">
				<title>end</title>
				<para>Marks the end of a Proc module, operation, or trigger. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>end</command>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The end statement does not affect the value of $status. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The end statement indicates the end of a Proc module or operation. If this
						statement is encountered during execution, an implicit done is executed and
						the module or operation ends, returning the current value of $status. If an
						entry or operation statement or the end of the trigger is encountered, an
						end (and implicit done) for the previous Proc module or operation is
						assumed. </para>
					<para>Proc statements after an end are not recognized unless they are part of
						another Proc module or operation. That is, if Proc statements following an
						end are meant to be executed, the statement immediately following the end
						should be an entry or operation statement. </para>
					<para>Labels defined with blockdata statements must be defined at the end of a
						Proc module or operation, before the end statement is encountered. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of end for a trigger and an entry
						statement: </para>
					<programlisting role="uniface"><![CDATA[trigger _store 
call LSTORE
end ; end trigger
]]></programlisting>
					<programlisting role="uniface"><![CDATA[; container: Local Proc Modules (component-level)
entry LSTORE
   store
   if ($status &lt; 0)
      message "Store error!"
      rollback
   else
      message "Store done."
      commit
   endif
end ; end LSTORE entry
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Defining an Operation</title>
					<para>The following example shows the operation DISCOUNT, defined in the
						Operations trigger of a service component named SERV1: </para>
					<programlisting role="uniface"><![CDATA[; Operations trigger of service SERV1
operation DISCOUNT
params
   string CUSTID : IN
   numeric AMOUNT : INOUT
   numeric PERCENTAGE : OUT
endparams
; no discount till proven otherwise
; 20% discount for Compuware
; 15% discount for Acme
; adjust amount
PERCENTAGE = 0
if ( CUSTID == "cpwr" ) PERCENTAGE = 20
if ( CUSTID == "acme" ) PERCENTAGE = 15
AMOUNT = AMOUNT * ( 100 - PERCENTAGE) / 100
end ]]></programlisting>
					<para>The operation DISCOUNT could be referenced from another component as
						follows: </para>
					<programlisting role="uniface"><![CDATA[activate "SERV1".DISCOUNT (ID.CUST, TOTAL.INVOICE, $DISCOUNT$)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.endif">
				<title>endif</title>
				<para>Defines the end of an if conditional block</para>
				<sect2>
					<title>Syntax</title>
					<para>See if. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.endparams">
				<title>endparams</title>
				<para>Defines the end of a params block.</para>
				<sect2>
					<title>Syntax</title>
					<para>See params.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.endscope">
				<title>endscope</title>
				<para> Introduced in: U9 </para>
				<para>Declare the end of a scope block. See scope.</para>
				<sect2>
					<title>Syntax</title>
					<para>public | partner web </para>
					<para>{scope </para>
					<para> {input </para>
					<para> {output}</para>
					<para> {operation InstanceSelector1.OperationSelector1 </para>
					<para> {operation InstanceSelectorN.OperationSelectorN} }</para>
					<para>{endscope}}</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.endselectcase">
				<title>endselectcase</title>
				<para>Defines the end of a selectcase conditional block</para>
				<sect2>
					<title>Syntax</title>
					<para>See selectcase.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.endvariables">
				<title>endvariables</title>
				<para>Defines the end of a variables block</para>
				<sect2>
					<title>Syntax</title>
					<para>See variables.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.endwhile">
				<title>endwhile</title>
				<para>Ends a while loop.</para>
				<sect2>
					<title>Syntax</title>
					<para>For more information, see while.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.entitycopy">
				<title>entitycopy</title>
				<para>Copy data from one DBMS or file to another. </para>
				<para> Introduced in: U9 </para>
				<sect2>
					<title>Syntax</title>
					<para> entitycopy Source , Target {, Options} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Source—database path and entity, or an XML file, to be copied,
								using the following syntax: <itemizedlist>
									<listitem>
										<para>Database object: Path : Entity . Model </para>
										<para>Either of both of Entity and Model can contain
											wildcards, for example DEF:ENT*.MOD* </para>
									</listitem>
									<listitem>
										<para>XML file: xml:{ZipArchive :}Filename </para>
										<para>For example, xml:myxmlfile.xml or
											xml:ziparchive.zip:myxmlfile.xml </para>
									</listitem>
									<listitem>
										<para>Uniface 8 TRX file: trx: Filename </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
						<listitem>
							<para>Target—destination database path or XML file using the following
								syntax: <itemizedlist>
									<listitem>
										<para>Database objects: Path : </para>
										<para>Entity and/or model names following the path are
											ignored. </para>
									</listitem>
									<listitem>
										<para>XML file—same syntax as above </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
						<listitem>
							<para>List of one or more options that influence how the data is copied.
								See Options. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;=0</entry>
									<entry> Number of records where an attempt was made to write
										them. This may differ from what is expected.
										$procreturncontext contains detailed information about the
										actual results of the instruction.</entry>
								</row>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error
										and $procerrorcontext provides the details. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Items Returned by $procreturncontext after entitycopy. Items
							are omitted if their value is zero or an empty string.</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Item</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Context = Context </entry>
									<entry> Context of the information. Can have the value
										EntityCopy, UDE Copy, UDE Import, UDE Export, or UDE
										Compile. </entry>
								</row>
								<row>
									<entry> Error = Number </entry>
									<entry> Error number if process failed on error</entry>
								</row>
								<row>
									<entry> InputRecords = Number </entry>
									<entry> Records to be copied.</entry>
								</row>
								<row>
									<entry> OutputRecords = Number </entry>
									<entry> Records written. </entry>
								</row>
								<row>
									<entry> SkippedRecords = Number </entry>
									<entry> Records not written due to map file entity mapping to
										&lt;void&gt; </entry>
								</row>
								<row>
									<entry> WriteErrorsContinues = Number </entry>
									<entry> Write errors encountered that did not stop the copy
										action.</entry>
								</row>
								<row>
									<entry> InputDescriptors= Number </entry>
									<entry> Descriptors to be copied. The same descriptor can occur
										more than once.</entry>
								</row>
								<row>
									<entry> OutputDescriptors = Number </entry>
									<entry> Signatures actually output. This can be less than the
										number of InputDescriptors if void mappings are
										encountered.</entry>
								</row>
								<row>
									<entry> SkippedDescriptors = Number </entry>
									<entry> Entities mapped to &lt;void&gt; </entry>
								</row>
								<row>
									<entry> InputTrxFiles = Number </entry>
									<entry> TRX files to copy, if a wildcard was specified.</entry>
								</row>
								<row>
									<entry> InputXmlFiles = Number </entry>
									<entry> XML files to copy, if a wildcard was specified.</entry>
								</row>
								<row>
									<entry> Release = ReleaseNumber </entry>
									<entry> Number of the Uniface release of the source
										data.</entry>
								</row>
								<row>
									<entry> AdditionalInfo = String </entry>
									<entry> Information in the message frame, structured as a list.
										For details, see <emphasis role="italic"
											>AdditionalInfo</emphasis> below. This item is only
										available if requested by setting the option prcadditional=
										to TRUE. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Values commonly returned by $procerror </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1 through -25 </entry>
									<entry> Various. See $procerror </entry>
									<entry> Database I/O and network communication errors.</entry>
								</row>
								<row>
									<entry> -1107 </entry>
									<entry> &lt;UPROCERR_PATH&gt; </entry>
									<entry> The path name is not correct or the path does not exist,
										for example, no assignment is found for the path. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>With the exception of error -9 &lt;UIOSERR_LOGON_ERROR&gt;, errors from -1
						through -15 do not stop the entitycopy process. The number of ignored errors
						is returned in $procreturncontext, along with additional information, such
						as the Uniface release number of the Source, and the number of input and
						output records processed.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Any Uniface component. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The entitycopy Proc statement copies or converts one or more entity
						occurrences from a source database or file to another. It enables you to
						incorporate the functionality provided by the /cpy command line switch into
						your Uniface application.</para>
					<para>entitycopy is typically used to export and import user data, but it can
						also be used to convert data, with or without a map file. By default, when
						copying or importing from an XML file, the entity descriptors in the source
						XML file are used. However, if you specify the map=# option, the entity
						descriptors in the Repository are used instead. For example, if you want to
						change the syntax definition of a field to use the W packing code instead of
						the C packing code, you can export the data, change the syntax definition,
						then import the data specifying map=# to have it use the new definition. </para>
					<para>If the Source is a database, analyze the application models to be
						exported. </para>
					<para>The copy process does not consider referential integrity constraints. It
						is assumed that the data to be copied is complete and correct. </para>
				</sect2>
				<sect2>
					<title>Options</title>
					<para>The Options enables you to influence how the data is copied. For example,
						you can specify a map file, or select occurrences that have specific field
						values. </para>
					<para>The Options is an associative list containing at least one option and
						value, using GOLD ; as a separator.</para>
					<table>
						<title>Table 4. Options</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Option</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> append= TRUE | FALSE </entry>
									<entry> Append the data to an existing XML file</entry>
								</row>
								<row>
									<entry> keepopen= TRUE | FALSE </entry>
									<entry> Keep an XML file open in preparation for appending more
										data. Only applicable if Target is a single file. By
										default, if the Target is an XML file, the file is flushed
										and closed each time the entitycopy command is used.
										However, to improve performance in cases when appending to a
										file, use this option to keep the file open. </entry>
								</row>
								<row>
									<entry> sort= True | False </entry>
									<entry> Copy the output in primary key order. If this is set to
										False, depending on the database used, the order in the
										export file can differ in repeated exports, even if nothing
										has changed</entry>
								</row>
								<row>
									<entry> map= MapFile | #{Entity|TargetEntity=SourceEntity} </entry>
									<entry> Use mapping functionality to determine how data is
										copied from existing entity and field definitions to new
										model definitions. For the following, it is not necessary to
										specify a MapFile: #—use Target Repository definitions to
										map all entities # Entity—use Target Repository definitions
										to map the specified entity # TargetEntity=SourceEntity—use
										Target Repository definitions to map a source entity to a
										destination entity</entry>
								</row>
								<row>
									<entry> tran= TranslationTable </entry>
									<entry> Use the specified database translation table for
										converting the data. A database translation table is a
										keyboard translation table that is used to convert character
										strings during database input or output. </entry>
								</row>
								<row>
									<entry> library= TranslationTableLibrary </entry>
									<entry> Library in which the TranslationTable is
										located.</entry>
								</row>
								<row>
									<entry> where= SelectClause </entry>
									<entry><para>Copy selected occurrences. The SelectClause has the
											following syntax: Field 1 Operator ObjectSpec
												1{<emphasis role="underline">;</emphasis> Field n
											Operator ObjectSpec n} {"} </para>
										<itemizedlist>
											<listitem>
												<para>Field—name of a field in the source entity.
												</para>
											</listitem>
											<listitem>
												<para>Operator—logical operator preceded by GOLD,
												for example GOLD = ( <emphasis role="underline"
												>=</emphasis> ) or GOLD &gt; GOLD = ( <emphasis
												role="underline">&gt;</emphasis>
												<emphasis role="underline">=</emphasis> ). </para>
											</listitem>
											<listitem>
												<para>ObjectSpec—string specifying the retrieve
												profile for objects to be copied. Use the subfield
												separator GOLD ! GOLD ; ( <emphasis
												role="underline">!</emphasis>
												<emphasis role="underline">;</emphasis> ) to
												specify multiple conditions. </para>
											</listitem>
										</itemizedlist>
										<para>For information on specifying repository objects, see
											/whr. </para>
									</entry>
								</row>
								<row>
									<entry> supersede= TRUE | FALSE </entry>
									<entry> Indicate whether to overwrite existing occurrences
										having matching primary keys in the target DBMS.</entry>
								</row>
								<row>
									<entry> printinterval= Number </entry>
									<entry> Frequency with which a message is displayed, expressed
										as a number of occurrences.</entry>
								</row>
								<row>
									<entry> commitinterval= Number </entry>
									<entry> Frequency with which data is stored in the database,
										expressed as the number of occurrences.</entry>
								</row>
								<row>
									<entry> prcadditional= TRUE|FALSE </entry>
									<entry> Determines whether the AdditionalInfo item is available
										in $procreturncontext.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Error Handling</title>
					<para>entitycopy is a batch processing instruction, so it is possible for errors
						to occur either in executing entitycopy itself, or while processing an
						operation that it invokes. For example, if you specify a source file that
						does not exist, entitycopy itself returns an error -4.</para>
					<para>However, if you use entitycopy to import a file and it returns 0, this
						indicates the entitycopy executed successfully, but no records were actually
						imported. Information about errors encountered during processing can be made
						available by specifying the option prcadditional=true. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<programlisting role="uniface"><![CDATA[;export data
entitycopy "def:myent.mymodel", "xml:myexportfile.xml"
entitycopy "def:myent.mymodel", "xml:myzip.zip:myexportfile.xml"
;import data
entitycopy "xml:myexportfile.xml", "def:myent.mymodel"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Specifying Multiple Conditions with where=</title>
					<para>The following example uses the where= option to retrieve all entities
						where the organization name (field ORGNAME) starts with letters A through C,
						and the city (field CITY) is Detroit. The use of the GOLD subfield separator
							(<emphasis role="underline">!</emphasis>
						<emphasis role="underline">;</emphasis>) in the where option implies a
						logical AND. The GOLD separators and operators are underlined.</para>
					<programlisting role="uniface"><![CDATA[entitycopy "def:ORG.ORGSMODEL", "xml:ABCOrgs.xml", %\
"printinterval=50 <emphasis role="underline">;</emphasis>where=ORGNAME <emphasis role="underline">&gt;</emphasis><emphasis role="underline">=</emphasis>A<emphasis role="underline">&amp;</emphasis><emphasis role="underline">&lt;</emphasis><emphasis role="underline">=</emphasis>D<emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis>CITY<emphasis role="underline">=</emphasis>Detroit"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Specifying Alternative Conditions with where=</title>
					<para>The following example uses the where= option to retrieve all entities
						where the product code (field CODE) starts with letters A through C, or the
						product category (field CATEGORY) is footwear. To specify a logical OR
						between subfields in the where option, place the OR operator (GOLD |)
						immediately after the subfield operator. </para>
					<programlisting role="uniface"><![CDATA[entityCopy "def:PRODUCT.PRODUCTS", "xml:myexportfile.xml", %\
"printinterval=50 <emphasis role="underline">;</emphasis>where=CODE <emphasis role="underline">&gt;</emphasis><emphasis role="underline">=</emphasis>A <emphasis role="underline">&amp;</emphasis><emphasis role="underline">&lt;</emphasis><emphasis role="underline">=</emphasis>D <emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis>CATEGORY<emphasis role="underline">|</emphasis><emphasis role="underline">=</emphasis>footwear"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: prcadditional=true</title>
					<para>Consider the following statement:</para>
					<programlisting role="uniface"><![CDATA[entitycopy "MYCARS.XML","def:"]]></programlisting>
					<para>After importing the file MYCARS.XML, $status contains 0 and
						$procreturncontext returns the following:</para>
					<programlisting role="uniface"><![CDATA[Context=UDE Import·;InputRecords=5·;WriteErrorsContinued=5·;InputDescriptors=1·;InputXmlFiles=1·;Release=9.1]]></programlisting>
					<para>It indicates that 5 write errors were encountered. To get details of those
						errors, execute the entitycopy instruction with prcadditional=true:</para>
					<programlisting role="uniface"><![CDATA[entitycopy MYCARS.XML,"def:","prcadditional=true"]]></programlisting>
					<para>$procreturncontext now returns: </para>
					<programlisting role="uniface"><![CDATA[Context=EntityCopy·;InputRecords=5·;WriteErrorsContinued=5·;InputDescriptors=1·;InputXmlFiles=1·;
Release=9.1·;AdditionalInfo=REC1=ID=0·!·!·!·;MESSAGE=I/O function: W, mode: 0, on file/table: CAR length: 
1146·!·!·;ID=0·!·!·!·;MESSAGE=SOLID Table Error 13011: Table USYSANA does not exist·!·!·;ID=8069·!·!·!·;
MESSAGE=8069 - Copy failed: Write error on file/table 'DEF:CAR.MYCARS'.·!·;INFO=ID=8078·!·!·!·;MESSAGE=8078 - 
Copy from 'D:\Compuware\samples\widgets\CAR.xml' to 'DEF:CAR.MYCARS'.·!·;REC2=ID=0·!·!·!·;MESSAGE=I/O function: 
W, mode: 0, on file/table: CAR length: 1688·!·!·;ID=0·!·!·!·;MESSAGE=SOLID Database Error 10033: Primary key 
unique constraint violation.·!·!·;ID=8069·!·!·!·;MESSAGE=8069 - Copy failed: Write error on file/table 'DEF:CAR.
MYCARS'.·!·;REC3=ID=0·!·!·!·;MESSAGE=I/O function: W, mode: 0, on file/table: CAR length: 982·!·!·;ID=0·!·!·!·;
MESSAGE=SOLID Database Error 10033: Primary key unique constraint violation.·!·!·;ID=8069·!·!·!·;MESSAGE=8069 - 
Copy failed: Write error on file/table 'DEF:CAR.MYCARS'.·!·;REC4=ID=0·!·!·!·;MESSAGE=I/O function: W, mode: 0, on 
file/table: CAR length: 3816·!·!·;ID=0·!·!·!·;MESSAGE=SOLID Database Error 10033: Primary key unique constraint 
violation.·!·!·;ID=8069·!·!·!·;MESSAGE=8069 - Copy failed: Write error on file/table 'DEF:CAR.MYCARS'.·!·;
REC5=ID=0·!·!·!·;MESSAGE=I/O function: W, mode: 0, on file/table: CAR length: 1748·!·!·;ID=0·!·!·!·;MESSAGE=SOLID
 Database Error 10033: Primary key unique constraint violation.·!·!·;ID=8069·!·!·!·;MESSAGE=8069 - Copy failed: 
Write error on file/table 'DEF:CAR.MYCARS'.·!·;INFO=ID=8074·!·!·!·;MESSAGE=8074 - Copied from 'D:\Compuware\
samples\widgets\CAR.xml' to 'DEF:CAR.MYCARS' total records/rows 0.]]></programlisting>
					<para>(To get more readable output, you can use the example provided in the
						$procreturncontext description.) From the messages returned, it is clear
						that the records already exist in the database. They are not overwritten,
						which is why entitycopy returned 0.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.entry">
				<title>entry</title>
				<para>Label the start of a Proc entry</para>
				<sect2>
					<title>Syntax</title>
					<para> entry EntryName </para>
					<para><emphasis role="italic">... Proc statements and precompiler
							directives</emphasis>
					</para>
					<para>end </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>EntryName—literal name of the entry; can have a maximum length of 32
						bytes; these characters can be letters (A-Z), digits (0-9), or underscores
						(_). </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The entry statement does not affect the value of $status. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service and report components</para>
					<para>Declared in triggers of application shells, components, and component
						entities and fields and global Proc.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The entry statement defines the name and the starting point for a Proc
						module that is referenced by a call statement. It acts as an implicit end
						for the previous module or operation. An entry statement must be in the same
						component or global Proc as the call statement that references it. </para>
					<para>If parameters are defined for the entry, the params block should be the
						first statement following the entry statement. If local variables are
						defined for the module, the variables block should follow the params block,
						if that is present. </para>
				</sect2>
				<sect2>
					<title>Entries in Field Triggers</title>
					<para>Proc modules that are defined in the Local Proc Modules triggers for all
						fields belonging to that entity are always available, regardless of whether
						that field has been drawn on the component. However, Proc modules that are
						defined in other triggers of a field are available only if that field has
						been drawn or included in the field list for the entity. </para>
				</sect2>
				<sect2>
					<title>Entries in Subtype Triggers</title>
					<para>If two subtypes of an entity contain entry statements with the same
						EntryName, when they are drawn on a single component, a compilation error
						results because of the multiple occurrences of the same EntryName. To avoid
						this problem, you can create a global Proc named EntryName and remove the
						entry modules from the subtypes. </para>
				</sect2>
				<sect2>
					<title>Entries in Global Procs</title>
					<para>Be careful when using entry in a global Proc. Place any statements not in
						the subroutine at the beginning of the global Proc. If you call a global
						Proc which contains one or more entry statements, as well as one or more
						statements which are not physically part of any module labeled with the
						entry statement, the Proc interpreter ignores these 'loose' statements
						unless they are the first statements in the global Proc. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example, the Store trigger contains a call to an entry
						defined in the Local Proc Modules trigger of the component</para>
					<programlisting role="uniface"><![CDATA[; trigger: &lt;Store&gt;
call LSTORE]]></programlisting>
					<programlisting role="uniface"><![CDATA[; trigger: Local Proc Modules (component-level)
entry LSTORE
   store
   if ($status &lt; 0)
      message "Store error!"
      rollback
   else
      message "Store done."
      commit
   endif
end]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.erase">
				<title>erase</title>
				<para>Activate the Delete or Delete Up trigger for all occurrences in the component. </para>
				<sect2>
					<title>Syntax</title>
					<para> erase{/e {Entity}} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/e—erases all occurrences of Entity in the component, including inner
						entities if the relationship between these entities and the erased entity is
						Cascading Delete. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity to be erased. Can be a string, or a field, variable,
						function, or parameter that evaluates to a string containing the entity
						name. If Entity is omitted, all occurrences of the current entity ($entname)
						are erased. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by erase in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> erase is not allowed. (For example, the component was
										activated with run/query.) </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Data was successfully erased, or no entities are painted
										on the component. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> Occurrence not found: table is empty. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -5 </entry>
									<entry> Update request for nonupdatable occurrence. </entry>
								</row>
								<row>
									<entry> -6 </entry>
									<entry> Exceptional I/O error on write request; for example,
										lack of disk space, no write permission, or violation of a
										database constraint. Check the message frame for details.
									</entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							erase</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The erase statement activates the Delete triggers at entity level for all
						occurrences <emphasis role="italic">in the component</emphasis>. This means
						that occurrences which have <emphasis role="italic">not</emphasis> been
						fetched are not erased. Use this statement to allow the user to erase all
						the occurrences in the component. </para>
					<para>The erase statement attempts to delete all the occurrences of the
						outermost entity that have been fetched into the component. This includes
						occurrences not currently displayed, and also any occurrences fetched due to
						Proc code. Uniface attempts to erase all occurrences, not just those visible
						on the component. If the hitlist contains several occurrences, they are not
						deleted unless they have been explicitly fetched into the component. </para>
				</sect2>
				<sect2>
					<title>Related Entities</title>
					<para>If the entity to be erased has related entities, the behavior of erase
						depends on the delete constraints of the relationship: </para>
					<itemizedlist>
						<listitem>
							<para>Cascading Delete—the erase statement deletes related entities.
							</para>
						</listitem>
						<listitem>
							<para>Nullify Delete—it nullifies the foreign key in related entities.
							</para>
						</listitem>
						<listitem>
							<para>An erase is not allowed if there is a Restricted Delete
								relationship between entities and there are still occurrences of the
								many entity. </para>
						</listitem>
					</itemizedlist>
					<para>If Uniface detects that an entity is painted as an up entity on a
						component, the Delete Up trigger is activated instead of the Delete trigger.
						If the occurrence in the up entity should be deleted in the normal I/O
						procedure, include a delete statement in this trigger. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Deleting an occurrence of an up
						entity can have serious consequences for database integrity. </para>
				</sect2>
				<sect2>
					<title>Deleting all Occurrences in the Database</title>
					<para>If it is necessary to delete all occurrences in the database, you should
						use setocc "*",-1 to retrieve all occurrences into the component structure.
						The retrieve statement only builds the hitlist, and does not actually fetch
						the data. Then use the erase statement to remove the data. Simply using
						retrieve then erase does not necessarily delete all the occurrences, because
						erase only deletes fetched occurrences. You should only allow this if you
						want all your data to be deleted. </para>
				</sect2>
				<sect2>
					<title>Clearing the Message Frame</title>
					<para>If the message level for the application is greater than zero, the erase
						statement also clears the message frame. (If the message level is 0, the
						message frame is never cleared.) The message level can be set with the /pri
						switch or defined in the application definitions. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>Because the ^ERASE function can be quite drastic, it is common to disable
						this trigger completely (by omitting the erase statement from it), or to add
						the following code to the Erase trigger: </para>
					<programlisting role="uniface"><![CDATA[trigger _erase 
if ($totocc(CUSTOMER) &gt;= 1)
   askmess "%%$totocc(CUSTOMER) occurrences. Erase them all?"
   if ($status = 0)
      return
   endif
endif
erase
if ($status &lt;0)
   message "Erase error; see message frame"
   rollback
else
   if ($status = 1)
      message "Erase is not allowed"
   else
      message "Erase was successful"
      commit
      if($status &lt; 0)
         rollback
      endif
   endif
endif
end ; end trigger]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.exit">
				<title>exit</title>
				<para>Exits the current component instance and return to the previous or specified
					instance. </para>
				<sect2>
					<title>Syntax</title>
					<para> exit {Expression}{, InstName} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Expression—expression that results in a number. Uniface evaluates
								the expression, converts it to an integer if necessary, and places
								the result in $status. The simplest form of Expression is a
								constant. To improve readability, parentheses (()) are often
								included as a part of Expression. </para>
						</listitem>
						<listitem>
							<para>InstName—string, or field (or indirect reference to a field),
								variable, or function that evaluates to a string containing the name
								of the target component instance. If InstanceName is longer than 32
								characters, it is truncated to that length. Trailing blanks are
								removed. </para>
							<para>If InstanceName is present, it must be an instance in the
								component pool that the user would return to at some point if the
								exit statement had not been used. Uniface returns to the named
								instance; intervening instances are closed. (Any assignments for
								renaming components are not considered by exit.) </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The result of evaluating Expression is placed in $status. If Expression is
						omitted, $status defaults to 0. In either case, $procerror is 0. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>exit {Expression} is allowed in form, service, and report components. </para>
					<para>exit {Expression}{, InstName} is allowed in form components (and in
						service and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The exit statement immediately exits the current component and returns to
						the previous component or to the InstanceName specified. It overrides the
						normal processing of events by the structure editor. Any outstanding data
						validation is not performed and triggers that would otherwise be executed
						are not activated. In addition, the Form Loses Focus trigger is not
						activated. </para>
					<para>For example, an exit statement in the Quit trigger of a component does not
						cause the Execute trigger of the component to be reactivated. If you want
						the Execute trigger to be reactivated (for example, to execute any
						statements after the edit statement in the Execute trigger), you should use
						a return statement instead of exit. </para>
				</sect2>
				<sect2>
					<title>deleteinstance and exit </title>
					<para>If the current component is a local component instance (started with
						activate), an implicit deleteinstance is executed after the exit to remove
						the instance. </para>
					<para>If the component instance is a remote synchronous service, it is deleted
						on both the server and the client. However, it is strongly recommended that
						you use the return statement and have the client perform an explicit
						deleteinstance, rather than to rely on the implicit behavior of exit.</para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If the component instance is a
						remote <emphasis role="italic">asynchronous</emphasis> service, it is
						deleted on the server only—the client is <emphasis role="italic"
							>not</emphasis> informed of the deletion. For that reason, the exit
						statement is not allowed in a remote asynchronous service. Instead, you
						should perform an explicit deleteinstance on the client side. </para>
					<para>Before the current instance exits, any child instances attached to it are
						removed. In each of the attached instances that contains an operation named
						CLEANUP, that operation is executed before the instance is removed. If the
						current instance (the one that issued the exit statement) contains an
						operation named CLEANUP, that operation is performed before the component is
						removed. </para>
				</sect2>
				<sect2>
					<title>Exiting to a Named Instance</title>
					<para>Exiting to a named component instance bypasses any triggers that would
						ordinarily be executed in the current instance, as well as in any
						intervening instances. In each instance that is exited, if it contains an
						operation named CLEANUP, that operation is executed before the instance is
						removed. </para>
					<para>Exiting to a named component instance is generally used to skip quickly
						back to a specific instance. Trying to exit to an instance that is not in
						the component pool or that is not a parent of the current instance is a
						logical error in the application. In this case, the InstanceName argument is
						ignored and the current instance exits normally, as if the InstanceName
						argument were not present. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns to the previous component: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Accept
$1 = CUSTNAME
exit (1)
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example returns to the form MAINMENU, if the user enters Y: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Quit
askmess "Return to Main Menu?"
if ($status = 1) ;if answer is "Y"
    exit (0), "MAINMENU"
else
    return (-1)
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.exp">
				<title>exp [DEPRECATED]</title>
				<warning>
					<para> The command <function>exp</function> was replaced by <link
							linkend="langref.dollar_exp">
							<function>$exp</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'exp' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_exp">
							<function>$exp</function>
						</link> was introduced to replace <literal>exp</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.expression">
				<title>expression [DEPRECATED]</title>
				<warning>
					<para> The command <function>expression</function> was replaced by <link
							linkend="langref.dollar_expression">
							<function>$expression</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'expression'
							used</literal>. </para>
					<para> In U8 the function <link
							linkend="langref.dollar_expression">
							<function>$expression</function>
						</link> was introduced to replace <literal>expression</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.fact">
				<title>fact [DEPRECATED]</title>
				<warning>
					<para> The command <function>fact</function> was replaced by <link
							linkend="langref.dollar_fact">
							<function>$fact</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'fact' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_fact">
							<function>$fact</function>
						</link> was introduced to replace <literal>fact</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.field_syntax">
				<title>field_syntax [DEPRECATED]</title>
				<para> Deprecated since: U8. </para>
			</sect1>
			<sect1 xml:id="langref.fieldsyntax">
				<title>fieldsyntax</title>
				<para> Introduced since: U8 </para>
				<warning>
					<para>This function is the same as $fieldsyntax. So we declare this one
						deprecated. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.field_video">
				<title>field_video [DEPRECATED]</title>
				<para> Deprecated since: U8. </para>
			</sect1>
			<sect1 xml:id="langref.fieldvideo">
				<title>fieldvideo</title>
				<para> Introduced since: U8. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.file_dump">
				<title>file_dump [DEPRECATED]</title>
				<para> Deprecated since: U8. </para>
			</sect1>
			<sect1 xml:id="langref.file_load">
				<title>file_load [DEPRECATED]</title>
				<para> Deprecated since: U8. </para>
			</sect1>
			<sect1 xml:id="langref.filebox">
				<title>filebox</title>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.filecopy">
				<title>filecopy</title>
				<para> Introduced in: U9 </para>
				<para>Copy the specified file to the target location. </para>
				<sect2>
					<title>Syntax</title>
					<para>filecopy FilePath , DirPath | NewFilePath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
							<listitem>
								<para>NewFilePath—new file name, optionally preceded by the path to
									the file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
							<listitem>
								<para>DirPath—directory name, optionally preceded by the path to the
									directory. Must end with a directory separator </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The filecopy statement copies the specified file FilePath to the target
						location, either to DirPath or to NewFilePath, taking any file redirections
						in the assignment file into account. </para>
					<para>If DirPath is specified (that is, the path ends with a directory
						separator), the file FilePath is copied to the directory DirPath using the
						same file name.</para>
					<para>If NewFilePath is specified, the specified file is copied to the directory
						name and file name supplied in NewFilePath.</para>
					<para>If the the specified file FilePath is located in a zip archive, it can be
						copied to different directory in the same archive, to another zip archive,
						or to a directory on the file system.</para>
				</sect2>
				<sect2>
					<title>Specifying Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the directory part of DirPath or
						NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Does not already exist </para>
						</listitem>
						<listitem>
							<para>Does not permit user-writing due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the file NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Copying From and To Zip Files and Across Platforms</title>
					<para>If the the specified file FilePath is located in a ZIP archive, it can be
						copied to different directory in the same archive, to another ZIP archive,
						or to a directory on the file system.</para>
					<para>When copying files to or from zip archives, or across operating systems or
						media, Uniface handles text files differently than binary files. It copies
						binary files as-is, but it automatically adjusts text file attributes so
						that EOL characters and optional character set conversions match the
						platform. This may result in changes in the file size, making it appear that
						source and target files are not the same. </para>
					<para>You can define the files to be treated as text files, or switch off
						automatic cross-platform text file handling using the $TEXT_FILE_EXTENSIONS
						assignment setting.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On the iSeries, the particular ‘copy’ command that is used depends on the
						following circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>When both the source and the destination use the IFS prefix, or
								when both do <emphasis role="italic">not</emphasis> use the IFS
								prefix, the CPY command is used </para>
						</listitem>
						<listitem>
							<para>When the source has the IFS prefix, but the destination does not,
								then CPYFRMSTMF is used </para>
						</listitem>
						<listitem>
							<para>When the destination has the IFS prefix, but the source does not,
								then CPYTOSTMF is used. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Copying a File to Another Directory</title>
					<para>The following example copies the file <emphasis role="bold"
							>test.txt</emphasis> from the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory to the directory <emphasis
							role="bold">sub2dir</emphasis> in <emphasis role="bold"
							>sub1dir</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[filecopy "sub1dir\test.txt", "sub1dir\sub2dir\"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[filecopy "sub1dir/test.txt", "sub1dir/sub2dir/"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[filecopy "[.sub1dir]test.txt", "[.sub1dir.sub2dir]"]]></programlisting>
					<para>ON VMS, version 5 is retained in the copied file; on other platforms, it
						is not: </para>
					<programlisting role="uniface"><![CDATA[filecopy "[.sub1dir]test.txt;5", "[.sub1dir.sub2dir]"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying a Ffile to the Same Directory Under Another Name</title>
					<para>The following example copies the file <emphasis role="bold"
							>test1.txt</emphasis> to <emphasis role="bold">test2.txt</emphasis> in
						the same directory:</para>
					<programlisting role="uniface"><![CDATA[filecopy "sub1dir\test1.txt", "sub1dir\test2.txt"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[filecopy "[.sub1dir]test1.txt", "[.sub1dir]test2.txt"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying a File to Another Directory Under Another Name</title>
					<para>The following example copies the file <emphasis role="bold"
							>test1.txt</emphasis> in the current directory to the file <emphasis
							role="bold">test2.txt</emphasis> in <emphasis role="bold"
							>sub3dir</emphasis> in the current directory:</para>
					<programlisting role="uniface"><![CDATA[filecopy "test1.txt", ".\sub3dir/test2.txt"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.filedelete">
				<title>filedelete</title>
				<para> Introduced in: U9 </para>
				<para>Delete the specified file. </para>
				<sect2>
					<title>Syntax</title>
					<para>filedelete FilePath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>FilePath—file name, optionally preceded by the path to the file. The file
						can be located in a ZIP archive. Must <emphasis role="italic">not</emphasis>
						end with a directory separator. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The filedelete statement deletes the specified file, using any file
						redirections in the assignment file. </para>
				</sect2>
				<sect2>
					<title>Specifying Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-deletion due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example deletes the file <emphasis role="bold"
							>test.txt</emphasis> in the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory:</para>
					<programlisting role="uniface"><![CDATA[filedelete "sub1dir\test.txt"]]></programlisting>
					<para>VMS</para>
					<programlisting role="uniface"><![CDATA[filedelete "[.sub1dir]test.txt;5"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.filedump">
				<title>filedump</title>
				<para> Introduced since: U8. </para>
				<para>Copy the contents of the source object to the specified file. </para>
				<sect2>
					<title>Syntax</title>
					<para>filedump {/text | /append | /image | /raw | /web{/raw}} Source , FileName
						{, UnicodeFormat} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/text—translates the raw data from FileName to the system
								character set or the UnicodeFormat. This is the default behavior.
							</para>
						</listitem>
						<listitem>
							<para>/append—appends the contents of Source to the specified FileName.
								If FileName does not exist, it is created. The /append switch cannot
								be used in conjunction with /image and /raw. </para>
						</listitem>
						<listitem>
							<para>/image—writes the raw data from Source, assuming that this data is
								an image. An initial hash character (#) is removed from the data
								before writing. (The hash character is an indicator to show that
								image data follows.) No further conversion is performed on the data
								in Source. </para>
						</listitem>
						<listitem>
							<para>/raw—writes the raw data from Source; an initial hash character
								(#) is not removed. No further conversion is performed on the data
								in Source, which is encoded as UTF-8. </para>
						</listitem>
						<listitem>
							<para>/web—in forms running in the Web Application Server, copies files
								that were downloaded via the browser. The files are in raw format,
								therefore there is no need to combine the /web and /raw switches,
								although this is allowed syntactically. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Source—source object containing the contents to be copied. It can
								be a literal name, or a string, a variable, or function that
								evaluates to a string containing the name. </para>
						</listitem>
						<listitem>
							<para>FileName—destination path and file name of the output file, which
								can include a ZIP archive. It can be a string, or a field (or
								indirect reference to a field), a variable, or a function that
								evaluates to a string. The total length of the path and file name
								cannot exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>UnicodeFormat—Unicode encoding format of the input file. It can be
								a string, or a field (or indirect reference to a field), a variable,
								or a function that evaluates to a string. Valid values are: UTF-8,
								UTF-16, UTF-16BE, UTF-16LE, UTF-32BE and UTF-32LE. If not specified,
								the system character set is used. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by filedump and lfiledump in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;=0 </entry>
									<entry> The number of bytes from Source written to FileName.
									</entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> An I/O error occurred while writing FileName. </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> Cannot open FileName. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
								<row>
									<entry> -17 </entry>
									<entry> Network error: pipe broken. </entry>
								</row>
								<row>
									<entry> -18 </entry>
									<entry> Network error: failed to start new server. </entry>
								</row>
								<row>
									<entry> -19 </entry>
									<entry> Network error: fatal. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following filedump
							and lfiledump</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -4 </entry>
									<entry> &lt;UIOSERR_OPEN_FAILURE&gt; </entry>
									<entry> The table or file could not be opened. The entity is not
										painted or the corresponding table or file does not exist in
										the database. </entry>
								</row>
								<row>
									<entry> -12 </entry>
									<entry> &lt;UIOSERR_FILE_READ_WRITE&gt; </entry>
									<entry> An error occurred while trying to read or write to the
										file. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The filedump statement copies the contents of Source to FileName.
						Assignments are considered when locating FileName. (Logical names are only
						supported under OpenVMS.) The file FileName is created if it does not
						already exist. By default, filedump overwrites an existing file. </para>
					<para>Used without the /image or /raw switch, filedump converts the data to be
						stored to the UTF8 character set , or with the UnicodeFormat, if specified. </para>
					<para>filedump writes a Unicode Byte-Order-Mark (BOM), a special character to
						recognize the encoding.</para>
					<para>If the first line contains XML information, for example &lt;?xml
						version="1.0"?&gt;, filedump adds information (if not already present) about
						the character set in use to the XML string, for example:</para>
					<programlisting role="uniface"><![CDATA[&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;]]></programlisting>
					<para>The contents of Source affects what is written to FileName: </para>
					<itemizedlist>
						<listitem>
							<para>If Source is the literal name of a field, the current contents of
								that field are written to FileName. </para>
						</listitem>
						<listitem>
							<para>If Source is a string, a variable, or function, the current value
								of that object is written to FileName. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> If the output file does not contain
						enough space to write the entire contents of the Source, the data is
						truncated and filedump returns &lt;UIOSERR_FILE_READ_WRITE&gt; in
						$procerror. </para>
				</sect2>
				<sect2>
					<title>Specifying the File Name</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information on specifying parameters, see Proc for File System
						Management </para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-writing due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Appending Data to a File 1</title>
					<para>After the following code has been executed, the file <emphasis role="bold"
							>MYFILE</emphasis> contains the string "Crew, JimNAME" </para>
					<programlisting role="uniface"><![CDATA[NAME = "Crew, Jim"
filedump NAME, "MYFILE"
filedump/append "NAME","MYFILE"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Appending Data to a File 2</title>
					<para>To cause data to appear on separate lines in the output file, use filedump
						(with append) "%%^", as follows: </para>
					<programlisting role="uniface"><![CDATA[filedump NAME, "MYFILE"
filedump/append "%%^", "MYFILE"
filedump/append "NAME", "MYFILE"]]></programlisting>
					<para>The result of this code is: </para>
					<programlisting role="uniface"><![CDATA[Crew, Jim
NAME]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Saving a Downloaded File</title>
					<para>The following example dumps a file that was downloaded via a Web browser: </para>
					<programlisting role="uniface"><![CDATA[filedump/web UPLOADNAME.ENTITY.MODEL,"downloads/file1"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Saving Data to OpenVMS File</title>
					<para>In the following example, an OpenVMS file is the destination for the data
						written by the filedump statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
filedump TEXTFIELD,"dua0:[JIMC.DOCUMENTS]text.ext"
message "%%$status%%% bytes of TEXTFIELD copied to TEXT.EXT file."]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Saving Data to Unix File</title>
					<para>In the following example, a Unix file is the destination for the data
						written by the filedump statement: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
filedump TEXTFIELD,"/home/jimc/textfiles/TEXT.EXT"
message "%%$status%%% bytes of TEXTFIELD copied to TEXT.EXT file."]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.fileload">
				<title>fileload</title>
				<para> Introduced since: U8. </para>
				<para>Copy the contents of the specified file into the specified field or variable. </para>
				<sect2>
					<title>Syntax</title>
					<para>fileload {/text |/image | /raw | /web {/raw}} FilePath , Target {,
						UnicodeFormat} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/text—translates the raw data from FileName to the system
								character set or the UnicodeFormat. This is the default behavior.
							</para>
						</listitem>
						<listitem>
							<para>/image—reads the raw data from FileName, assuming that this data
								is an image. An initial hash character (#) is added to the data
								before copying the data to Target. (The hash character is an
								indicator to show that image data follows.) No further conversion is
								performed on the data. </para>
						</listitem>
						<listitem>
							<para>/raw—behaves similarly to the /image switch, except that the data
								in FileName is assumed not to be an image; an initial hash character
								(#) is not added. No further conversion is performed on the data.
							</para>
						</listitem>
						<listitem>
							<para>/web—when used in forms running in the Web Application Server, it
								loads files that were uploaded via the browser. The files are in raw
								format, therefore there is no need to combine the /web and /raw
								switches, although this is allowed syntactically. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FilePath—name and path of the file contents to be copied. It
									can be a string, or a field (or indirect reference to a field),
									a variable, or a function that evaluates to a string. The total
									length of the path and file name may not exceed 255 bytes. The
									file can be located in a zip archive. Assignments are considered
									when locating FileName. Logical names are supported only under
									OpenVMS. </para>
							</listitem>
							<listitem>
								<para>Target—name of a field, a variable, or a parameter to receive
									the data. </para>
							</listitem>
							<listitem>
								<para>UnicodeFormat—Unicode encoding format of the input file. It
									can be a string, or a field (or indirect reference to a field),
									a variable, or a function that evaluates to a string. Valid
									values are: UTF8, UTF16, UTF-16BE, UTF-16LE, UTF-32BE and
									UTF-32LE. If not specified, the system character set is used.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by fileload in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &gt;=0 </entry>
										<entry> The number of bytes in Target. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> An I/O error occurred while reading FileName.
										</entry>
									</row>
									<row>
										<entry> -4 </entry>
										<entry> Cannot open FileName. </entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
									<row>
										<entry> -17 </entry>
										<entry> Network error: pipe broken. </entry>
									</row>
									<row>
										<entry> -18 </entry>
										<entry> Network error: failed to start new server. </entry>
									</row>
									<row>
										<entry> -19 </entry>
										<entry> Network error: fatal. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								fileload</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -4 </entry>
										<entry> &lt;UIOSERR_OPEN_FAILURE&gt; </entry>
										<entry> The table or file could not be opened. The entity is
											not painted or the corresponding table or file does not
											exist in the database. </entry>
									</row>
									<row>
										<entry> -12 </entry>
										<entry> &lt;UIOSERR_FILE_READ_WRITE&gt; </entry>
										<entry> An error occurred while trying to read or write to
											the file. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> -1113 </entry>
										<entry> &lt;UPROCERR_PARAMETER&gt; </entry>
										<entry> Parameter name not valid or not defined. </entry>
									</row>
									<row>
										<entry> -1114 </entry>
										<entry> &lt;UPROCERR_LOCAL_VARIABLE&gt; </entry>
										<entry> Local variable name not valid or not defined.
										</entry>
									</row>
									<row>
										<entry> -1115 </entry>
										<entry> &lt;UPROCERR_COMPONENT_VARIABLE&gt; </entry>
										<entry> Component variable name not valid or not found.
										</entry>
									</row>
									<row>
										<entry> -1116 </entry>
										<entry> &lt;UPROCERR_GENERAL_VARIABLE&gt; </entry>
										<entry> General variable not valid. </entry>
									</row>
									<row>
										<entry> -1117 </entry>
										<entry> &lt;UPROCERR_GLOBAL_VARIABLE&gt; </entry>
										<entry> Global variable name not valid or not found.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The fileload statement copies the contents of FileName to Target. Unlike
						lfileload, it uses the locations specified in the assignment file to locate
						files.</para>
					<para>Used without the /image or /raw switch, fileload converts the data to be
						stored from the character set specified by the assignment setting
						$SYS_CHARSET or with the UnicodeFormat, if specified. </para>
					<para>fileload checks for a Unicode Byte-Order-Mark (BOM), a special character
						to recognize the encoding. If no BOM is available, the indicated character
						set is used:</para>
					<table>
						<title>Table 3. Character Set Used if Unicode BOM Not Available</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Character Set Specified by UnicodeFormat </entry>
									<entry> Character Set Used</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> UnicodeFormat is not specified</entry>
									<entry> Character set specified by the $SYS_CHARSET assignment
										setting</entry>
								</row>
								<row>
									<entry> UTF-8 </entry>
									<entry> UTF-8 </entry>
								</row>
								<row>
									<entry> UTF-16 or UTF-32 </entry>
									<entry> Big-Endian character set; either UTF-16BE or UTF-32BE,
										according to Unicode specification </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If the UnicodeFormat is specified as UTF-16BE, UTF-16LE, UTF-32BE or
						UTF-32LE, fileload does not check the Unicode BOM because the character set
						is explicitly provided.</para>
					<para>To strip the end-of-line character from an otherwise empty input file, so
						the resulting data is truly empty, use the assignment setting
						$FILELOAD_SINGLE_LINE.</para>
				</sect2>
				<sect2>
					<title>Specifying the File Name</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Does not permit user-reading due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Uploading Files to a Server Page</title>
					<para>When you create a server page to select files to be uploaded, you use the
						following Proc syntax for fileload: </para>
					<programlisting role="uniface"><![CDATA[fileload /web FileName, Target]]></programlisting>
					<para>In addition, you must also modify the server page to include the attribute
						enctype within the FORM tag, as follows: </para>
					<programlisting role="uniface"><![CDATA[&lt;FORM method="POST" action="" onSubmit="return uSubmit(this)" enctype="multipart/form-data"&gt;
]]></programlisting>
					<para>The addition of enctype="multipart/form-data" instructs the Web browser to
						send not only the file name, but also the contents of the selected file.
					</para>
				</sect2>
				<sect2>
					<title>Example: Loading an OpenVMS File</title>
					<programlisting role="uniface"><![CDATA[trigger _detail 
fileload "usys:text.ext", TEXTFIELD
message "%%$status%%% bytes of text loaded into TEXTFIELD field."
end ; trigger end]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Loading an Image File</title>
					<para>The following example loads a bitmap for a national flag based on the
						current value of $language : </para>
					<programlisting role="uniface"><![CDATA[fileload/image "flags\%%$language%%%.bmp",FLAGFIELD
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: fileload/web</title>
					<para>The following example downloads a file from a Web page and stores it to a
						file system: </para>
					<programlisting role="uniface"><![CDATA[fileload/web "UPLOADNAME.ENTITY.MODEL",$1
filedump/raw $1,"downloads/file1"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.filemove">
				<title>filemove</title>
				<para> Introduced in: U9 </para>
				<para>Move the specified file to the target location. </para>
				<sect2>
					<title>Syntax</title>
					<para> filemove FilePath , DirPath | NewFilePath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>FilePath—file name, optionally preceded by the path to the file.
								Must <emphasis role="italic">not</emphasis> end with a directory
								separator. </para>
						</listitem>
						<listitem>
							<para>NewFilePath—new file name, optionally preceded by the path to the
								file. Must <emphasis role="italic">not</emphasis> end with a
								directory separator. </para>
						</listitem>
						<listitem>
							<para>DirPath—directory name, optionally preceded by the path to the
								directory. Must end with a directory separator. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The filemove statement moves the specified file FilePath to the target
						location, using any file redirections in the assignment file. You can move
						the file by specifying DirPath, or move and rename the file by specifying
						NewFilePath. The file to be moved can be located within a zip archive and
						moved to a different directory in the same archive, to a different zip
						archive, or to a local directory.</para>
					<para>To rename a file without moving it, use filerename.</para>
				</sect2>
				<sect2>
					<title>Specifying File and Directory Names</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-deletion (after move) due to insufficient
								authorization level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the directory part of DirPath or
						NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Does not permit user-writing due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the file NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Moving From and To Zip Files and Across Platforms</title>
					<para>If the the specified file FilePath is located in a ZIP archive, it can be
						moved to different directory in the same archive, to another ZIP archive, or
						to a directory on the file system.</para>
					<para>When moving files to or from zip archives, or across operating systems or
						media, Uniface handles text files differently than binary files. It copies
						binary files as-is, but it automatically adjusts text file attributes so
						that EOL characters and optional character set conversions match the
						platform. This may result in changes in the file size, making it appear that
						source and target files are not the same. </para>
					<para>You can define the files to be treated as text files, or switch off
						automatic cross-platform text file handling using the $TEXT_FILE_EXTENSIONS
						assignment setting.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On the iSeries, the particular ‘move’ command that is used depends on the
						following circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>When both the source and the destination use the IFS prefix, or
								when both do <emphasis role="italic">not</emphasis> use the IFS
								prefix, the MOVE command is used </para>
						</listitem>
						<listitem>
							<para>When the source has the IFS prefix, but the destination does not,
								then CPYFRMSTMF is used. If the copy finishes successfully, the
								source file is deleted; if the delete fails (for example, due to
								lack of authorization), the copy is undone, and $procerror -13 is
								returned. The file (indicated by its extension), into which the
								member is to be moved, must already exist; filemove does not
								implicitly create files. </para>
						</listitem>
						<listitem>
							<para>When the destination has the IFS prefix, but the source does not,
								then CPYTOSTMF is used. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Moving a File to Another Directory</title>
					<para>The following example moves the file <emphasis role="bold"
							>test.txt</emphasis>, from the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory, to the directory <emphasis
							role="bold">sub2dir</emphasis> in <emphasis role="bold"
							>sub1dir</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[filemove "sub1dir\test.txt", "sub1dir\sub2dir\"
]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[filemove "[.sub1dir]test.txt", "[.sub1dir.sub2dir]"
]]></programlisting>
					<para>Note that it is the presence of the directory separator at the end of the
						second argument that determines that this is only a move to another
						directory, <emphasis role="italic">not</emphasis> a move combined with a
						file rename.</para>
				</sect2>
				<sect2>
					<title>Example: Moving and Renaming a File </title>
					<para>The following example moves the file <emphasis role="bold"
							>test1.txt</emphasis> from the current directory to the directory
							<emphasis role="bold">sub2dir</emphasis>, renaming the file to <emphasis
							role="bold">text.txt</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[filemove ".\test1.txt", ".\sub2dir\text.txt"]]></programlisting>
					<para>Note that it is the absence of a directory separator at the end of the
						second argument that determines that this is a move to another directory,
							<emphasis role="italic">combined</emphasis> with a file rename.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.filerename">
				<title>filerename</title>
				<para> Introduced in: U9 </para>
				<para>Rename the specified file within the same directory. </para>
				<sect2>
					<title>Syntax</title>
					<para> filerename FilePath , NewFileName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>FilePath—file name, optionally preceded by the path to the file.
								Must <emphasis role="italic">not</emphasis> end with a directory
								separator. </para>
						</listitem>
						<listitem>
							<para>NewFilePath—new file name, optionally preceded by the path to the
								file. Must <emphasis role="italic">not</emphasis> end with a
								directory separator. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfilerename statement renames FilePath to NewFileName within the same
						directory, using any file redirections in the assignment file. The file can
						be renamed in a ZIP archive.</para>
				</sect2>
				<sect2>
					<title>Specifying File Names</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation filerename fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-renaming due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the file NewFileName:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On the iSeries, when you attempt to rename a file (that does not reside in
						the IFS) such that its extension is changed, this implies a move of a member
						to a different file. For example, the command filerename lib/aaa.ext1,
						bbb.ext2 will move member <emphasis role="bold">aaa</emphasis> from file
							<emphasis role="bold">ext1</emphasis> to file <emphasis role="bold"
							>ext2</emphasis> and rename the member to <emphasis role="bold"
							>bbb</emphasis>. This works only if file <emphasis role="bold"
							>ext2</emphasis> already exists and the process has appropriate access
						rights, because the statement filerename does not implicitly create
						files.</para>
				</sect2>
				<sect2>
					<title>Example: Renaming a File in the Same Directory</title>
					<para>The following example renames the file <emphasis role="bold"
							>test.txt</emphasis> in the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory to <emphasis role="bold"
							>tested.txt</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[filerename "sub1dir/test.txt", "tested.txt"]]></programlisting>
					<para>or (VMS-specific):</para>
					<programlisting role="uniface"><![CDATA[filerename "[.sub1dir]test.txt", "tested.txt"]]></programlisting>
					<para>or:</para>
					<programlisting role="uniface"><![CDATA[filerename "[.sub1dir]test.txt;5", "tested.txt"]]></programlisting>
					<para> </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.findkey">
				<title>findkey</title>
				<para>Check if the key value of an entity exists. </para>
				<sect2>
					<title>Syntax</title>
					<para> findkey {Entity , KeyNumber} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Entity—entity where the key is to be located. Can be a string, or
								a field, variable, function, or parameter that evaluates to a string
								containing the entity name. </para>
						</listitem>
						<listitem>
							<para>KeyNumber—value that identifies the key to be located. It can be a
								constant, or a field (or indirect reference to a field), a variable,
								or a function that can be converted to a whole (integer) number; the
								value will be truncated to form an integer. <itemizedlist>
									<listitem>
										<para>1, the primary key. </para>
									</listitem>
									<listitem>
										<para>2, 3, 4, and so on, the number that identifies a
											candidate key; indexes are not allowed. </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> 0</entry>
									<entry> Primary or candidate key, KeyNumber, of Entity does not
										exist. </entry>
								</row>
								<row>
									<entry> 1</entry>
									<entry> Primary or candidate key, KeyNumber, of Entity already
										exists in the component. $result contains the occurrence
										number. </entry>
								</row>
								<row>
									<entry> 2</entry>
									<entry> Primary or candidate key, KeyNumber, of Entity already
										exists in the database. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							findkey</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -1128 </entry>
									<entry> &lt;UPROCERR_NOT_A_KEY&gt; </entry>
									<entry> The key number specified is an index. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1104 </entry>
									<entry> &lt;UPROCERR_KEY&gt; </entry>
									<entry> The key number provided is not valid; for example, the
										key number was out of range. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The findkey statement checks whether the values of the fields that make up
						the specified KeyNumber in Entity exist, either in the component or in the
						database. No validation is performed; only a check for the existence of the
						key. </para>
					<para>Unlike the retrieve/o statement, which provides additional functionality
						such as repositioning and recovering removed occurrences, findkey only
						checks for the existence of a key. </para>
					<para>The findkey statement is especially useful in the Validate Key trigger,
						while retrieve/o should be used in the Leave Modified Key trigger. The
						findkey statement checks for existence of a specified key, referred to by
						its key number, while retrieve/o looks for the ‘first’ complete key, using
						the order in which the keys are defined. This means that retrieve/o only
						works for candidate keys if the primary key data is not available. </para>
					<para>If the arguments are omitted, findkey looks for the primary key of the
						current entity. This is equivalent to the following statement: </para>
					<programlisting role="uniface"><![CDATA[findkey $entname, 1
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the findkey statement: </para>
					<programlisting role="uniface"><![CDATA[findkey $entname, $NEWKEYVALUE$
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.flush">
				<title>flush</title>
				<para> Introduced in: U9 </para>
				<para>Complete a file management transaction for the specified open zip archive,
					then close the file. </para>
				<sect2>
					<title>Syntax</title>
					<para>flush " ZipArchive :" </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>ZipArchive—zip archive name, optionally preceded by the path to the file. </para>
					<para>See Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para/>
					<para>When accessing files and directories located in zip archives, Uniface
						keeps the zip archives open to avoid the performance problems entailed by
						repeatedly opening and closing files. The flush Proc statement explicitly
						completes an open transaction for a specified zip archive and closes the
						file, taking any assignment file redirections into account. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example writes data to the <emphasis role="bold"
							>def.txt</emphasis> file located in the <emphasis role="bold"
							>dir1</emphasis> directory within the <emphasis role="bold"
							>b5.zip</emphasis> archive, then saves and close the file using flush.
						Since no absolute path is specified, the location of the zip archive is
						determined by the assignment file. If it is not defined there, it defaults
						to the Uniface project directory.</para>
					<programlisting role="uniface"><![CDATA[filedump "abc", "b5.zip:dir1\def.txt"
flush "b5.zip:"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.frac">
				<title>frac [DEPRECATED]</title>
				<warning>
					<para> The command <function>frac</function> was replaced by <link
							linkend="langref.dollar_frac">
							<function>$frac</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'frac' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_frac">
							<function>$frac</function>
						</link> was introduced to replace <literal>frac</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.getitem">
				<title>getitem</title>
				<para>Copy an item from a list to a field or variable. </para>
				<sect2>
					<title>Syntax</title>
					<para>getitem Target , List , N </para>
					<para>getitem/id{/case} Target , List , Index </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/id—get the item specified by Index from an associative list.
							</para>
						</listitem>
						<listitem>
							<para>/case—both the value and the case of Index must match the item in
								the list </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Target—destination of the copied item; can be a field, indirect
								reference to a field, variable, or an assignable function that can
								accept a string value. </para>
						</listitem>
						<listitem>
							<para>List—source list of the item to be copied; can be string, or field
								(or indirect reference to a field), variable, or a function that
								evaluates to a string. </para>
						</listitem>
						<listitem>
							<para>N—number of the item in the list. (Items are numbered starting
								with 1.) It can be a constant, or a field (or indirect reference to
								a field), variable, or function that can be converted to a whole
								(integer) number; the value will be truncated to form an integer.
							</para>
						</listitem>
						<listitem>
							<para>Index—item in an associative list; can be a string, or a field (or
								indirect reference to a field), variable, or function that evaluates
								to a string; it may not be an expression. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> No item was copied; Target is empty. </entry>
								</row>
								<row>
									<entry> &gt;0</entry>
									<entry> Sequence number of the list item that was copied.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The getitem statement copies an item from List to Target. </para>
					<para>For more information on the structure of lists, see Lists and Sublists. </para>
					<para>If List contains an associative list, and you don't use the /id switch,
						the item that is copied is the entire ValRep for the associative item. If N
						is -1, the last item from List is copied. Otherwise, if N does not refer to
						an existing item, no item is copied. </para>
				</sect2>
				<sect2>
					<title>Associative Lists</title>
					<para>Use the /id switch to get from an associative list the representation of
						the item whose value is Index. </para>
					<para>By default, matching Index with item values is not case-sensitive. For
						example, the following statement gets from $LIST$ the first item encountered
						whose value is ab, Ab, aB, or AB: </para>
					<programlisting role="uniface"><![CDATA[getitem/id $2, $LIST$, "ab"
					]]></programlisting>
					<para>Use the /case switch with /id to cause matching to be case-sensitive. For
						example, the following statement only gets an item whose value is ab: </para>
					<programlisting role="uniface"><![CDATA[getitem/id/case $2, $LIST$, "ab"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying an Indexed List Item to a Variable</title>
					<para>In the examples, an underlined semicolon ( <emphasis role="underline">;
						</emphasis>) represents the Uniface subfield separator (by default, GOLD ;)
						and an underlined exclamation point ( <emphasis role="underline">!
						</emphasis>) represents the retrieve profile character for logical NOT (GOLD
						!). </para>
					<para>The following example copies the third item from an indexed list to the
						variable $1: </para>
					<programlisting role="uniface"><![CDATA[$valrep(DBMSFLD) = "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb"   ;"syb" copied to $1
getitem $1, $valrep(DBMSFLD), 3
]]></programlisting>
					<para>The same item could also be copied by treating the list as an associative
						list: </para>
					<programlisting role="uniface"><![CDATA[$valrep(DBMSFLD) = "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb"
getitem/id $1, $valrep(DBMSFLD), "syb"   ;"syb" copied to $1
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying an Associative List Item to a Variable</title>
					<para>The following example treats the associative list as an indexed list and
						copies the entire third ValRep from the list to the variable $2: </para>
					<programlisting role="uniface"><![CDATA[$valrep(DATEFLD) = %\
"mon=monday<emphasis role="underline">;</emphasis>tue=tuesday<emphasis role="underline">;</emphasis>wed=wednesday<emphasis role="underline">;</emphasis>weekend=sat<emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis>sun"
getitem $2, $valrep(DATEFLD), 3   ;"wed=wednesday" copied to $2
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Finding Items in Associative Lists</title>
					<para>The following example looks in an associative list to find the item whose
						value is weekend and copies the representation of that item to the variable
						$3. Finally, assuming that $3 now contains a list, it copies the first item
						in that list to $4. </para>
					<programlisting role="uniface"><![CDATA[$valrep(DATEFLD) = %\
"mon=monday<emphasis role="underline">;</emphasis>tue=tuesday<emphasis role="underline">;</emphasis>wed=wednesday<emphasis role="underline">;</emphasis>weekend=sat<emphasis role="underline">!</emphasis><emphasis role="underline">;</emphasis>sun"
getitem/id $3, $valrep(DATEFLD), "weekend"   ;"sat<emphasis role="underline">;</emphasis>sun" copied to $3
getitem $4, $3, 1   ;"sat" copied to $4
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.getlistitems">
				<title>getlistitems</title>
				<para>Copy items from a list into a field or variable. </para>
				<sect2>
					<title>Syntax</title>
					<para>Fill one field in successive occurrences from list items: </para>
					<para>getlistitems List , Field </para>
					<para>Fill one or two fields in successive occurrences from list items: </para>
					<para>getlistitems/id List , {TargetValue}, TargetRepresentation </para>
					<para>getlistitems/id List , TargetValue </para>
					<para>Fill fields of current occurrence from list items: </para>
					<para>getlistitems/occ{/init} List , Entity </para>
					<para>Fill targets from representation part of list items: </para>
					<para>getlistitems/id{/field | /component | /global} List </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/id—copies items from an associative list into one or two fields
								in successive occurrences </para>
						</listitem>
						<listitem>
							<para>/occ—copies the representation of items in an associative list
								into the field </para>
						</listitem>
						<listitem>
							<para>/init—sets the value of the target field in a non-database
								occurrence without locking the occurrence or changing the status of
								$fieldmod, $occmod, $occdbmod, $formmod, $instancemod, or
								$instancedbmod. </para>
						</listitem>
						<listitem>
							<para>/field—copies the representation of items in an associative list
								to a field </para>
						</listitem>
						<listitem>
							<para>/component—copies the representation of items in an associative
								list to a component variable </para>
						</listitem>
						<listitem>
							<para>/global—copies the representation of items in an associative list
								to a global variable </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>List—source list of the item to be copied; can be string, or field
								(or indirect reference to a field), variable, or a function that
								evaluates to a string. </para>
						</listitem>
						<listitem>
							<para>Field—field painted on the component; can be a literal name, or a
								string, variable, function, or parameter that evaluates to the name.
							</para>
						</listitem>
						<listitem>
							<para>TargetValue—value in an associative list </para>
						</listitem>
						<listitem>
							<para>TargetRepresentation—value representation in an association list
							</para>
						</listitem>
						<listitem>
							<para>Entity—entity where fields of an occurrence are to be filled. Can
								be a string, or a field, variable, function, or parameter that
								evaluates to a string. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> No items were copied. </entry>
								</row>
								<row>
									<entry> &gt;0</entry>
									<entry> Number of the items copied.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>getlistitems/id/global is allowed in form components (and in service and
						report components that are not self-contained). </para>
					<para>Other forms are allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The getlistitems statement gets items from List and copies them to the
						specified destination. Use it to get and copy: </para>
					<itemizedlist>
						<listitem>
							<para>The contents of items in an indexed list to the field Field in
								successive occurrences of its entity. </para>
						</listitem>
						<listitem>
							<para>The value and representation (ValRep) of items in an associative
								list into the fields TargetValue and TargetRepresentation in
								successive occurrences of the current entity. </para>
						</listitem>
						<listitem>
							<para>The representation of items in an associative list into the fields
								of the named Entity that are identified by the associated value of
								each item. </para>
						</listitem>
						<listitem>
							<para>The representation of items in an associative list into the
								fields, and variables that are identified by the associated value of
								each item. </para>
						</listitem>
					</itemizedlist>
					<para>For information about the structure of lists, see Lists and Sublists.
					</para>
				</sect2>
				<sect2>
					<title>Copying to Successive Occurrences</title>
					<para>...</para>
					<para>When items are copied from a list into a field or pair of fields in
						successive occurrences of an entity, the first list item is copied into the
						current occurrence and <emphasis role="italic">new occurrences</emphasis>
						are created for the subsequent items. </para>
					<para>When copying data into successive occurrences, if one of the specified
						fields occurs in an entity that is painted as an up entity, then the nearest
						outer entity that is painted as a down entity is used to control the
						movement of data into occurrences. If both of the fields specified are
						painted as up entities, the nearest outer entity of the first field controls
						the movement. </para>
				</sect2>
				<sect2>
					<title>Filling One Field in Successive Occurrences</title>
					<para>To copy items from an indexed list to a single field in successive
						occurrences, use getlistitems with no switch. Each item is copied to the
						indicated field in successive occurrences of its entity. If an unqualified
						field name is used, the current entity is used. The entire item is copied to
						Field, even if the item is structured like an associative list item. </para>
					<para>The argument Field should be one of the following: </para>
					<itemizedlist>
						<listitem>
							<para>The literal name of a field painted on the component. For example,
								INV_NBR. </para>
						</listitem>
						<listitem>
							<para>A string that evaluates to the name of a field. For example,
								"INV_NBR". </para>
						</listitem>
						<listitem>
							<para>A variable, function, or parameter that evaluates to a string that
								contains the name of a field. For example: <itemizedlist>
									<listitem>
										<para>$1, where $1 contains "INV_NBR". </para>
									</listitem>
									<listitem>
										<para>PARAM1, where PARAM1 contains "INV_NBR". </para>
									</listitem>
									<listitem>
										<para>$fieldname, where $fieldname contains "INV_NBR".
										</para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Filling One or Two Fields From Associative Lists</title>
					<para> To copy list items into one or two fields in successive occurrences, use
						getlistitems with the /id switch and at least one of TargetValue and
						TargetRepresentation. <itemizedlist>
							<listitem>
								<para>If both TargetValue and TargetRepresentation are present, for
									each item in the associative list, the value part of the item is
									copied to the field TargetValue and the representation part is
									copied to the field TargetRepresentation in successive
									occurrences. </para>
							</listitem>
							<listitem>
								<para>If TargetValue is omitted, only the representations are
									copied. </para>
							</listitem>
							<listitem>
								<para>If TargetRepresentation is omitted, only the values are
									copied. </para>
							</listitem>
						</itemizedlist>
						<emphasis role="bold"> Note:</emphasis> If one of the switches /field,
						/component, or /global appears with /id, it is ignored. </para>
				</sect2>
				<sect2>
					<title>Copying Representations of List items Into Targets</title>
					<para>To copy the representation part of each item in an associative list into
						the target specified by the value part of that item, use getlistitems with
						the /id switch, a List name, and no further arguments. The value part of the
						item can contain the name of a field, a component variable, a global
						variable, or a general variable. For example: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "NAME=Frodo<emphasis role="underline">;</emphasis>$LOC_TOT$=14<emphasis role="underline">;</emphasis>$$GLOB_TOT=329<emphasis role="underline">;</emphasis>$1=-8"
getlistitems/id $LIST$
 ]]></programlisting>
					<para>After these statements have been executed, the field NAME contains
						'Frodo', the component variable $LOC_TOT$ contains 14, the global variable
						$$GLOB_TOT contains 329 and the general variable $1 contains -8. </para>
					<para>For each item, if the field or variable named by the value cannot be
						found, no action is taken. </para>
					<para>If the value part of a list item does not contain a dollar sign ($), the
						target is assumed to be a field unless one of the target switches /field,
						/component, or /global is present. </para>
					<para><emphasis role="bold"> Note:</emphasis> You can use the switch /local as a
						synonym for /component. In this case, component variables are still the
						source for the getlistitems statement; local variables are not used.</para>
					<para>If one of these target switches is specified, names that do not include a
						dollar sign are treated as the specified target type. (If a name includes a
						dollar sign, it is treated as the type indicated.) In the following example,
						a field NAME, a component variable $NAME$ and a global variable $$NAME are
						all available, as well as a field TOTAL and a component variable $TOTAL$: </para>
					<programlisting role="uniface"><![CDATA[NAME = ""
$NAME$ = ""
$$NAME = ""
TOTAL = 0
$TOTAL$ = 0
$LIST$ = "NAME=Frodo<emphasis role="underline">;</emphasis>$TOTAL$=123.45"
getlistitems/id $LIST$     ;NAME is Frodo, $TOTAL$ Is 123.45, TOTAL Is
0
getlistitems/id/field $LIST$   ;NAME is Frodo, $TOTAL$ Is 123.45, TOTAL Is 0
getlistitems/id/component $LIST$ ;$NAME$ is Frodo, $TOTAL$ Is 123.45, TOTAL Is 0
getlistitems/id/global $LIST$   ;$$NAME is Frodo, $TOTAL$ Is 123.45,
TOTAL Is 0
]]></programlisting>
					<para>Although it is usually good practice to include the dollar signs ($) that
						form part of the variable name in each list item's value, these must be
						omitted to take advantage of the power of the target switches. </para>
					<para>Because the list argument is evaluated at run time, you should consider
						the following points when you create the component: </para>
					<itemizedlist>
						<listitem>
							<para>The existence of the referenced objects (fields and variables)
								cannot be verified by the compiler </para>
						</listitem>
						<listitem>
							<para>Any referenced fields cannot be included in an Automatic field
								list </para>
						</listitem>
					</itemizedlist>
					<para>Be sure that all the fields that will be referenced are included in the
						entity's field list (by using All Fields or a User-Defined field list) and
						that all the component and global variables are defined.</para>
				</sect2>
				<sect2>
					<title>Filling Fields in an Entity</title>
					<para>To copy the representation of each item in an associative list into the
						field (in the current occurrence of the specified Entity) that is identified
						by the associated value, use getlistitems with the /occ switch. If a field
						is not available in the component, the item is not copied. Specifying Entity
						makes it possible to identify the entity uniquely in case of duplicate field
						names. </para>
					<para>The argument Entity should specify the entity where fields of an
						occurrence are to be filled as one of the following: </para>
					<itemizedlist>
						<listitem>
							<para>A string that evaluates to the name of an entity. For example,
								"INVOICES". </para>
						</listitem>
						<listitem>
							<para>A variable, function, or parameter that evaluates to a string that
								contains the name of an entity. For example: <itemizedlist>
									<listitem>
										<para>$1, where $1 contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>PARAM1, where PARAM1 contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>$entname, where $entname contains "INVOICES". </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Filling a Field in Successive Occurrences </title>
					<para>In the examples, an underlined semicolon ( <emphasis role="underline">;
						</emphasis>) represents the Uniface subfield separator (by default, GOLD ;)
						and an underlined exclamation point ( <emphasis role="underline">!
						</emphasis>) represents the retrieve profile character for logical NOT (GOLD
						!). </para>
					<para>The following example copies the three items of an indexed list into the
						field DAY in the current occurrence and two added occurrences of the entity
						CALENDAR: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "Monday<emphasis role="underline">;</emphasis>Tuesday<emphasis role="underline">;</emphasis>Wednesday"
setocc "CALENDAR", 1    ; Make first occurrence current
getlistitems $LIST$, DAY.CALENDAR
; DAY of current occurrence is "Monday"
; DAY of 1st added occurrence is "Tuesday"
; DAY of 2nd added occurrence is "Wednesday"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling a Pair of Fields in Successive Occurrences</title>
					<para>The following example copies the three items of an associative list into
						the fields NUM and NAME in the current occurrence and two added occurrences
						of the entity CALENDAR. The associated parts of the ValRep of each item are
						placed in the fields NUM and NAME. </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "d1=Mon<emphasis role="underline">;</emphasis>d2=Tue<emphasis role="underline">;</emphasis>d3=Wed"
setocc "CALENDAR", 1   ; Make first occurrence current
getlistitems/id $LIST$, NUM.CALENDAR, NAME.CALENDAR
; NUM is "d1" and NAME is "Mon" of current occ
; NUM is "d2" and NAME is "Tue" of added occ
; NUM is "d3" and NAME is "Wed" of added occ
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling Fields in the Current Occurrence </title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item into the field (in the current entity)
						identified by the value part of the item: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "day1=Mon<emphasis role="underline">;</emphasis>day2=Tue<emphasis role="underline">;</emphasis>day3=Wed"
getlistitems/id/field $LIST$
; copies "Mon" to field DAY1
; copies "Tue" to field DAY2
; copies "Wed" to field DAY3
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling Component Variables </title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item into the component variable identified by
						the value part of the item: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "day1=Mon<emphasis role="underline">;</emphasis>day2=Tue<emphasis role="underline">;</emphasis>day3=Wed"
getlistitems/id/component $LIST$
; copies "Mon" to component variable $DAY1$
; copies "Tue" to component variable $DAY2$
; copies "Wed" to component variable $DAY3$
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling Global Variables </title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item into the global variable identified by the
						value part of the item: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "day1=Mon<emphasis role="underline">;</emphasis>day2=Tue<emphasis role="underline">;</emphasis>day3=Wed"
getlistitems/id/global $LIST$
; copies "Mon" to global variable $$DAY1
; copies "Tue" to global variable $$DAY2
; copies "Wed" to global variable $$DAY3
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling Fields and Variables </title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item into the target identified by the value part
						of the item. The type of the target (that is, whether it is a field or
						variable) is derived from the value of the item. </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "day1=Mon<emphasis role="underline">;</emphasis>$day2$=Tue<emphasis role="underline">;</emphasis>$$day3=Wed"<emphasis role="underline">;</emphasis>$9=Thu
getlistitems/id $LIST$
; copies "Mon" to the field DAY1
; copies "Tue" to component variable $DAY2$
; copies "Wed" to global variable $$DAY3
; copies "Thu" to general variable $9
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling Fields in a Named Entity</title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item into the field (of entity WEEK) identified
						by the value part of the item. Notice that this is similar to the first
						example above using the /field switch, except that the target entity name is
						specified with the getlistitems/occ statement. </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "day1=Mon<emphasis role="underline">;</emphasis>day2=Tue<emphasis role="underline">;</emphasis>day3=Wed"
getlistitems/occ $LIST$, "WEEK"
; copies "Mon" to the field DAY1.WEEK
; copies "Tue" to the field DAY2.WEEK
; copies "Wed" to the field DAY3.WEEK
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.goto">
				<title>goto</title>
				<para>Branch unconditionally to the specified label. </para>
				<warning>
					<para>Using the goto statement is very ill advised and shows poor programming
						skills. You should avoid using this command at all times. There is no reason
						that you shoul drequire a goto statement that can not be done using an entry
						or an operation.</para>
				</warning>
				<sect2>
					<title>Syntax</title>
					<para> goto Label </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> ... Label—label of a statement in the current Proc module </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The goto statement continues execution within the current Proc module,
						beginning at the statement identified by Label. For a more structured
						approach to programming, use the while or repeat statements. </para>
				</sect2>
				<sect2>
					<title>Example: goto Proc Label</title>
					<para>The following example deletes the first 1001 records, then exits the
						current component. This is typically used when a component is defined for
						transaction processing. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
$1 = 0
retrieve
start:          ; the label ends with a colon (:)
if ($1 = 1001)
   store
   exit
else
   remocc
   $1 = $1 + 1
endif
goto start      ; but no colon is used in the goto line
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.help">
				<title>help</title>
				<para>Display help information, either a Uniface help message or information from
					the native help system (HTML page or WinHelp).</para>
				<sect2>
					<title>Syntax</title>
					<para>help (/topic | /keyword) Parameters | {/noborder} </para>
					<para>help {/noborder} HelpMessage {, VertPos , HorizPos{, VertSize ,
						HorizSize}} </para>
					<para>help/topic Subject {, LogicalName} | </para>
					<para>help/keyword Keyword {, LogicalName} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/topic—retrieves and displays an online help topic, index, or
								table of contents from the native help system </para>
						</listitem>
						<listitem>
							<para>/keyword—retrieves and displays help about a keyword from a
								WinHelp file </para>
						</listitem>
						<listitem>
							<para>/noborder—in character mode, displays the form window for
								USYS:USYSTXT without a border. The switch is ignored in GUI mode and
								also within the Web environment. </para>
						</listitem>
					</itemizedlist>
					<para>If no switch is specified, a Uniface help message is displayed.</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Subject—string, or field (or indirect reference to a field),
								variable, or function that evaluates to a string that identifies the
								help topic. If Subject is an empty string (""), the index or table
								of contents for the native help is displayed. </para>
						</listitem>
						<listitem>
							<para>LogicalName—string, or a field (or indirect reference to a field),
								a variable, or a function that evaluates to a string. If LogicalName
								is present, Uniface gets the location of the help file from the
								system initialization file (for example, the <emphasis role="bold"
									>.ini</emphasis> file). If the argument LogicalName is omitted
								or if the logical name is not found in the initialization file, the
								logical name DEFAULT is used. </para>
						</listitem>
						<listitem>
							<para>Keyword—string, or a field (or indirect reference to a field), a
								variable, or a function that evaluates to a string. If Keyword is an
								empty string ("") or is not found, the native help engine displays
								an error message. </para>
						</listitem>
						<listitem>
							<para>HelpMessage—string, or a field, variable, or function that
								evaluates to a string. Often, the function $text is used, referring
								to a global help text or message. </para>
						</listitem>
						<listitem>
							<para>VertPos, HorizPos, VertSize, and HorizSize—position and size of
								the help form, expressed in character cells. If the help text is
								larger than the size defined, vertical and horizontal scroll bars
								appear as needed. By default, the help window appears with a size
								that exactly fits the help text being displayed. These arguments
								have no effect in the Web environment. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values Returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1</entry>
									<entry> Uniface help form was exited with ^ACCEPT. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Native help successfully started. This value is always
										returned in the Web environment. Uniface help form was left
										with ^QUIT. </entry>
								</row>
								<row>
									<entry> -1</entry>
									<entry> Uniface help form <emphasis role="bold"
											>USYS:USYSTXT.frm</emphasis> could not be found.
									</entry>
								</row>
								<row>
									<entry> -2</entry>
									<entry> Uniface help form is not correct. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Unable to start native help. </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> Platform does not support native help. (If this case you
										may want to use the help statement to provide help
										information.) </entry>
								</row>
								<row>
									<entry> -5 </entry>
									<entry> Native help does not support the requested option.
									</entry>
								</row>
								<row>
									<entry> -6 </entry>
									<entry> Unable to map logical name. </entry>
								</row>
								<row>
									<entry> -7 </entry>
									<entry> Requested topic or keyword not found. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following help </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -350 </entry>
									<entry> &lt;UHLPERR_STARTUP&gt; </entry>
									<entry> Unable to start help. Uniface form <emphasis role="bold"
											>USYS:USYSTXT.frm</emphasis> is missing or is not
										correct. </entry>
								</row>
								<row>
									<entry> -351 </entry>
									<entry> &lt;UHLPERR_PLATFORM&gt; </entry>
									<entry> Platform does not support native help. (In this case you
										may want to use the help [native] statement to provide help
										information.) </entry>
								</row>
								<row>
									<entry> -352 </entry>
									<entry> &lt;UHLPERR_LOGICAL_NAME&gt; </entry>
									<entry> Unable to map logical name. </entry>
								</row>
								<row>
									<entry> -354 </entry>
									<entry> &lt;UHLPERR_OPTION&gt; </entry>
									<entry> Native help does not support the requested option.
									</entry>
								</row>
								<row>
									<entry> -353 </entry>
									<entry> &lt;UHLPERR_TOPIC&gt; </entry>
									<entry> Requested help topic or keyword not found. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When used with the /topic or /keyword switches, the help statement starts
						a native help engine to display the specified information. For example, in
						the Development Environment itself, the Uniface Library is started using the
						/topic switch to display help about the current form or Proc keyword.</para>
					<para>When used without a switch or with /noborders, the help statement displaus
						the specified Uniface help text in an overlay help form (USYS:USYSTXT)
						available with Uniface. The focus stays with the help window until the user
						uses either ^QUIT or ^ACCEPT or clicks the button on the USYS:USYSTXT form.
						At that point, control of the application is returned to the statement
						following the help statement. </para>
				</sect2>
				<sect2>
					<title>Example: Calling Native Help </title>
					<para>The following example starts the native help engine and displays the index
						from the help file identified by the logical name MYHELP: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Help help/topic " ", "myhelp"
if ($status &lt; 0)
    message "Unable to show help index: %%$status"
endif
end ; end trigger
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Calling Uniface Help Message</title>
					<para>The following example displays the help text or message identified by
						HELPTEXT. The example assumes that the appropriate $language and $variation
						settings are used. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Help help/noborder $text(HELPTEXT), 3,4,7,23
]]></programlisting>
				</sect2>
				<sect2>
					<title>if</title>
					<para>Define an if/endif conditional block. </para>
				</sect2>
				<sect2>
					<title>Syntax</title>
					<para>if Condition 1 ) </para>
					<para> ... one or more Proc statements ... </para>
					<para>{elseif Condition 2 ) </para>
					<para> ... one or more Proc statements ... </para>
					<para>... </para>
					<para>elseif Condition n ) </para>
					<para> ... one or more Proc statements ... } </para>
					<para>{else </para>
					<para> ... one or more Proc statements ... } </para>
					<para>endif </para>
				</sect2>
				<sect2>
					<title>Clauses</title>
					<itemizedlist>
						<listitem>
							<para>if—defines a condition and marks the Proc code to be executed if
								the condition is met. </para>
						</listitem>
						<listitem>
							<para>elseif—defines an alternative condition to that introduced by the
								If statement, and marks the Proc code to be executed if the
								Condition is met. </para>
						</listitem>
						<listitem>
							<para>else—marks the Proc code to be executed if none of the previous
								conditions have been met. If no else clause is present, no Proc
								statements are executed. </para>
						</listitem>
						<listitem>
							<para>endif—marks the end of the if conditional block </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Condition—expression that evaluates to a Boolean. Uniface performs
						implicit data type conversion if the expression is of a data type other then
						Boolean. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>An if/endif block allows you to write Proc code that is conditionally
						executed based on the results of logical expressions. Each Condition is
						evaluated in sequence, beginning with the one on the if statement. </para>
					<itemizedlist>
						<listitem>
							<para>If a Condition is evaluated as TRUE, the following group of Proc
								statements up to the next elseif, else, or endif statement is
								executed. </para>
						</listitem>
						<listitem>
							<para>If a Condition is FALSE, the Proc statements following the else
								statement are executed. If no else clause is present, no Proc
								statements are executed. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Nesting and Writing if Blocks</title>
					<para>Any number of elseif clauses may be included. Conditional statements such
						as if/endif, while/endwhile, and repeat/until can be nested up to 32 levels. </para>
					<itemizedlist>
						<listitem>
							<para>In each if, elseif, and else clause, if there is more than one
								Proc statement, each statement must begin on a separate line,
								beginning on the line below the if, elseif, or else statement.
							</para>
						</listitem>
						<listitem>
							<para>If only one Proc statement is required for the if clause, it can
								occur on the same line as the if; in this case, do not include any
								elseif clauses, an else clause, or an endif. </para>
						</listitem>
						<listitem>
							<para>If only one Proc statement is required for an elseif clause, it
								can occur on the same line; in this case, do not include further
								elseif clauses, an else clause or an endif. </para>
						</listitem>
						<listitem>
							<para>If only one Proc statement is required for the else clause, it can
								occur on the same line; in this case, do not include an endif. This
								style of programming is not recommended. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Conditionally Printing a Break Frame</title>
					<para>The following example shows how an if statement is used to conditionally
						print a break frame: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Printed Occurrence
; if next invoice date different
;    print "SUBTOTAL" break frame
;    set subtotal to 0
;    start printing on next page
; else
;    print next line empty
AMOUNT.SUBTOTAL = (AMOUNT.SUBTOTAL + INVAMOUNT)
if (INVDATE != $next(INVDATE))
   printbreak "SUBTOTAL"
   AMOUNT.SUBTOTAL = 0
   eject
else
   skip
endif]]></programlisting>
					<para>This could also be written as: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Printed Occurrence
; if next invoice date different
;    print "SUBTOTAL" break frame
;    set subtotal to 0
;    start printing on next page
; else print next line empty
AMOUNT.SUBTOTAL = (AMOUNT.SUBTOTAL + INVAMOUNT)
if (INVDATE != $next(INVDATE))
   print_break "SUBTOTAL"
   AMOUNT.SUBTOTAL = 0
   eject
else skip]]></programlisting>
					<para>The first format is more legible than the second. For ease of maintenance,
						it is recommended that you use only the first format. </para>
				</sect2>
				<sect2>
					<title>Example: Determining the Alphabetic Range of a Field</title>
					<para>The following example illustrates a simple use of the elseif clause to
						determine the alphabetic range of the field NAME: </para>
					<programlisting role="uniface"><![CDATA[$1 = NAME[1:1]
if ($1 &lt; "M")
   message "NAME starts A-L"
elseif ($1 &gt; "M")
   message "NAME starts N-Z"
else
   message "NAME starts M"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.int">
				<title>int [DEPRECATED]</title>
				<warning>
					<para> The command <function>int</function> was replaced by <link
							linkend="langref.dollar_int">
							<function>$int</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'int' used </literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_int">
							<function>$int</function>
						</link> was introduced to replace <literal>int</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.ldircreate">
				<title>ldircreate</title>
				<para> Introduced since: U8. Create the specified directory in the working
					directory, ignoring redirections in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para>ldircreate NewDirPath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>NewDirPath—directory name, optionally preceded by the path to the
						directory, which can be in a zip archive. Must end with a directory
						separator. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The ldircreate statement creates the specified directory in the current
						working directory, ignoring any file redirections in the assignment file.
					</para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if NewDirPath:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Does not permit user-creation due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Unix</title>
					<para>On Unix, the directory is created with read and write access on world,
						group, and user level.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On iSeries, ldircreate creates a library or a file in a library or, when
						the IFS prefix is used, a directory in the IFS.</para>
					<para>If used without the IFS prefix, a library, or a file in a library, is
						created. Libraries cannot have sublibraries, so no more than one directory
						separator is allowed. That is, the only allowed syntax is library/ or file
						or library/file. </para>
					<para>If used with the IFS prefix, an IFS directory is created. Directories in
						the IFS can have subdirectories, but the different file systems existing in
						the IFS have their own rules and limitations. For more information, see
						File-Naming Considerations on iSeries.</para>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On z/OS, ldircreate can create a directory in an HFS system or a PDS in a
						partioned dataset system. However it does not create a prefix (the dataset
						structure to which the concept of directory is mapped) in a sequential
						dataset.</para>
					<para>If used with the HFS: prefix, ldircreate creates a directory as
						expected.</para>
					<para>If used with the prefixes DNS:, TSO:, or ! prefix: </para>
					<itemizedlist>
						<listitem>
							<para>If the specified name ends with () or starts with @ to indicate a
								PDS, ldircreate creates an empty PDS. For example:
								<programlisting role="uniface"><![CDATA[ldircreate("@DSN:A/B/C")
ldircreate ("DSN:A/B/C()")]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>Otherwise, it does nothing but reports success. An error status is
								returned only if there is already a dataset that starts with
								specified name. </para>
							<para>For example, the following instruction to create a directory path
									<emphasis role="bold">A.B.C</emphasis> does nothing because
								sequential datasets use file name prefixes. The concept of a
								directory as container of files does not exist.
								<programlisting role="uniface"><![CDATA[ldircreate("DSN:A/B/C")]]></programlisting></para>
						</listitem>
					</itemizedlist>
					<para>If no prefix is specified, Uniface sets it to TSO:, for example, a/b/c
						becomes TSO:a.b.c. and ldircreate behaves as described above. </para>
					<para>For more information, see File-Naming Considerations on z/OS.</para>
				</sect2>
				<sect2>
					<title>Example: Creating a Directory in the Current Working Directory</title>
					<para>The following Proc code creates a directory with the name <emphasis
							role="bold">coffee</emphasis> in the current working directory:</para>
					<programlisting role="uniface"><![CDATA[ldircreate "coffee"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Creating a Directory in an Existing Directory</title>
					<para>The following Proc code creates a directory with the name <emphasis
							role="bold">coffee</emphasis> in the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory:</para>
					<programlisting role="uniface"><![CDATA[ldircreate "sub1dir\coffee\"
]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[ldircreate "[.sub1dir.coffee.]"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.ldirdelete">
				<title>ldirdelete</title>
				<para> Introduced since: U8. </para>
				<para>Delete the specified directory. </para>
				<sect2>
					<title>Syntax</title>
					<para> ldirdelete DirPath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>DirPath—directory name, optionally preceded by the path to the directory.
						The directory can be located in a ZIP archive. Must end with a directory
						separator. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The ldirdelete statement deletes the specified directory DirPath, ignoring
						any file redirections in the assignment file. </para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if DirPath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a directory </para>
						</listitem>
						<listitem>
							<para>Is the current directory or root </para>
						</listitem>
						<listitem>
							<para>Is not empty </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-deletion due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>When used without the IFS prefix, deleting libraries is only possible for
						libraries that are not in use and not on your own or somebody else’s library
						list. The same applies for files in libraries. Negative return values can be
						expected.</para>
					<para>When used with an IFS prefix, directories are deleted as expected.</para>
					<para>For more information, see File-Naming Considerations on iSeries.</para>
				</sect2>
				<sect2>
					<title>z/OS</title>
					<para>On z/OS, ldirdelete can delete an empty directory in an HFS system or an
						empty PDS in a partioned dataset system. However it does not delete a prefix
						(the dataset structure to which the concept of directory is mapped) in a
						sequential dataset.</para>
					<para>If used with the HFS: prefix, ldirdelete deletes a directory as
						expected.</para>
					<para>If used with the prefixes DNS:, TSO:, or ! prefix: </para>
					<itemizedlist>
						<listitem>
							<para>If the specified name starts with @ or ends with () to indicate a
								PDS, ldirdelete deletes an empty PDS. For example:
								<programlisting role="uniface"><![CDATA[ldirdelete("@DSN:A/B/C")
ldirdelete ("DSN:A/B/C()")]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>Otherwise, it does nothing but reports success. An error status is
								returned only if there is already a dataset that starts with
								specified name, in which case it is considered to be not empty.
							</para>
						</listitem>
					</itemizedlist>
					<para>If no prefix is specified, Uniface sets it to TSO:, for example, a/b/c
						becomes TSO:a.b.c. and ldirdelete behaves as described above. </para>
					<para>For more information, see File-Naming Considerations on z/OS.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc code deletes the directory <emphasis role="bold"
							>tea</emphasis> if it is empty and the user confirms that it may be
						deleted:</para>
					<programlisting role="uniface"><![CDATA[$dir$ = "drinks\tea\"
; or $dir$ = "drinks/tea/"
; or $dir$ = "[drinks.tea]"
if ($ldirlist($dir$,"dir") = "" &amp; $ldirlist($dir$,"file") = "")
   askmess/warning "Do you want to delete '%%$dir$'?", "Yes, No"
   if ($status = 1) 
      ldirdelete $dir$
   else
   message/error "Directory '%%$dir$' is not empty!"
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.ldirrename">
				<title>ldirrename</title>
				<para> Introduced since: U8. Rename the specified directory, ignoring redirections
					in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para>ldirrename DirPath , NewDirName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>DirPath—directory name, optionally preceded by the path to the
								directory. Must end with a directory separator. </para>
						</listitem>
						<listitem>
							<para>NewDirPath—new directory name, optionally preceded by the path to
								the directory. Must end with a directory separator. </para>
						</listitem>
					</itemizedlist>
					<para>The directory can be located in a ZIP archive. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The ldirrename statement renames the specified directory DirPath to
						NewDirName, ignoring any file redirections in the assignment file. </para>
				</sect2>
				<sect2>
					<title>Specifying the Directory</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation failure</title>
					<para>The ldirrename operation fails if DirPath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a directory </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is not empty </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Is the current directory or root </para>
						</listitem>
						<listitem>
							<para>Does not permit user-renaming due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if NewDirName:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>When used without the IFS prefix, renaming libraries is only possible for
						libraries that are not in use and not on somebody else’s library list. The
						same applies for files in libraries. Negative return values can be
						expected.</para>
					<para>When used with an IFS prefix, directories can be renamed in the same way
						as on Unix systems.</para>
					<para>For more information, see File-Naming Considerations on iSeries.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following Proc code renames the directory <emphasis role="bold"
							>drinks\coffee</emphasis> to <emphasis role="bold"
						>drinks\tea</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[ldirrename "drinks\coffee\", "tea"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[ldirrename "[drinks.coffee]", "tea" ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.log">
				<title>log [DEPRECATED]</title>
				<warning>
					<para> The command <function>log</function> was replaced by <link
							linkend="langref.dollar_log">
							<function>$log</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'log' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_log">
							<function>$log</function>
						</link> was introduced to replace <literal>log</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.log10">
				<title>log10 [DEPRECATED]</title>
				<warning>
					<para> The command <function>log10</function> was replaced by <link
							linkend="langref.dollar_log10">
							<function>$log10</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'log10'
						used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_log10">
							<function>$log10</function>
						</link> was introduced to replace <literal>log10</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.length">
				<title>length</title>
				<para>Return the number of characters in the specified string. </para>
				<sect2>
					<title>Syntax</title>
					<para> length String </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>String—string, or a field (or indirect reference to a field), a variable,
						or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>$result is set to the number of characters in the string. </para>
					<para>$status is not affected. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The length statement finds the length of the piece of text in String. The
						value of $result is set to the number of characters in String. </para>
					<para>If String contains frame marker, ruler, or character attribute characters,
						they are ignored. </para>
					<para>The length statement is often used to determine where extraction should
						begin. </para>
				</sect2>
				<sect2>
					<title>Example: Find the Length of a String </title>
					<para>The following example finds the length of the string in $1: </para>
					<programlisting role="uniface"><![CDATA[; store contents of NOTEPAD in $1
; how long is string in $1?
; output = 11
$1 = "test string"
length $1
$2 = $result
output = $2
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Finding the Offset to Characters in a String </title>
					<para>The following example uses the length statement to find the offset to the
						last two characters in the string. In the example, the field INVNUM contains
						the value 90021387SH. This is the concatenation of a date (13-Feb-1990), a
						number (87), and a salesman's initials (SH): </para>
					<programlisting role="uniface"><![CDATA[; how long is invnum?
; $1 contains position second from end
; extract last 2 characters
; report their total sales
length INVNUM
$1=$result-1
$2=INVNUM[$1]
selectdb (sum(AMOUNT)) %\
   from "INVOICES" %\
   u_where (SALESCODE = $2) %\
   to SALESREPORT.DUMMY
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lfilecopy">
				<title>lfilecopy</title>
				<para> Introduced since: U8. </para>
				<para>Copy the specified file to the target location, ignoring file redirections in
					the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para> lfilecopy FilePath , DirPath | NewFilePath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>FilePath—file name, optionally preceded by the path to the file.
								Must <emphasis role="italic">not</emphasis> end with a directory
								separator. </para>
						</listitem>
						<listitem>
							<para>NewFilePath—new file name, optionally preceded by the path to the
								file. Must <emphasis role="italic">not</emphasis> end with a
								directory separator. </para>
						</listitem>
						<listitem>
							<para>DirPath—directory name, optionally preceded by the path to the
								directory. Must end with a directory separator </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfilecopy statement copies the specified file FilePath to the target
						location, either to DirPath or to NewFilePath, ignoring any file
						redirections in the assignment file. </para>
					<para>If DirPath is specified (that is, the path ends with a directory
						separator), the file FilePath is copied to the directory DirPath using the
						same file name.</para>
					<para>If NewFilePath is specified, the specified file is copied to the directory
						name and file name supplied in NewFilePath.</para>
				</sect2>
				<sect2>
					<title>Specifying Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names </para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation lfilecopy fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the directory part of DirPath or
						NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Does not already exist </para>
						</listitem>
						<listitem>
							<para>Does not permit user-writing due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the file NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Copying From and To Zip Files and Across Platforms</title>
					<para>If the the specified file FilePath is located in a ZIP archive, it can be
						copied to different directory in the same archive, to another ZIP archive,
						or to a directory on the file system.</para>
					<para>When copying files to or from zip archives, or across operating systems or
						media, Uniface handles text files differently than binary files. It copies
						binary files as-is, but it automatically adjusts text file attributes so
						that EOL characters and optional character set conversions match the
						platform. This may result in changes in the file size, making it appear that
						source and target files are not the same. </para>
					<para>You can define the files to be treated as text files, or switch off
						automatic cross-platform text file handling using the $TEXT_FILE_EXTENSIONS
						assignment setting.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On the iSeries, the particular ‘copy’ command that is used depends on the
						following circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>When both the source and the destination use the IFS prefix, or
								when both do <emphasis role="italic">not</emphasis> use the IFS
								prefix, the CPY command is used </para>
						</listitem>
						<listitem>
							<para>When the source has the IFS prefix, but the destination does not,
								then CPYFRMSTMF is used </para>
						</listitem>
						<listitem>
							<para>When the destination has the IFS prefix, but the source does not,
								then CPYTOSTMF is used. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Copying a File to Another Directory</title>
					<para>The following example copies the file <emphasis role="bold"
							>test.txt</emphasis> from the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory to the directory <emphasis
							role="bold">sub2dir</emphasis> in <emphasis role="bold"
							>sub1dir</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[lfilecopy "sub1dir\test.txt", "sub1dir\sub2dir\"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[lfilecopy "sub1dir/test.txt", "sub1dir/sub2dir/"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[lfilecopy "[.sub1dir]test.txt", "[.sub1dir.sub2dir]"]]></programlisting>
					<para>ON VMS, version 5 is retained in the copied file; on other platforms, it
						is not: </para>
					<programlisting role="uniface"><![CDATA[lfilecopy "[.sub1dir]test.txt;5", "[.sub1dir.sub2dir]"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying a Ffile to the Same Directory Under Another Name</title>
					<para>The following example copies the file <emphasis role="bold"
							>test1.txt</emphasis> to <emphasis role="bold">test2.txt</emphasis> in
						the same directory:</para>
					<programlisting role="uniface"><![CDATA[lfilecopy "sub1dir\test1.txt", "sub1dir\test2.txt"]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[lfilecopy "[.sub1dir]test1.txt", "[.sub1dir]test2.txt"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying a File to Another Directory Under Another Name</title>
					<para>The following example copies the file <emphasis role="bold"
							>test1.txt</emphasis> in the current directory to the file <emphasis
							role="bold">test2.txt</emphasis> in <emphasis role="bold"
							>sub3dir</emphasis> in the current directory:</para>
					<programlisting role="uniface"><![CDATA[lfilecopy "test1.txt", ".\sub3dir/test2.txt"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lfiledelete">
				<title>lfiledelete</title>
				<para> Introduced since: U8. </para>
				<para>Delete the specified file, ignoring file redirections in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para> lfiledelete FilePath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>FilePath—file name, optionally preceded by the path to the file. The file
						can be located in a ZIP archive. Must <emphasis role="italic">not</emphasis>
						end with a directory separator. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfiledelete statement deletes the specified file, ignoring any file
						redirections in the assignment file. </para>
				</sect2>
				<sect2>
					<title>Specifying Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-deletion due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example deletes the file <emphasis role="bold"
							>test.txt</emphasis> in the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory:</para>
					<programlisting role="uniface"><![CDATA[lfiledelete "sub1dir\test.txt"]]></programlisting>
					<para>VMS</para>
					<programlisting role="uniface"><![CDATA[lfiledelete "[.sub1dir]test.txt;5"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lfiledump">
				<title>lfiledump</title>
				<para> Introduced since: U8. </para>
				<para>Copy the contents of the source object to the specified file on the local file
					system, ignoring file redirections that might occur in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para> lfiledump {/text | /append | /image | /raw | /web{/raw}} Source ,
						FilePath {, UnicodeFormat} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/text—translates the raw data from FileName to the system
									character set or the UnicodeFormat. This is the default
									behavior. </para>
							</listitem>
							<listitem>
								<para>/append—appends the contents of Source to the specified
									FileName. If FileName does not exist, it is created. The /append
									switch cannot be used in conjunction with /image and /raw.
								</para>
							</listitem>
							<listitem>
								<para>/image—writes the raw data from Source, assuming that this
									data is an image. An initial hash character (#) is removed from
									the data before writing. (The hash character is an indicator to
									show that image data follows.) No further conversion is
									performed on the data in Source. </para>
							</listitem>
							<listitem>
								<para>/raw—writes the raw data from Source; an initial hash
									character (#) is not removed. No further conversion is performed
									on the data in Source, which is encoded as UTF-8. </para>
							</listitem>
							<listitem>
								<para>/web—in forms running in the Web Application Server, copies
									files that were downloaded via the browser. The files are in raw
									format, therefore there is no need to combine the /web and /raw
									switches, although this is allowed syntactically. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Source—object containing source data to be copied. It can be a
									literal name, or a string, a variable, or function that
									evaluates to a string containing the name. </para>
							</listitem>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. The file can be located in a ZIP archive. Must <emphasis
										role="italic">not</emphasis> end with a directory separator.
								</para>
							</listitem>
							<listitem>
								<para>UnicodeFormat—Unicode encoding format of the input file. It
									can be a string, or a field (or indirect reference to a field),
									a variable, or a function that evaluates to a string. Valid
									values are: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32BE and
									UTF-32LE. If not specified, the system character set is used.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfiledump statement copies Source directly to the local file system,
						ignoring file redirections that might occur in the assignment file (in
						contrast to filedump, which observes file redirections in the assignment
						file). The file FileName is created if it does not already exist. </para>
					<para>If FilePath is an existing file, its contents will be overwritten, unless
						you specify the /append option. </para>
					<para>Used without the /image or /raw switch, lfiledump converts the data to be
						stored to the character set specified by the assignment setting
						$SYS_CHARSET, or with the UnicodeFormat, if specified. </para>
					<para>If UnicodeFormat is specified, lfiledump writes a Unicode Byte-Order-Mark
						(BOM), a special character to recognize the encoding.</para>
				</sect2>
				<sect2>
					<title>Specifying the File Name</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information on specifying parameters, see Proc for File System
						Management </para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation lfiledump fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-writing due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lfileload">
				<title>lfileload</title>
				<para> Introduced since: U8. </para>
				<para>Copy the contents of the specified file into the target object, ignoring any
					file indirections in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para> lfileload{/text |/image | /raw | /web {/raw}} FileName , Target {,
						UnicodeFormat} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/text—translates the raw data from FileName to the system
								character set or the UnicodeFormat. This is the default behavior.
							</para>
						</listitem>
						<listitem>
							<para>/image—reads the raw data from FilePath, assuming that this data
								is an image. An initial hash character (#) is added to the data
								before copying the data to Target. (The hash character is an
								indicator to show that image data follows.) No further conversion is
								performed on the data. </para>
						</listitem>
						<listitem>
							<para>/raw—behaves similarly to the /image switch, except that the data
								in FileName is assumed not to be an image; an initial hash character
								(#) is not added. No further conversion is performed on the data.
							</para>
						</listitem>
						<listitem>
							<para>/web—when used in forms running in the Web Application Server, it
								loads files that were uploaded via the browser. The files are in raw
								format, therefore there is no need to combine the /web and /raw
								switches, although this is allowed syntactically. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. The file can be located in a zip archive, but must
										<emphasis role="italic">not</emphasis> end with a directory
									separator. </para>
							</listitem>
							<listitem>
								<para>Target—name of a field, a variable, or a parameter to receive
									the data. </para>
							</listitem>
							<listitem>
								<para>UnicodeFormat—Unicode encoding format of the input file. It
									can be a string, or a field (or indirect reference to a field),
									a variable, or a function that evaluates to a string. Valid
									values are: UTF8, UTF16, UTF-16BE, UTF-16LE, UTF-32BE and
									UTF-32LE. If not specified, the system character set is used.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfileload statement copies the contents of FilePath to the specified
						Target, ignoring any file indirections in the assignment file. </para>
					<para>Used without the /image or /raw switch, lfileload converts the data to be
						stored from the character set specified by the assignment setting
						$SYS_CHARSET or with the UnicodeFormat, if specified. </para>
					<para>lfileload checks for a Unicode Byte-Order-Mark (BOM), a special character
						to recognize the encoding. If no BOM is available, the indicated character
						set is used:</para>
					<table>
						<title>Table 2. Character Set Used if Unicode BOM Not Available</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Character Set Specified by UnicodeFormat </entry>
									<entry> Character Set Used</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> UnicodeFormat is not specified</entry>
									<entry> Character set specified by the $SYS_CHARSET assignment
										setting</entry>
								</row>
								<row>
									<entry> UTF-8 </entry>
									<entry> UTF-8 </entry>
								</row>
								<row>
									<entry> UTF-16 or UTF-32 </entry>
									<entry> Big-Endian character set; either UTF-16BE or UTF-32BE,
										according to Unicode specification </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>If the UnicodeFormat is specified as UTF-16BE, UTF-16LE, UTF-32BE or
						UTF-32LE, lfileload does not check the Unicode BOM because the character set
						is explicitly provided.</para>
					<para>To strip the end-of-line character from an otherwise empty input file, so
						the resulting data is truly empty, use the assignment setting
						$FILELOAD_SINGLE_LINE.</para>
					<para>If you want to copy contents from a file located on a network, use
						fileload.</para>
				</sect2>
				<sect2>
					<title>Specifying the File Name</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Does not permit user-reading due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lfilemove">
				<title>lfilemove</title>
				<para> Introduced since: U8. </para>
				<para>Move the specified file to the target location, ignoring any file redirections
					in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para> lfilemove FilePath , DirPath | NewFilePath </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>FilePath—file name, optionally preceded by the path to the file.
								Must <emphasis role="italic">not</emphasis> end with a directory
								separator. </para>
						</listitem>
						<listitem>
							<para>NewFilePath—new file name, optionally preceded by the path to the
								file. Must <emphasis role="italic">not</emphasis> end with a
								directory separator. </para>
						</listitem>
						<listitem>
							<para>DirPath—directory name, optionally preceded by the path to the
								directory. Must end with a directory separator. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by $status and $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> </entry>
									<entry> Successful</entry>
								</row>
								<row>
									<entry> -13</entry>
									<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
									<entry> An error occurred while trying to perform the OS
										command. Set /pri=64 to display the exact error in the
										message frame.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfilemove statement moves the specified file FilePath to the target
						location, ignoring any file redirections in the assignment file. You can
						simply move the file by specifying DirPath or move and rename the file by
						specifying NewFilePath. The file to be moved can be located within a ZIP
						archive and moved to a different directory in the same archive, to a
						different ZIP archive, or to a local directory.</para>
					<para>To rename a file without moving it, use lfilerename.</para>
				</sect2>
				<sect2>
					<title>Specifying Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The lfilemove operation fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-deletion (after move) due to insufficient
								authorization level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the directory part of DirPath or
						NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Does not permit user-writing due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the file NewFilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Moving From and To Zip Files and Across Platforms</title>
					<para>If the the specified file FilePath is located in a ZIP archive, it can be
						moved to different directory in the same archive, to another ZIP archive, or
						to a directory on the file system.</para>
					<para>When moving files to or from zip archives, or across operating systems or
						media, Uniface handles text files differently than binary files. It copies
						binary files as-is, but it automatically adjusts text file attributes so
						that EOL characters and optional character set conversions match the
						platform. This may result in changes in the file size, making it appear that
						source and target files are not the same. </para>
					<para>You can define the files to be treated as text files, or switch off
						automatic cross-platform text file handling using the $TEXT_FILE_EXTENSIONS
						assignment setting.</para>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On the iSeries, the particular ‘move’ command that is used depends on the
						following circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>When both the source and the destination use the IFS prefix, or
								when both do <emphasis role="italic">not</emphasis> use the IFS
								prefix, the MOVE command is used </para>
						</listitem>
						<listitem>
							<para>When the source has the IFS prefix, but the destination does not,
								then CPYFRMSTMF is used. If the copy finishes successfully, the
								source file is deleted; if the delete fails (for example, due to
								lack of authorization), the copy is undone, and $procerror -13 is
								returned. The file (indicated by its extension), into which the
								member is to be moved, must already exist; lfilemove does not
								implicitly create files. </para>
						</listitem>
						<listitem>
							<para>When the destination has the IFS prefix, but the source does not,
								then CPYTOSTMF is used. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Moving a File to Another Directory</title>
					<para>The following example moves the file <emphasis role="bold"
							>test.txt</emphasis>, from the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory, to the directory <emphasis
							role="bold">sub2dir</emphasis> in <emphasis role="bold"
							>sub1dir</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[lfilemove "sub1dir\test.txt", "sub1dir\sub2dir\"
]]></programlisting>
					<para>or</para>
					<programlisting role="uniface"><![CDATA[lfilemove "[.sub1dir]test.txt", "[.sub1dir.sub2dir]"
]]></programlisting>
					<para>Note that it is the presence of the directory separator at the end of the
						second argument that determines that this is only a move to another
						directory, <emphasis role="italic">not</emphasis> a move combined with a
						file rename.</para>
				</sect2>
				<sect2>
					<title>Example: Moving and Renaming a File </title>
					<para>The following example moves the file <emphasis role="bold"
							>test1.txt</emphasis> from the current directory to the directory
							<emphasis role="bold">sub2dir</emphasis>, renaming the file to <emphasis
							role="bold">text.txt</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[lfilemove ".\test1.txt", ".\sub2dir\text.txt"
]]></programlisting>
					<para>Note that it is the absence of a directory separator at the end of the
						second argument that determines that this is a move to another directory,
							<emphasis role="italic">combined</emphasis> with a file rename.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lfilerename">
				<title>lfilerename</title>
				<para> Introduced since: U8. </para>
				<para>Rename the specified file within the same directory, ignoring any file
					redirections in the assignment file. </para>
				<sect2>
					<title>Syntax</title>
					<para>lfilerename FilePath , NewFileName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>FilePath—file name, optionally preceded by the path to the
									file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
							<listitem>
								<para>NewFilePath—new file name, optionally preceded by the path to
									the file. Must <emphasis role="italic">not</emphasis> end with a
									directory separator. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by $status and $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> </entry>
										<entry> Successful</entry>
									</row>
									<row>
										<entry> -13</entry>
										<entry> &lt;UIOSERR_OS_COMMAND&gt;</entry>
										<entry> An error occurred while trying to perform the OS
											command. Set /pri=64 to display the exact error in the
											message frame.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lfilerename statement renames FilePath to NewFileName within the same
						directory, ignoring any file redirections in the assignment file. The file
						can be renamed in a ZIP archive.</para>
				</sect2>
				<sect2>
					<title>Specifying File Named</title>
					<itemizedlist>
						<listitem>
							<para>Each specification can be a string, a field (or indirect reference
								to a field), a variable, or a function that evaluates to a string.
							</para>
						</listitem>
						<listitem>
							<para>The total length of any path (or file name or directory name) must
								not exceed 255 bytes. </para>
						</listitem>
						<listitem>
							<para>Valid generic directory separators are the backward slash (\), the
								forward slash (/) , and the period (.) in combination with square
								brackets ([a.b]). These are translated to the platform-specific
								separators. </para>
						</listitem>
						<listitem>
							<para>No wildcards are allowed in any path, except for $ldirlist and
								$dirlist, which allows the Uniface wildcards <emphasis
									role="underline">?</emphasis> (GOLD ?) and <emphasis
									role="underline">*</emphasis> (GOLD *) in the directory name,
								for example ab<emphasis role="underline">?</emphasis> , or in its
								suffix, for example abc\<emphasis role="underline">*</emphasis>.txt.
							</para>
						</listitem>
						<listitem>
							<para>The semicolon (;) is interpreted as a file version separator
									<emphasis role="italic">only</emphasis> on VMS and z/OS; it is
								removed for other platforms. If Uniface encounters any other
								character in a path name, it stops interpretation and passes the
								string as is. </para>
						</listitem>
						<listitem>
							<para>File redirections in assignment files are <emphasis role="italic"
									>not</emphasis> considered when locating file paths. </para>
						</listitem>
					</itemizedlist>
					<para>For more information, see Syntax of File and Directory Names.</para>
				</sect2>
				<sect2>
					<title>Operation Failure</title>
					<para>The operation lfilerename fails if FilePath:</para>
					<itemizedlist>
						<listitem>
							<para>Is not a file </para>
						</listitem>
						<listitem>
							<para>Does not exist </para>
						</listitem>
						<listitem>
							<para>Is in use (locked) </para>
						</listitem>
						<listitem>
							<para>Does not permit user-renaming due to insufficient authorization
								level </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
					<para>The operation also fails if the file NewFileName:</para>
					<itemizedlist>
						<listitem>
							<para>Already exists </para>
						</listitem>
						<listitem>
							<para>Has invalid syntax </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>iSeries</title>
					<para>On the iSeries, when you attempt to rename a file (that does not reside in
						the IFS) such that its extension is changed, this implies a move of a member
						to a different file. For example, the command lfilerename lib/aaa.ext1,
						bbb.ext2 will move member <emphasis role="bold">aaa</emphasis> from file
							<emphasis role="bold">ext1</emphasis> to file <emphasis role="bold"
							>ext2</emphasis> and rename the member to <emphasis role="bold"
							>bbb</emphasis>. This works only if file <emphasis role="bold"
							>ext2</emphasis> already exists and the process has appropriate access
						rights, because the statement lfilerename does not implicitly create
						files.</para>
				</sect2>
				<sect2>
					<title>Example: Renaming a File in the Same Directory</title>
					<para>The following example renames the file <emphasis role="bold"
							>test.txt</emphasis> in the directory <emphasis role="bold"
							>sub1dir</emphasis> in the current directory to <emphasis role="bold"
							>tested.txt</emphasis>:</para>
					<programlisting role="uniface"><![CDATA[lfilerename "sub1dir/test.txt", "tested.txt"]]></programlisting>
					<para>or (VMS-specific):</para>
					<programlisting role="uniface"><![CDATA[lfilerename "[.sub1dir]test.txt", "tested.txt"]]></programlisting>
					<para>or:</para>
					<programlisting role="uniface"><![CDATA[lfilerename "[.sub1dir]test.txt;5", "tested.txt"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lflush">
				<title>lflush</title>
				<para> Introduced in: U9 </para>
				<para>Complete a file management transaction for the specified open zip archive,
					then close the file, ignoring any file redirections in the assignment
					file.</para>
				<sect2>
					<title>Syntax</title>
					<para>lflush " ZipArchive :" </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>ZipArchive—Zip archive name, optionally preceded by the path to the file. </para>
					<para>See Syntax of File and Directory Names. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When accessing files and directories located in zip archives, Uniface
						keeps the zip archives open to avoid the performance problems entailed by
						repeatedly opening and closing files. The lflush Proc statement explicitly
						completes an open transaction for a specified zip archive and closes the
						file.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example writes data to the <emphasis role="bold"
							>def.txt</emphasis> file located in the <emphasis role="bold"
							>dir1</emphasis> directory within the <emphasis role="bold"
							>b5.zip</emphasis> archive, then saves and close the file using lflush. </para>
					<programlisting role="uniface"><![CDATA[lfiledump "abc", "C:\Compuware\Uniface\project\b5.zip:dir1\def.txt"
lflush "C:\Compuware\Uniface\project\b5.zip:" ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lock">
				<title>lock</title>
				<para>Lock the current occurrence in the database. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$lock</command>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by lock in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Occurrence cannot be modified (for example, during a
										run/query). </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> There is no active occurrence, or no entities are
										painted on the component. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> Occurrence not found: table is empty. Occurrence removed
										since last retrieve. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> The hit for the occurrence does not exist. </entry>
								</row>
								<row>
									<entry> -5 </entry>
									<entry> There is no hit for the occurrence or the occurrence is
										read-only (cannot be locked). </entry>
								</row>
								<row>
									<entry> -10 </entry>
									<entry> Occurrence has been modified or removed since it was
										retrieved; the occurrence should be reloaded. </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							lock</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1 </entry>
									<entry> &lt;UGENERR_ERROR&gt; </entry>
									<entry> An error occurred. For example, there is no active
										occurrence, or no entities are painted on the component.
									</entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> &lt;UIOSERR_OCC_NOT_FOUND&gt; </entry>
									<entry> Occurrence or record not found; the table is empty or
										end of file was encountered. Occurrence removed since last
										retrieve. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Other DBMS driver error codes can be returned in certain circumstances;
						refer to the appropriate connector documentation for information about your
						DBMS. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lock statement locks the database occurrence of the current
						occurrence. If the DBMS does not support database locking or if it uses
						optimistic locking, the statement is ignored. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses lock to lock a record, then uses the reload
						statement if the record has been modified: </para>
					<programlisting role="uniface"><![CDATA[;trigger: Lock lock
if ($status = -10)
   reload
endif
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lookup">
				<title>lookup</title>
				<para>Count the number of occurrences that match the current profile. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$lookup</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by lookup in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;=0 </entry>
									<entry> Number of hits that match the profile. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> Record not found: end of file encountered. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> Occurrence not found: table is empty. (The table or file
										has no occurrences.) </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> Open request for table or file failed. The table or file
										is not painted, or it does not exist. </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> Uniface network error. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							lookup</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lookup statement checks the database for an occurrence of the current
						entity with the primary key values of the current occurrence. If the
						complete primary key is not available, all field values are used. The number
						of hits that match this profile is returned in $status. No data is
						transported and the Read trigger is not activated. If you want to find the
						total number of occurrences in the database of an entity, use clear before
						you use lookup. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> A retrieve/o may be faster than a
						lookup statement, and it also checks data in the component.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the lookup statement to check if a record with
						the number entered by the user already exists. The example assumes that
						INVOICE_NUMBER is a primary key. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Field
; field : INVOICE_NUMBER
; if another record already has this number
; prevent user from leaving field
lookup
if ($status &gt; 0)
   message "No! This number has been used before!"
   return (-1)
else
   message "I/O error %%$status"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.lowercase">
				<title>lowercase</title>
				<para>Convert a string to lowercase. </para>
				<sect2>
					<title>Syntax</title>
					<para>lowercase Source , Target </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Source—content to convert to lowercase; can be a string, or a
									field (or indirect reference to a field), a variable, or a
									function that evaluates to a string. </para>
							</listitem>
							<listitem>
								<para>Target—destination of converted content; can be a field or
									variable that can accept a string value. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The lowercase statement converts the contents of Source to lowercase, then
						places the result in Target. </para>
					<para>Conversion is on a character-by-character basis as defined by
						Unicode.</para>
					<para><emphasis role="bold"> Note:</emphasis> Locale-based processing rules are
						not applies when using lowecase. If this is desired, use $lowercase.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example converts the contents of $1 to lowercase: </para>
					<programlisting role="uniface"><![CDATA[vString1 = "ABC"
lowercase vString1, vString2
; result: vString2 = "abc"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.macro">
				<title>macro</title>
				<para>Place structure editor input in the event input queue. </para>
				<sect2>
					<title>Syntax</title>
					<para>macro{/exit} String </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/exit—queues the structure editor functions for the current form and
						returns control to the previous form. This switch cannot be used to execute
						the structure editor functions and return control when the functions are
						complete. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>String—text to be placed in the event input queue; it can be a string, or
						a field (or indirect reference to a field), a variable, or a function that
						evaluates to a string. If a character code or mnemonic is used, it should be
						preceded by a caret (^). </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>$status is set to 9 after macro ^QUIT and to 10 after macro
						^ACCEPT.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The macro statement places the structure editor functions indicated by the
						codes in String into the event input queue. The functions are executed when
						the structure editor is activated. The macro statement is used primarily in
						menu mode. </para>
					<para>The character codes and mnemonics that can be used with the macro
						statement are listed in the table:</para>
					<table>
						<title>Table 1. Structure Editor Functions</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry/>
									<entry> Numeric value </entry>
									<entry> Level </entry>
									<entry> Associated trigger </entry>
									<entry> Purpose </entry>
									<entry> Action</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> ^ACCEPT </entry>
									<entry> ^127^009 </entry>
									<entry> Component </entry>
									<entry> ACPT </entry>
									<entry> Session control </entry>
									<entry> Activate Accept trigger; intended to end edit session
										for current form on a positive note. (See also ^QUIT.)
									</entry>
								</row>
								<row>
									<entry> ^ADD_OCC </entry>
									<entry> ^127^044 </entry>
									<entry> Entity </entry>
									<entry> AIO </entry>
									<entry> Data entry </entry>
									<entry> Append a new occurrence after the current one, that is,
										at position $curocc+1. </entry>
								</row>
								<row>
									<entry> ^ATTRIBUTE </entry>
									<entry> ^127^078 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Toggle the presence of the session panel and toolbar
										(for character attributes), if defined. </entry>
								</row>
								<row>
									<entry> ^BEGIN_LINE </entry>
									<entry> ^127^188 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor to the beginning of the line. </entry>
								</row>
								<row>
									<entry> ^BOLD </entry>
									<entry> ^127^147 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Toggle bold character attribute. </entry>
								</row>
								<row>
									<entry> ^BOTTOM </entry>
									<entry> ^127^023 </entry>
									<entry> Component </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor to the window bottom. </entry>
								</row>
								<row>
									<entry> ^BOT_OF_FORM </entry>
									<entry> ^127^021 </entry>
									<entry> Component </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor to the form bottom. Only in character
										mode. </entry>
								</row>
								<row>
									<entry> ^CHAR </entry>
									<entry> ^255^001 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation or text editing </entry>
									<entry> Move cursor as ^NEXT_CHAR or ^PREV_CHAR (depending on
										direction mode), or apply a composite function like REMOVE
										to a character. </entry>
								</row>
								<row>
									<entry> ^CLEAR </entry>
									<entry> ^127^012 </entry>
									<entry> Component </entry>
									<entry> CLR </entry>
									<entry> Data entry </entry>
									<entry> Activate Clear trigger (intended to clear all data from
										the form and hitlist without saving, or release primary key
										controls). </entry>
								</row>
								<row>
									<entry> ^COMPOSE </entry>
									<entry> ^127^088 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Activate the compose character facility</entry>
								</row>
								<row>
									<entry> ^CURSOR_DOWN </entry>
									<entry> ^127^017 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor down one line. </entry>
								</row>
								<row>
									<entry> ^CURSOR_FAST_DOWN </entry>
									<entry> ^127^026 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor eight lines down. </entry>
								</row>
								<row>
									<entry> ^CURSOR_FAST_LEFT </entry>
									<entry> ^127^027 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor eight spaces left. </entry>
								</row>
								<row>
									<entry> ^CURSOR_FAST_RIGHT </entry>
									<entry> ^127^028 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor eight spaces right. </entry>
								</row>
								<row>
									<entry> ^CURSOR_FAST_UP </entry>
									<entry> ^127^025 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor eight lines up. </entry>
								</row>
								<row>
									<entry> ^CURSOR_LEFT </entry>
									<entry> ^127^018 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor left one position. </entry>
								</row>
								<row>
									<entry> ^CURSOR_RIGHT </entry>
									<entry> ^127^019 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor right one position. </entry>
								</row>
								<row>
									<entry> ^CURSOR_UP </entry>
									<entry> ^127^016 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor up one line. </entry>
								</row>
								<row>
									<entry> ^DETAIL </entry>
									<entry> ^255^008 </entry>
									<entry> Field Entity </entry>
									<entry> DTLF DTLE </entry>
									<entry> Services </entry>
									<entry> Activate the Detail trigger for the current field or, if
										the trigger is empty, the entity. </entry>
								</row>
								<row>
									<entry> ^END_LINE </entry>
									<entry> ^127^189 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move the cursor to the end of the current line. </entry>
								</row>
								<row>
									<entry> ^ERASE </entry>
									<entry> ^127^008 </entry>
									<entry> Component </entry>
									<entry> ERAS </entry>
									<entry> Database I/O </entry>
									<entry> Delete all data currently in the component, both in the
										component and in the database. </entry>
								</row>
								<row>
									<entry> ^FIELD </entry>
									<entry> ^255^010 </entry>
									<entry> Field </entry>
									<entry> NFLD or PFLD (navigation only) </entry>
									<entry> Navigation or text editing </entry>
									<entry> Move cursor as ^NEXT_FIELD or ^PREV_FIELD (depending on
										direction mode), or apply a composite function like REMOVE
										to a field. </entry>
								</row>
								<row>
									<entry> ^FIND_TEXT </entry>
									<entry> ^127^150 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Search for previously specified string or profile. (See
										also ^PROFILE.) </entry>
								</row>
								<row>
									<entry> ^FIRST </entry>
									<entry> ^255^067 </entry>
									<entry> Field, entity </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Composite function, for use with objects like ^WORD and
										^OCCURRENCE (but not with ^FIELD). </entry>
								</row>
								<row>
									<entry> ^FIRST_OCC </entry>
									<entry> ^127^037 </entry>
									<entry> Entity </entry>
									<entry> None, but will activate OGF for first occurrence </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to first promptable field of first
										occurrence in current entity; activate OGF for that
										occurrence. </entry>
								</row>
								<row>
									<entry> ^FIRST_TEXT </entry>
									<entry> ^127^129 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of text. </entry>
								</row>
								<row>
									<entry> ^FONT </entry>
									<entry> ^127^151 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Choose Uniface character set. </entry>
								</row>
								<row>
									<entry> ^FRAME </entry>
									<entry> ^127^089 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Run Define Frame form to define a frame.</entry>
								</row>
								<row>
									<entry> ^HELP </entry>
									<entry> ^127^092 </entry>
									<entry> Field Entity </entry>
									<entry> HLPF HLPE </entry>
									<entry> Services </entry>
									<entry> Activate the Help trigger for the current field or, if
										the trigger is empty, the entity. </entry>
								</row>
								<row>
									<entry> ^HOME </entry>
									<entry> ^127^022 </entry>
									<entry> Component </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to top of form window. </entry>
								</row>
								<row>
									<entry> ^INSERT </entry>
									<entry> ^255^071 </entry>
									<entry> Field, entity </entry>
									<entry> AIO, if the object is an occurrence </entry>
									<entry> Text editing, data entry </entry>
									<entry> Insert object specified (like ^WORD) in a composite
										function. When the object is ^OCCURRENCE, same as ^INS_OCC;
										otherwise, insert contents of buffer for the object.
									</entry>
								</row>
								<row>
									<entry> ^INS_CHAR </entry>
									<entry> ^127^184 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Insert character in the ^INS_CHAR buffer. </entry>
								</row>
								<row>
									<entry> ^INS_FIELD </entry>
									<entry> ^127^181 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Insert contents of the ^INS_FIELD buffer. </entry>
								</row>
								<row>
									<entry> ^INS_FILE </entry>
									<entry> ^127^180 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Data entry </entry>
									<entry> Insert file into current field. This is the same as the
										fileload Proc statement. The upper limit for the number of
										characters that can be loaded into a field is 65536. This
										limit applies to both fileload and the structure editor
										function ^INS_FILE.</entry>
								</row>
								<row>
									<entry> ^INS_LINE </entry>
									<entry> ^127^182 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Insert the contents of the ^INS_LINE buffer. </entry>
								</row>
								<row>
									<entry> ^INS_OCC </entry>
									<entry> ^127^043 </entry>
									<entry> Entity </entry>
									<entry> AIO </entry>
									<entry> Data entry </entry>
									<entry> Insert a new occurrence before the current occurrence,
										that is, at position $curocc. </entry>
								</row>
								<row>
									<entry> ^INS_OVER </entry>
									<entry> ^127^146 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Toggle Insert/Overstrike mode for unifields. </entry>
								</row>
								<row>
									<entry> ^INS_SELECT </entry>
									<entry> ^127^195 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Insert contents of the ^INS_SELECT buffer, or, if this
										is empty, the INS_FIELD buffer. </entry>
								</row>
								<row>
									<entry> ^INS_TEXT </entry>
									<entry> ^127^177 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Insert contents of the ^INS_FIELD buffer. </entry>
								</row>
								<row>
									<entry> ^INS_WORD </entry>
									<entry> ^127^183 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Insert contents of the ^INS_WORD buffer. </entry>
								</row>
								<row>
									<entry> ^ITALIC </entry>
									<entry> ^127^148 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Toggle italic character attribute. </entry>
								</row>
								<row>
									<entry> ^KEY_HELP </entry>
									<entry> ^127^072 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Keyboard layout help. </entry>
								</row>
								<row>
									<entry> ^LAST </entry>
									<entry> ^255^068 </entry>
									<entry> Field, entity </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Composite function, used with objects like ^WORD and
										^OCCURRENCE (but not with ^FIELD). </entry>
								</row>
								<row>
									<entry> ^LAST_OCC </entry>
									<entry> ^127^038 </entry>
									<entry> Entity </entry>
									<entry> None, but will activate OGF for last occurrence </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to first promptable field of last occurrence
										in current entity, activate OGF for that occurrence.
									</entry>
								</row>
								<row>
									<entry> ^LAST_TEXT </entry>
									<entry> ^127^128 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to end of text. </entry>
								</row>
								<row>
									<entry> ^LINE </entry>
									<entry> ^255^004 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation or text editing </entry>
									<entry> Move cursor as ^NEXT_LINE or ^PREV_LINE (depending on
										direction mode), or apply a composite function like ^REMOVE
										to a line. </entry>
								</row>
								<row>
									<entry> ^MENU </entry>
									<entry> ^127^101 </entry>
									<entry> Field Entity </entry>
									<entry> MNUF MNUE </entry>
									<entry> Services </entry>
									<entry> Activate the &lt;Menu&gt; trigger for the current field
										or, if the trigger is empty, the entity. </entry>
								</row>
								<row>
									<entry> ^MESSAGE </entry>
									<entry> ^127^093 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Display the message frame. </entry>
								</row>
								<row>
									<entry> ^NEXT </entry>
									<entry> ^255^065 </entry>
									<entry> Field, entity </entry>
									<entry> - </entry>
									<entry> Mode toggle or navigation </entry>
									<entry> Set the direction mode ($direction) to Next, or, if
										specified with an object, a composite navigation function.
									</entry>
								</row>
								<row>
									<entry> ^NEXT_CHAR </entry>
									<entry> ^127^142 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to next character. </entry>
								</row>
								<row>
									<entry> ^NEXT_FIELD </entry>
									<entry> ^127^046 </entry>
									<entry> Field </entry>
									<entry> NFLD </entry>
									<entry> Navigation </entry>
									<entry> Activate the Next Field trigger for the current field,
										or, if the trigger is empty, move cursor to next promptable
										field. </entry>
								</row>
								<row>
									<entry> ^NEXT_LINE </entry>
									<entry> ^127^136 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of next line. </entry>
								</row>
								<row>
									<entry> ^NEXT_OCC </entry>
									<entry> ^127^039 </entry>
									<entry> Entity </entry>
									<entry> None, but will activate OGF for occurrence </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to first promptable field of next occurrence
										in current entity, activate OGF for that occurrence.
									</entry>
								</row>
								<row>
									<entry> ^NEXT_TEXT </entry>
									<entry> ^127^163 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of the next text section that
										is not currently visible, below. </entry>
								</row>
								<row>
									<entry> ^NEXT_WORD </entry>
									<entry> ^127^140 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of next word. </entry>
								</row>
								<row>
									<entry> ^OCCURRENCE </entry>
									<entry> ^255^011 </entry>
									<entry> Entity </entry>
									<entry> None for navigation, AIO for add or insert, RMO for
										remove </entry>
									<entry> Navigation or data entry </entry>
									<entry> Give focus to next or previous occurrence (depending on
										direction mode), or apply a composite function like ^REMOVE
										to an object. </entry>
								</row>
								<row>
									<entry> ^OCC_WINDOW </entry>
									<entry> ^255^015 </entry>
									<entry> Entity </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Scroll the displayed occurrences up (in Next mode) or
										down (in Previous mode) by as many occurrences as are
										painted on the form for that entity. </entry>
								</row>
								<row>
									<entry> ^PREV </entry>
									<entry> ^255^066 </entry>
									<entry> Field, entity </entry>
									<entry> - </entry>
									<entry> Mode toggle or navigation </entry>
									<entry> Set the direction mode ($direction) to Previous, or, if
										specified with an object, a composite navigation function.
									</entry>
								</row>
								<row>
									<entry> ^PREV_CHAR </entry>
									<entry> ^127^143 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to previous character. </entry>
								</row>
								<row>
									<entry> ^PREV_FIELD </entry>
									<entry> ^127^047 </entry>
									<entry> Field </entry>
									<entry> PFLD </entry>
									<entry> Navigation </entry>
									<entry> Activate the Previous Field trigger for the current
										field, or, if the trigger is empty, move cursor to previous
										promptable field. </entry>
								</row>
								<row>
									<entry> ^PREV_LINE </entry>
									<entry> ^127^137 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of previous line. </entry>
								</row>
								<row>
									<entry> ^PREV_OCC </entry>
									<entry> ^127^040 </entry>
									<entry> Entity </entry>
									<entry> None, but will activate OGF for occurrence </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to first promptable field of previous
										occurrence in current entity, activate the OGF trigger for
										that occurrence. </entry>
								</row>
								<row>
									<entry> ^PREV_TEXT </entry>
									<entry> ^127^162 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of the next text section that
										is not currently visible, above. </entry>
								</row>
								<row>
									<entry> ^PREV_WORD </entry>
									<entry> ^127^141 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to beginning of next word. </entry>
								</row>
								<row>
									<entry> ^PRINT </entry>
									<entry> ^127^098 </entry>
									<entry> Component </entry>
									<entry> PRNT </entry>
									<entry> Services </entry>
									<entry> Activate the Print trigger, or, if trigger is empty, run
										the Print form. </entry>
								</row>
								<row>
									<entry> ^PRINT_ATTRIBUTES </entry>
									<entry> ^127^099 </entry>
									<entry> Component </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Run the Print Job Model form. </entry>
								</row>
								<row>
									<entry> ^PROFILE </entry>
									<entry> ^127^087 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Define string or profile to search for with ^FIND_TEXT
										function. </entry>
								</row>
								<row>
									<entry> ^PULLDOWN </entry>
									<entry> ^127^086 </entry>
									<entry> Component/application </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Activate a menu bar. In character mode, activate the
										component-level menu bar, if defined, or the
										application-level menu bar; toggle between menu bars if both
										are defined. </entry>
								</row>
								<row>
									<entry> ^QUICK_ZOOM </entry>
									<entry> ^127^096 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Zoom current field to maximum zoom size in one step.
									</entry>
								</row>
								<row>
									<entry> ^QUIT </entry>
									<entry> ^127^010 </entry>
									<entry> Component </entry>
									<entry> QUIT </entry>
									<entry> Session control </entry>
									<entry> Activate Quit trigger (intended to end edit session for
										current form on a negative note, ignore modifications).
									</entry>
								</row>
								<row>
									<entry> ^REFRESH </entry>
									<entry> ^127^067 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Refresh the screen. (Character mode only.) </entry>
								</row>
								<row>
									<entry> ^REMOVE </entry>
									<entry> ^255^073 </entry>
									<entry> Field, entity </entry>
									<entry> RMO, if the object is an occurrence </entry>
									<entry> Text editing, data entry </entry>
									<entry> Remove the object specified (like ^WORD) in a composite
										function; all removed objects except for occurrences are
										written to ^INSERT buffers. </entry>
								</row>
								<row>
									<entry> ^REM_CHAR </entry>
									<entry> ^127^172 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Delete character to right of cursor and write to
										^INS_CHAR buffer. </entry>
								</row>
								<row>
									<entry> ^REM_FIELD </entry>
									<entry> ^127^166 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Remove the current selection (or the entire field if
										nothing is selected) to ^INS_FIELD and ^INS_SELECT buffers.
									</entry>
								</row>
								<row>
									<entry> ^REM_FILE </entry>
									<entry> ^127^192 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Write contents of field to a file (this is the same as
										the filedump statement). </entry>
								</row>
								<row>
									<entry> ^REM_LINE </entry>
									<entry> ^127^167 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Remove the current line (from right of cursor) to
										^INS_LINE buffer. </entry>
								</row>
								<row>
									<entry> ^REM_OCC </entry>
									<entry> ^127^045 </entry>
									<entry> Entity </entry>
									<entry> RMO </entry>
									<entry> Text editing </entry>
									<entry> Remove the current occurrence. </entry>
								</row>
								<row>
									<entry> ^REM_SELECT </entry>
									<entry> ^127^194 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Remove selected text to ^INS_SELECT and ^INS_FIELD
										buffers. </entry>
								</row>
								<row>
									<entry> ^REM_WORD </entry>
									<entry> ^127^169 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Remove current word (from right of cursor) to ^INS_WORD
										buffer. </entry>
								</row>
								<row>
									<entry> ^RESET_SELECT </entry>
									<entry> ^127^196 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Turn off Select mode. </entry>
								</row>
								<row>
									<entry> ^RETRIEVE </entry>
									<entry> ^127^005 </entry>
									<entry> Component </entry>
									<entry> RETR </entry>
									<entry> Database I/O </entry>
									<entry> Activate Retrieve trigger. </entry>
								</row>
								<row>
									<entry> ^RETRIEVE_SEQ </entry>
									<entry> ^127^003 </entry>
									<entry> Component </entry>
									<entry> RETS </entry>
									<entry> Database I/O </entry>
									<entry> Activate Retrieve Sequential trigger. </entry>
								</row>
								<row>
									<entry> ^RUB_CHAR </entry>
									<entry> ^127^173 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Backspace (delete character to left of cursor). </entry>
								</row>
								<row>
									<entry> ^RUB_SEL_CHAR </entry>
									<entry> ^127^175 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Remove selected characters (using Backspace). </entry>
								</row>
								<row>
									<entry> ^RULER </entry>
									<entry> ^127^081 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Ruler definition (run Ruler form). </entry>
								</row>
								<row>
									<entry> ^SAVE </entry>
									<entry> ^127^179 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Write selected text to ^INS_SELECT buffer. </entry>
								</row>
								<row>
									<entry> ^SELECT </entry>
									<entry> ^127^193 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Turn on Select mode. </entry>
								</row>
								<row>
									<entry> ^SQL </entry>
									<entry> ^127^097 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Run the SQL Workbench form. </entry>
								</row>
								<row>
									<entry> ^STORE </entry>
									<entry> ^127^011 </entry>
									<entry> Component </entry>
									<entry> STOR </entry>
									<entry> Database I/O </entry>
									<entry> Activate the Store trigger. </entry>
								</row>
								<row>
									<entry> ^SWITCH_KEY </entry>
									<entry> ^127^100 </entry>
									<entry> Application </entry>
									<entry> SWIT </entry>
									<entry> Services </entry>
									<entry> Activate the Switch Keyboard trigger. </entry>
								</row>
								<row>
									<entry> ^TEXT </entry>
									<entry> ^255^009 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation or text editing </entry>
									<entry> Move cursor as ^NEXT_TEXT or ^PREV_TEXT (depending on
										direction mode), or apply a composite function like ^REMOVE
										to text. </entry>
								</row>
								<row>
									<entry> ^TEXT_WINDOW </entry>
									<entry> ^255^014 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Scroll text up or down, depending on direction mode.
									</entry>
								</row>
								<row>
									<entry> ^TOP_OF_FORM </entry>
									<entry> ^127^020 </entry>
									<entry> Component </entry>
									<entry> - </entry>
									<entry> Navigation </entry>
									<entry> Move cursor to the top of the form. Character mode only.
									</entry>
								</row>
								<row>
									<entry> ^UNDERLINE </entry>
									<entry> ^127^149 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Toggle underline character attribute. </entry>
								</row>
								<row>
									<entry> ^USER_KEY </entry>
									<entry> ^127^091 </entry>
									<entry> Component Application </entry>
									<entry> UKYS UKYA </entry>
									<entry> Services </entry>
									<entry> Activate the User Key trigger for the current form, or,
										if the trigger is empty, the application. </entry>
								</row>
								<row>
									<entry> ^VIEW </entry>
									<entry> ^127^073 </entry>
									<entry> Application </entry>
									<entry> - </entry>
									<entry> Text editing </entry>
									<entry> Toggle View mode on or off. </entry>
								</row>
								<row>
									<entry> ^WORD </entry>
									<entry> ^255^003 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Navigation or text editing </entry>
									<entry> Move cursor as ^NEXT_WORD or ^PREV_WORD (depending on
										direction mode), or apply a composite function like ^REMOVE
										a word. </entry>
								</row>
								<row>
									<entry> ^ZOOM </entry>
									<entry> ^127^095 </entry>
									<entry> Field </entry>
									<entry> - </entry>
									<entry> Services </entry>
									<entry> Zoom the current field. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>
						<emphasis role="bold"> Note:</emphasis> If literal text or the contents of a
						variable or field are used in the macro statement, they may not contain
						composed characters or characters with attributes, for example, bold,
						underline, or italics. Only characters in Uniface Font 0 should be
						used.</para>
					<para>A macro statement does not execute the functions supplied as its
						arguments. Instead, it places its arguments in the event input queue. A
						macro that is triggered during execution of another macro appends its
						arguments to those of the first macro, which are already in the event input
						queue. This means that these arguments are executed after those of the first
						macro are completed. </para>
					<para>The following illustration shows a Form A with Behavior = Normal and an
						accompanying Form B with Behavior= Menu. Form B is started via the
						&lt;Menu&gt; trigger of form A. When a macro statement is executed in B, the
						structure editor makes form A active again, executes the functions specified
						by macro, then reactivates B via the &lt;Menu&gt; trigger of A. </para>
					<para>Figure 1. Normal form with Menu form<mediaobject>
							<imageobject>
								<imagedata fileref="images/fig13_3.jpg"/>
							</imageobject>
						</mediaobject>
					</para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Filling the structure editor buffer
						with the commands, rather than calling the structure editor to execute the
						commands, means that the macro statement relies on the structure editor
						being started at some point in the future. If this is not the case (for
						example, because there is a macro statement in the Quit or Accept trigger of
						the first form), you have to run another form that briefly starts the
						structure editor. </para>
					<para>The macro statement performs an implicit return 0. Consequently, any
						statements in the trigger after a macro statement are ignored. If you need
						to place statements after the macro statement, put the macro statement in an
						entry Proc module, and call this module instead of using the macro statement
						directly. </para>
				</sect2>
				<sect2>
					<title>Example: Sending Character Codes to the Structure Editor</title>
					<para>The following example sends the character codes for the ^RETRIEVE function
						to the structure editor when the user starts to enter data in the field: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Start Modification
macro "^127^005"   ; this is the code for ^RETRIEVE
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Puting the Structure Editor into Zoom Mode</title>
					<para>The following example puts the structure editor into Zoom mode and inserts
						a salutation when the user enters a capital D ($char="D" ): </para>
					<programlisting role="uniface"><![CDATA[; trigger: Start Modification
if ($char = 68)   ; "D"
   if (GENDER = "M")
      $1 = "Mr."
   else
      $1 = "Ms."
   endif
   macro "^127^096ear %%$1 %%SURNAME, ^CURSOR_RIGHT"
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying Contents of Message Frame to Time-Stamped File</title>
					<para>The following example uses the macro statement to copy the contents of the
						message frame into $selblk. The contents of $selblk are then dumped to a
						time-stamped file. The Proc code to do this is in a single form, which can
						be run at any time during the application, or once the application has
						ended. </para>
					<para>This approach ensures that the structure editor is always activated, and
						that the functions stored in the keyboard input buffer by the macro
						statement are never ignored. The form contains a single dummy field; this is
						all that is required for a successful edit session. The form uses component
						variables, so the form can be used without fear of overwriting general
						variables ($1-$99). </para>
					<programlisting role="uniface"><![CDATA[; Execute trigger
: Start structure editor
edit DUMMY_FIELD
; Occurrence Gets Focus trigger
; note the space at the end of the macro
; string. This ensures that the Start Modification
; trigger is activated
macro "^MESSAGE^SELECT^TEXT^SAVE^ACCEPT "
; Start Modification trigger (of DUMMY_FIELD)
$TIME_NOW$ = $clock
$MINUTES$ = $TIME_NOW$[n]
$SECONDS$ = $TIME_NOW$[s]
$HOURS$ = $TIME_NOW$[H]
filedump $selblk,"MF%%$HOURS$_%%$minutes$.%%$SECONDS$"
exit (1)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.message">
				<title>message</title>
				<para>Display the specified string in the message area. </para>
				<sect2>
					<title>Syntax</title>
					<para>message{/nobeep}{/error | /warning | /info} MessageText </para>
					<para>message/clear MessageText </para>
					<para>message/hint MessageText </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/nobeep—the terminal does not beep when MessageText is
									displayed. This switch has no effect in the Web environment.
								</para>
							</listitem>
							<listitem>
								<para>/info, /warning, and /error—display the message in a dialog
									box that requires confirmation. In a GUI, these switches also
									display an icon showing the indicated severity. If you specify
									several levels of severity, the most severe switch of those
									specified is used. </para>
							</listitem>
							<listitem>
								<para>/clear—clears the message area. In GUI mode, the message area
									is cleared, but the history list for the message area is not
									changed. In character mode, the 'Busy' indicator is restored, if
									necessary. </para>
							</listitem>
							<listitem>
								<para>/hint—displays a message in the message area without logging
									it in the history list of the message area and without beeping.
									It is commonly used in the Field Gets Focus trigger to display
									hint information about the field. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>MessageText—text to display; can be a string, or a field (or indirect
						reference to a field), a variable, or a function that evaluates to a string;
						maximum is 512 bytes. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>message/error, message/warning, and message/info allowed in form and
						static server page components (and in service and report components that are
						not self-contained). </para>
					<para>message, message/nobeep, message/clear, and message/hint allowed in form,
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The message statement sends MessageText to the message area. </para>
					<para>In GUI mode, the location and appearance of the message area depends on
						the GUI in use. In character mode, the message area is defined as part of
						the start-up shell definition. The message area is not the same as the
						message frame. </para>
					<para>If the message needs to be writtent to a log file, use the $putmess
						statement and set $PUTMESS_LOGFILE in the assignment file. </para>
					<para>In batch mode, all forms of the message statement write the message
						directly to the screen or to a batch log file, depending on your operating
						system settings. No user intervention is required. </para>
				</sect2>
				<sect2>
					<title>Web Environment</title>
					<para>When the switches /info, /error, or /warning are used in a Web environment
						(that is, Web deployment), the message statement raises a JavaScript alert,
						which is written to the ONLOAD attribute of the &lt;BODY&gt; tag. The type
						of alert is not shown as an icon; instead, text corresponding to the
						relevant alert level is added to the message text. For example: </para>
					<para>[info] This is my message. </para>
					<para><emphasis role="bold"> Note:</emphasis> For dynamic server pages, you can
						use the webmessage statement, which supports icons and enables you to
						control the size. </para>
					<para>In the Web environment, /hint writes the message to the client browser’s
						status line by inserting JavaScript in the ONLOAD attribute of the
						&lt;BODY&gt; tag. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example displays the status code with the message statement,
						if a store operation was unsuccessful: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Store
if ($status &lt; 0)
   message "Store error number %%$status."
   rollback
endif
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.moveocc">
				<title>moveocc</title>
				<para>Move the field values of the current occurrence to another occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>moveocc Entity , OccurrenceNumber{, FieldList} </para>
					<para>moveocc/allfields Entity , OccurrenceNumber </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/allfields—all the fields are copied. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...<itemizedlist>
							<listitem>
								<para>Entity—entity name. Can be a string, or a field, variable,
									function, or parameter that evaluates to a string containing the
									name of the entity. It can also be an indirect reference to a
									field, where the target field evaluates to a string that
									contains the name of an entity. For example, $selectlist(@$1),
									where $1 contains "FLD1" and FLD1 contains "INVOICES". </para>
								<para>If the Entity argument is omitted, the current entity is used.
								</para>
							</listitem>
							<listitem>
								<para>FieldList—a list of fields separated by a comma (,), which
									contains all fields to be moved to the specified occurrence. If
									no FieldList is provided, no fields are copied. </para>
							</listitem>
							<listitem>
								<para>OccurrenceNumber—number of the occurrence to which the current
									occurrence of the fields in the FieldList will be moved.
									OccurrenceNumber should be a constant, or a field (or indirect
									reference to a field), a variable, or a function that can be
									converted to a whole (integer) number; the value will be
									truncated to form an integer. </para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> &gt;=0</entry>
										<entry> Statement was successful. The exact number equals
											the sequence number of the new current occurrence.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values returned by $procerror following moveocc</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
									<row>
										<entry> -1203 </entry>
										<entry> &lt;UPROCERR_RANGE&gt; </entry>
										<entry> Value out of range. </entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> &lt;UPROCERR_FIELD&gt; </entry>
										<entry> An incorrect field name was provided; either the
											field name is not valid syntactically or the field is
											not available in the component. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UVALERR_KEY_*&gt; (-302, -303) </entry>
										<entry> Key incorrect. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The moveocc statement moves the fields of the current occurrence of Entity
						(whether they have been modified or not) that are specified in the FieldList
						to the target OccurrenceNumber. The target occurrence then becomes the new
						current occurrence and the old current occurrence is deleted. </para>
					<para>The Proc function $fieldmod is set to value 1 (modified) for all fields
						copied to the target occurrence. Other modification-related functions such
						as $occmod, $occdbmod, $instancemod, and $instancedbmod are set to 1
						(modified) accordingly. Validation functions such as $keyvalidation,
						$occvalidation, and $instancevalidation are also set to 1 (requires
						validation) accordingly. </para>
				</sect2>
				<sect2>
					<title>Example: Moving Field Values to Another Occurrence </title>
					<para>The following example moves the current values of the fields in the
						variable $FIELDS$ in entity, ENT, to the occurrence stated in $result. </para>
					<programlisting role="uniface"><![CDATA[; find occurrence with same key
; update occurrence
operation uupdate ENT
params
   occurrence ENT :IN
endparams
findkey ENT
moveocc ENT, $result, $fields$
end ; end occurrence]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.new_instance">
				<title>new_instance [DEPRECATED]</title>
				<warning>
					<para> The command <function>new_instance</function> was replaced by <link
							linkend="langref.newinstance">
							<function>newinstance</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated statement 'new_instance'
							used</literal>. </para>
					<para> In U8 the function <link linkend="langref.newinstance">
							<function>newinstance</function>
						</link> was introduced to replace <literal>new_instance</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.newinstance">
				<title>newinstance</title>
				<para>Creates a new instance of a component. </para>
				<para> Introduced in: U8 </para>
				<para>
					<programlisting role="uniface"><![CDATA[
entry CP_NEW_INSTANCE_IN_U7
; there is a difference in new_instance usage in U7 and U9
; the datatyoe handle didnot exist in U7
; therefore the handle was put in a string 
variables 
string v_handle 
endvariables 
new_instance "COMPONENT", v_handle
end ;CP_NEW_INSTANCE_IN_U7
operation createInstance
params
handle v_handle : out
endparams
newinstance "COMPONENT", v_handle
end ; operation createInstance
]]></programlisting>
				</para>
				<sect2>
					<title>Syntax</title>
					<para>newinstance{/sync | /async}{ /attached} ComponentName , Handle |
						InstanceName {, InstProperties} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/async and /sync—specify the communications mode for the
									operation; that is, the operation communicates either
									synchronously or asynchronously. <emphasis role="bold">
										Note:</emphasis> Both of these switches are ignored if you
									specify Handle, which is, by definition, a pointer to a
									synchronous instance. </para>
							</listitem>
							<listitem>
								<para>/attached—attaches the new instance to the current component
									instance, that is, it becomes a child of the current (displayed)
									instance. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>ComponentName—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string
									containing the component name. </para>
								<para>If ComponentName is a 4GL component, the string has a maximum
									length of 16 bytes. Otherwise, the string has a maximum length
									of 32 bytes. </para>
							</listitem>
							<listitem>
								<para>Handle—an empty variable of type handle. Uniface generates a
									handle to the instance that is unique within the application and
									stores it in that variable. </para>
							</listitem>
							<listitem>
								<para>InstanceName—string, or field (or indirect reference to a
									field), variable, or function that evaluates to a string contain
									the instance name. The string has a maximum length of 32 bytes;
									trailing blanks are removed. <emphasis role="bold">
										Note:</emphasis> The use of instance names for managing
									instances is discouraged. You are advised to use handles
									instead. </para>
							</listitem>
							<listitem>
								<para>InstanceProperties—string, or field (or indirect reference to
									a field), variable, or function that evaluates to a string that
									contains an associative list defining the properties for this
									instance. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0</entry>
										<entry> Component instance was successfully created.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								newinstance </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -50 </entry>
										<entry> &lt;UACTERR_NO_SIGNATURE&gt; </entry>
										<entry> Signature descriptor for the current component not
											found (in ULANA.DICT, USYSANA.DICT, URR file, or
											resource file). For example, the component name provided
											is not valid. </entry>
									</row>
									<row>
										<entry> -51 </entry>
										<entry> &lt;UACTERR_SIGNATURE_ID&gt; </entry>
										<entry> The identifier of the compiled component does not
											match the identifier in the signature descriptor (in
											ULANA.DICT, USYSANA.DICT, URR file, or resource file).
										</entry>
									</row>
									<row>
										<entry> -58 </entry>
										<entry> &lt;UACTERR_NO_COMPONENT&gt; </entry>
										<entry> The named component cannot be found. </entry>
									</row>
									<row>
										<entry> -154</entry>
										<entry> &lt;UACTERR_INSTANCE_NAME_EXISTS&gt;</entry>
										<entry><para>An instance with this name already exists. This
												error code is returned, for example, in the
												following cases: </para>
											<itemizedlist>
												<listitem>
												<para>When a modal form which is already active is
												activated again </para>
												</listitem>
												<listitem>
												<para>When an attempt is made to activate a modal
												form from a non-modal form </para>
												</listitem>
											</itemizedlist></entry>
									</row>
									<row>
										<entry> -155 </entry>
										<entry> &lt;UACTERR_CREATE_INSTANCE&gt; </entry>
										<entry> An error occurred while creating an instance: An
											unknown property occurs in the instance properties. A
											property in the instance properties has a value that is
											not valid. The component could not be loaded. An exit
											statement was executed in the operation INIT. </entry>
									</row>
									<row>
										<entry> -166 </entry>
										<entry> &lt;UACTERR_STATELESS&gt; </entry>
										<entry> Component instance could not be created by the
											newinstance statement because the component is
											stateless. </entry>
									</row>
									<row>
										<entry> -1105 </entry>
										<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
										<entry> The instance name provided is not valid. for
											example, the argument contains incorrect characters.
										</entry>
									</row>
									<row>
										<entry> -1106 </entry>
										<entry> &lt;UPROCERR_COMPONENT&gt; </entry>
										<entry> The component name provided is not valid; for
											example, the argument contains an empty string ("").
										</entry>
									</row>
									<row>
										<entry> -1110 </entry>
										<entry> &lt;UPROCERR_TOPIC&gt; </entry>
										<entry> Topic name not known. </entry>
									</row>
									<row>
										<entry> -1410 </entry>
										<entry> &lt;UPROCERR_PROPERTY_VALUE&gt; </entry>
										<entry> A property has been assigned an incorrect value.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The newinstance statement creates an instance of the component identified
						by ComponentName. The identifier of the new instance is returned as a handle
						and all communication with the instance is done via the handle. The
						reference count of the handle is 1 after the newinstance statement is
						complete. The compiled component is loaded and added to the component pool.
						Control then returns to the component that issued the newinstance statement. </para>
					<para>By default, an instance is created as a synchronous process. </para>
					<para>Before creating the new instance, Uniface locates a signature descriptor
						for ComponentName (in a resource file, URR file, or in the descriptor
						information of the Repository). This information is used to create the new
						instance. </para>
					<para>For Uniface (4GL) components, the signature and signature descriptor are
						created (and updated) automatically whenever the component is compiled. For
						other types of component, such as 3GL components, you must use the Signature
						Editor to create the signature and the compiled descriptor. </para>
					<para>A component instance remains in the component pool until one of the
						following situations occurs: </para>
					<itemizedlist>
						<listitem>
							<para>The instance executes an exit statement. </para>
						</listitem>
						<listitem>
							<para>The ACCEPT or QUIT operation of an instance returns a nonnegative
								value. </para>
						</listitem>
						<listitem>
							<para>A deleteinstance statement naming the instance is executed.
							</para>
						</listitem>
						<listitem>
							<para>For an instance created using a handle, there is no longer a
								handle that refers to the instance. </para>
						</listitem>
					</itemizedlist>
					<para>Before an instance is removed, if it contains an operation named CLEANUP,
						that operation is executed. </para>
					<para>Using newinstance allows you to start several instances of the same
						component, each known by its own instance name. If, for example, the
						component is a service or report, assignments in the [SERVICES_EXEC] or
						[REPORTS_EXEC] section of the assignment file determine if the instance is
						created on the client or server machine. (Instances of form components are
						always created on the client machine.) </para>
				</sect2>
				<sect2>
					<title>Using Handles</title>
					<para>If the following Proc code is used to create a new instance of the
						component MYCOMPONENT, Uniface returns a unique identifier in myHandle: </para>
					<programlisting role="uniface"><![CDATA[variables
   handle myHandle
endvariables
newinstance "MYCOMPONENT", myHandle
]]></programlisting>
					<para>This identifier can be used to activate operations of the component
						instance. For example: </para>
					<programlisting role="uniface"><![CDATA[myHandle-&gt;myOperation(myParam)
]]></programlisting>
					<para>If the argument that is specified in the position of Handle or
						InstanceName is an empty generic variable, by default, Uniface returns a
						handle in that generic variable. For example, if the following Proc code is
						used to create a new instance of the component MYCOMPONENT, Uniface returns
						a unique identifier in $1 of type handle:</para>
					<programlisting role="uniface"><![CDATA[$1 = ""
newinstance "MYCOMPONENT", $1
]]></programlisting>
					<para>This identifier can be used to activate operations of the component
						instance. For example: </para>
					<programlisting role="uniface"><![CDATA[$1-&gt;myOperation(myParam)
]]></programlisting>
					<para>When the identification of a component instance that is created in a
						Uniface server has to be returned to a client application, a handle must be
						used: </para>
					<para>On the server: </para>
					<programlisting role="uniface"><![CDATA[operation createInstance
params
   handle myHandle : OUT
endparams
newinstance "COMPONENT", myHandle
end ; operation createInstance
]]></programlisting>
					<para>And on the client: </para>
					<programlisting role="uniface"><![CDATA[variables
   handle myHandle
endvariables
; Suppose that $handleToServerInstance$ is a handle to an instance living in a Uniface server.
; The createInstance operation creates a new instance on the server side.
$handleToServerInstance$-&gt;createInstance(myHandle)
; Do something with the instance
myHandle-&gt;someOperation(17);
; When finished remove the reference to the instance
myHandle = 0;
]]></programlisting>
				</sect2>
				<sect2>
					<title>Using Instance Names</title>
					<para>If you specify an instance name, it can contain letters (A-Z), digits
						(0-9), and underscores (_); the first character must be a letter. If a
						variable or field containing an empty string ("") appears, Uniface generates
						a name for the instance that is unique within the application and stores it
						in that variable or field. For example, if the following Proc code is used
						to create a new instance of the component MYCOMPONENT, Uniface returns a
						unique identifier in myInstanceName: </para>
					<programlisting role="uniface"><![CDATA[variables
   string myInstanceName
endvariables
newinstance "MYCOMPONENT", myInstanceName
]]></programlisting>
					<para>This identifier can be used to activate operations of component instance.
						For example: </para>
					<programlisting role="uniface"><![CDATA[activate myInstanceName.myOperation(myParam)
]]></programlisting>
					<para>The instance name of an instance is valid only within the context where it
						is created. This means that it is not guaranteed that when an instance name
						is used in another context, the correct instance will be addressed. When
						instance identifications need to be transferred between contexts, handles
						have to be used. Contexts can include:</para>
					<itemizedlist>
						<listitem>
							<para>All Uniface components in a client process. </para>
						</listitem>
						<listitem>
							<para>All Uniface components in one server. </para>
						</listitem>
						<listitem>
							<para>All component instances created with the C Call-in API. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Component Instance Properties</title>
					<para>Most instance properties are meaningful only for form components; they are
						ignored for other component types. Many of the properties that can be
						defined correspond to the switches and arguments available on the run
						statement. The available properties are:</para>
					<table>
						<title>Table 3. Properties for the InstanceProperties argument of
							newinstance</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Property </entry>
									<entry> Form only? </entry>
									<entry> Possible values </entry>
									<entry> Default value, if omitted </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Display </entry>
									<entry> Y </entry>
									<entry> TRUE, FALSE </entry>
									<entry> FALSE </entry>
								</row>
								<row>
									<entry> Dimension </entry>
									<entry> Y </entry>
									<entry> HorizPos, VertPos, HorizSize, VertSize </entry>
									<entry> 0, 0, 0, 0 </entry>
								</row>
								<row>
									<entry> Query </entry>
									<entry> Y </entry>
									<entry> TRUE, FALSE </entry>
									<entry> FALSE </entry>
								</row>
								<row>
									<entry> Modality </entry>
									<entry> Y </entry>
									<entry> MODAL, NON-MODAL </entry>
									<entry> Determined by the component window property Modality
										&amp; Attachment </entry>
								</row>
								<row>
									<entry> Transaction </entry>
									<entry> N </entry>
									<entry> TRUE, FALSE </entry>
									<entry> FALSE </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>For example, you can activate a component with parallel transaction
						processing by using the transaction=true property. When the end-user enters
						an order and finds that the customer needs to be added to the customer
						database, the Customer form can be used to enter and store customer details,
						after which work can continue in the Order form. Two transactions are now
						taking place in parallel and they can be separately committed or rolled
						back. </para>
				</sect2>
				<sect2>
					<title>Communication Modes</title>
					<para>When the first instance of a component is created, the communications mode
						for that component is determined; that is, the new instance and all further
						instances of the same component run either synchronously or asynchronously.
						The communication mode affects the execution as follows: </para>
					<itemizedlist>
						<listitem>
							<para>If the new instance runs synchronously, each time an operation of
								the instance is activated, the component that requests the operation
								waits until the operation completes before proceeding. </para>
						</listitem>
						<listitem>
							<para>If the new instance runs asynchronously, the component that
								requests an operation does not wait for the operation to complete;
								it simply proceeds with its next Proc statement. </para>
						</listitem>
					</itemizedlist>
					<para>By default, an instance is created as a synchronous process. This
						information is included in the component descriptor. </para>
					<para>You can override the information in the component descriptor by using
						either the /sync or /async switch in the newinstance statement. Note that if
						this switch is used on the activate statement, it gets precedence over the
						switch on the newinstance statement and the component property as specified
						in the Signature Editor. If neither are present, the information in the
						component descriptor is considered. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> All form components run
						synchronously. The /sync and /async switches, and the definition on the More
						Properties form of the Define Component Properties form, are ignored for
						form components. </para>
				</sect2>
				<sect2>
					<title>Attached Instances</title>
					<para>The new instance is attached to the current instance in the following
						circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>The window property Modality &amp; Attachment for ComponentName is
								set to Modal, Attached or Non-Modal, Attached. </para>
						</listitem>
						<listitem>
							<para>The window property Modality &amp; Attachment is set to Non-Modal,
								Attached. The new instance can be viewed as a child of the
								application shell. In this case, the new, detached instance remains
								active until it exits itself or until the application exits. </para>
						</listitem>
						<listitem>
							<para>The /attached switch is used to create a child instance. </para>
						</listitem>
					</itemizedlist>
					<para>When /attached is used:</para>
					<itemizedlist>
						<listitem>
							<para>If the current instance exits, the child instance and all other
								child instances that still exist are removed before the current
								instance exits. </para>
						</listitem>
						<listitem>
							<para>If the current instance is iconized, the child instance and all
								other child instances that still exist are also iconized. When the
								current instance is restored, all its child instances are restored
								with it. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> The /attached switch has no meaning
						in a trigger of the start-up shell. In this case, all new instances can be
						considered as attached to the application screen.</para>
					<para>When using /attached in client/server environments, note the
						following:</para>
					<itemizedlist>
						<listitem>
							<para>Be careful when using deleteinstance on attached, remote instances
								that were created on a server, that is, with newinstance/attached.
								Although there is an implied advantage that you can use a single
								deleteinstance statement to delete many remote instances, the
								handles returned to the client become invalid. When one of these
								handle variables is assigned a new value, Uniface performs an
								implicit deleteinstance, because no other reference to the instance
								exists, which will fail with $procerror -88 (instance already
								deleted). </para>
						</listitem>
						<listitem>
							<para>A similar problem can occur when a shared server has been started
								with a /maxidle or /maxreq switch and all the instances are
								deleted—the Uniface Router may shut down the server. If an invalid
								handle to a child instance exists, Uniface performs an implicit
								deleteinstance and the Router will log error messages such as:
								<programlisting role="uniface"><![CDATA[err=-25: Problems handling request
err=-25: Server gone]]></programlisting></para>
						</listitem>
					</itemizedlist>
					<para>To avoid these problems, do not use attached instances, or delete them
						before the parent is deleted (although this incurs extra network
						traffic).</para>
				</sect2>
				<sect2>
					<title>New Instances of Stateless Components</title>
					<para>You are not allowed to create an instance of a component that is marked as
						stateless in the Signature Editor. An error is issued if you do this. For
						more information, see activate. </para>
				</sect2>
				<sect2>
					<title>INIT and CLEANUP Operations</title>
					<para>If the Operations trigger of the new component instance contains an
						operation named INIT, the operation is executed before the new instance is
						created. Since the new instance does not really exist at this point, the
						INIT operation should not perform any action that involves the new instance.
						For example, it should not use deleteinstance on the instance or activate
						for an operation contained in the instance. </para>
					<para>If the Operations trigger of the component instance contains an operation
						named CLEANUP, that operation is executed as the instance is removed (by an
						exit statement, by executing an ACCEPT operation, or a deleteinstance
						statement, and so on). Since the instance being deleted no longer exists at
						this point, the CLEANUP operation should not perform any action that
						involves its own instance. For example, it should not use deleteinstance on
						the instance or activate for an operation contained in the instance. </para>
					<para>The return values of INIT and CLEANUP have no effect on further
						processing. </para>
				</sect2>
				<sect2>
					<title>Use of Functions</title>
					<para>When referring to an instance created with newinstance, the following
						functions return the requested information for the current instance:</para>
					<itemizedlist>
						<listitem>
							<para>$componentname </para>
						</listitem>
						<listitem>
							<para>$componenttype </para>
						</listitem>
						<listitem>
							<para>$instancechildren </para>
						</listitem>
						<listitem>
							<para>$instancename </para>
						</listitem>
						<listitem>
							<para>$instanceparent </para>
						</listitem>
					</itemizedlist>
					<para>The following functions return various modification statuses associated
						with the instance:</para>
					<itemizedlist>
						<listitem>
							<para>$instancedb </para>
						</listitem>
						<listitem>
							<para>$instancedbmod </para>
						</listitem>
						<listitem>
							<para>$instancemod </para>
						</listitem>
					</itemizedlist>
					<para>When referring to a form created with run, the function $formname returns
						an empty string (""). The functions $formdb, $formdbmod, and $formmod return
						-1. These functions are meaningful only in forms started with the run
						statement. </para>
				</sect2>
				<sect2>
					<title>Example: Creating and Deleting Instances</title>
					<para>In the following example, the Application Execute trigger starts a
						sequence of non-modal forms before allowing the user to take control of the
						application. When control returns to this trigger, the Proc code removes any
						detached instances that are still in the component pool. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Application Execute
; start the initial forms
newinstance "form10",$1,"MODALITY=NON-MODAL"
newinstance "form20",$2,"MODALITY=NON-MODAL"
newinstance "form40",$3,"MODALITY=NON-MODAL"
; show them
$1-&gt;EXEC()
$2-&gt;EXEC()
$3-&gt;EXEC()
; let the user play
; control returns to me, so clean up any detached instances
getitem $1, $detachedinstances, 1
while ( $status &gt; 0 )
   deleteinstance $1
   getitem $1, $detachedinstances, 1
endwhile
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.nodebug">
				<title>nodebug</title>
				<para>Stop the character mode debugger, or, in the case of the interactive Debugger,
					return focus to the application. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$nodebug</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The nodebug statement turns off the character mode debugger. If you only
						want to activate the debugger for a specific trigger, start the trigger with
						a debug statement and terminate the trigger with nodebug. </para>
					<para>The nop debugger instruction has no effect on the nodebug statement. The
						dump and xtrace Proc debugger instructions stop their processing when they
						encounter a nodebug statement. </para>
					<para>In the case of the interactive Debugger, the nodebug statement returns
						focus to the application. </para>
				</sect2>
				<sect2>
					<title>Example: Enabling and Disabling Debugging </title>
					<para>The following example enables debugging and starts an editing session,
						then, when the edit session is completed, exits debug mode: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
; enter debug mode
; start editing session
; cancel debug mode when form is exited
debug
edit
nodebug ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.numgen">
				<title>numgen</title>
				<para>Increment the value of the specified counter. </para>
				<sect2>
					<title>Syntax</title>
					<para> numgen CounterName , Increment{, LibName} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Counter—string that contains the name of a counter in LibName, or
								a field (or indirect reference to a field), a variable, or a
								function that evaluates to a string. </para>
						</listitem>
						<listitem>
							<para>Increment—constant, field, or variable that evaluates to an
								integer value from -2,147,483,648 through 2,147,483,647. </para>
						</listitem>
						<listitem>
							<para>LibName—string containing the name of the library to which
								CounterName belongs, or a field (or indirect reference to a field),
								a variable, or a function that evaluates to a string. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by numgen in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Counter was successfully incremented; $result
											contains the new number. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> The value of the counter went out of range,
											CounterName not defined, or Uniface was unable to access
											UOBJ.TEXT. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> Increment was out of range. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								numgen</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1108 </entry>
										<entry> &lt;UPROCERR_COUNTER&gt; </entry>
										<entry> Uniface was unable to access UOBJ.TEXT or the
											counter is not defined. </entry>
									</row>
									<row>
										<entry> -1203 </entry>
										<entry> &lt;UPROCERR_RANGE&gt; </entry>
										<entry> Value out of range. The value of the increment or
											the generated counter is incorrect.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The numgen statement generates a unique number for a counter. This
						statement finds the current value of Counter, increases it by Increment, and
						returns the resulting value in $result. </para>
					<para>Both the argument Increment and the value generated for CounterName must
						be in the range -2,147,483,648 through 2,147,483,647, inclusive (that is, -2
						31 through 2 31 -1). </para>
					<para>If LibName is omitted, the library SYSTEM_LIBRARY is used. Libraries allow
						different projects to maintain their own set of counters. (The current
						library is available in $variation.) </para>
				</sect2>
				<sect2>
					<title>Using Counters</title>
					<para>Counters are global objects stored in UOBJ.TEXT, which is accessed via the
						path $UUU. Since several users can update a counter at the same time,
						locking problems can easily occur with UOBJ.TEXT occurrences if users wait a
						long time between store actions. </para>
					<para>To avoid locking problems, it is a good idea to follow a numgen (or
						numset) statement with a commit "$UUU" statement, if your DBMS supports this
						feature. If your DBMS does not support commit and rollback actions, the new
						number is stored immediately. </para>
					<para>(For consistency reasons, Uniface does not automatically commit your
						counter. If there is a store error and the new number has not yet been
						committed, that number is available for reuse after the rollback, which
						would not be possible if you had immediately committed $UUU.) </para>
				</sect2>
				<sect2>
					<title>Example: Generate Unique Sequence Numbers</title>
					<para>The following example uses the numgen statement to generate unique
						sequence numbers for a record: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
numgen "INVOICE_NUMBER", 1, "COUNTER_LIB"
if ($status &lt; 0)
   message "Error generating sequence number."
   rollback "$UUU"
   edit SEQNO
   done
else
   SEQNO = $result
   commit "$UUU"
   edit NAME
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Generate an Invoice Number </title>
					<para>The following example generates a new invoice number using numgen in the
						Add/Insert Occurrence trigger. Placing the code in this trigger can result
						in the sequence numbers being lost if the user does not store the data. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Add/Insert Occurrence
; Add occurrence
; Insert occurrence
; generate new invoice number
; set new invoice number
if ($rettype = 65)
   creocc "INVOICE", $curocc + 1
else
   creocc "INVOICE", $curocc
endif
numgen "INV_COUNT", 1, $variation
INV_NUM/init = $result
commit "$UUU"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.numset">
				<title>numset</title>
				<para>Initialize the value of the specified counter. </para>
				<sect2>
					<title>Syntax</title>
					<para>numset CounterName , InitialValue{, LibName} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>CounterName—string containing the name of a counter in LibName, or
								a field (or indirect reference to a field), a variable, or a
								function that evaluates to a string. </para>
						</listitem>
						<listitem>
							<para>InitialValue—constant, field, or variable that evaluates to an
								integer value. The integer must be in the range -2,147,483,648
								through 2,147,483,647, inclusive (that is, -2 31 through 2 31 -1).
							</para>
						</listitem>
						<listitem>
							<para>LibName—string containing the name of the library to which
								CounterName belongs, or a field (or indirect reference to a field),
								a variable, or a function that evaluates to a string. If LibName is
								omitted, the library SYSTEM_LIBRARY is used. Libraries allow
								different projects to maintain their own set of counters. (The
								current library is available in $variation.) </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by numset in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> CounterName was successfully initialized. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> InitialValue was out of range, CounterName not defined,
										or Uniface was unable to access UOBJ.TEXT. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							numset</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -1108 </entry>
									<entry> &lt;UPROCERR_COUNTER&gt; </entry>
									<entry> Uniface was unable to access UOBJ.TEXT or the counter is
										not defined. </entry>
								</row>
								<row>
									<entry> -1203 </entry>
									<entry> &lt;UPROCERR_RANGE&gt; </entry>
									<entry> Value out of range. The value of the counter or the
										initial value is incorrect. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained).</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The numset statement initializes CounterName to the value InitialValue.
						The statement can be used to initialize counters that are used by the numgen
						statement. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Before using the numset instruction,
						be sure to read the <emphasis role="italic">Using counters
						</emphasis>section in the description of numgen. </para>
				</sect2>
				<sect2>
					<title>Example: Resetting a Counter</title>
					<para>The following example resets the counter NUMBERCOUNTER in the library
						SALES_LIBRARY to 0: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
numset "NUMBERCOUNTER", 0,"SALES_LIBRARY"
commit "$UUU"
message "Counter %%NUMBERCOUNTER in SALES_LIBRARY set to 0." ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.open">
				<title>open</title>
				<para>Open the specified DBMS or path, or connect to the Uniface Router. </para>
				<sect2>
					<title>Syntax</title>
					<para> open LogonParameters , " PathString " {/net} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/net—Specify that PathString is a network path. Any path not recognized as
						a network path is assumed to be a DBMS path. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>LogonParameters—String containing the information necessary to log
								on to the specified path, or a field (or indirect reference to a
								field), a variable, or a function that evaluates to the string: </para>
							<para>{Name}| {UserName}| {Password} {| UST} <itemizedlist>
									<listitem>
										<para>Name—Database name or DBMS network server name (for a
											DBMS connector), or network node name or server name
											(for a network connector) </para>
									</listitem>
									<listitem>
										<para>UserName—Logon name for the DBMS or network driver
										</para>
									</listitem>
									<listitem>
										<para>Password—Password for the UserName on the driver
										</para>
									</listitem>
									<listitem>
										<para>UST—Uniface server type as defined in the Uniface
											Router's assignment file <emphasis role="bold"
												>urouter.asn</emphasis>
										</para>
									</listitem>
								</itemizedlist></para>
							<para>The Name, UserName, and Password parameters can each be replaced
								by a question mark (?) or completely omitted. </para>
						</listitem>
						<listitem>
							<para>PathString—String constant containing the name of a DBMS or
								network path; Although not required, it is recommended that you
								include the leading dollar sign ($) as part of the path named in
								PathString, for example: </para>
							<para>open "node |||","$TXT/net" </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by open in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> The path was successfully opened. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> Path is not found. </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -4 </entry>
										<entry> Open request for table or file failed. The table or
											file is not painted, or it does not exist. </entry>
									</row>
									<row>
										<entry> -9 </entry>
										<entry> An attempt to open a DBMS failed because the maximum
											number of DBMS logons has already been reached. </entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								open</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1107 </entry>
										<entry> &lt;UPROCERR_PATH&gt; </entry>
										<entry> The path name is not correct or the path does not
											exist, for example, no assignment is found for the path.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The open statement logs on to the DBMS via the specified path. If path is
						already open, this statement performs an implicit close before logging on. </para>
					<para>It can also be used to connect to the Uniface Router for the purpose of
						receiving messages sent with postmessage. In that case, the $DNP (Default
						Network for Postmessage) is used as PathString. </para>
					<para>The open statement can be placed in several different triggers. Typically,
						it might be placed in the Application Execute or the Execute triggers, when
						the developer knows which database or databases will be accessed in the
						course of the application, and wants to allow the user to log on to them all
						at the beginning. </para>
				</sect2>
				<sect2>
					<title>Example: Connecting to a Database </title>
					<para>The following example shows how to open an Oracle database for user scott,
						with a password of tiger. The path $ORA corresponds to a default path
						established at installation. </para>
					<programlisting role="uniface"><![CDATA[open "|scott|tiger", "$ora"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Connecting to the Uniface Router</title>
					<para>For example, the following example connects to the Uniface Router with HR
						as server type (UST) on the $DNP path. </para>
					<programlisting role="uniface"><![CDATA[open "AdminServer|||HR","$DNP"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.operation">
				<title>operation</title>
				<para>Declare an operation. </para>
				<sect2>
					<title>Syntax</title>
					<para/>
					<para>{public | partner } operation OperationName | PredefinedOperationName </para>
					<para>{scopeBlock}</para>
					<para>{paramsBlock}</para>
					<para>{variablesBlock}</para>
					<para>Your code here ... </para>
					<para>{end}</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>public—includes the operation in the component signature so
									that it can be invoked by from an external component by an
									activate statement; default </para>
							</listitem>
							<listitem>
								<para>partner—excludes the operation from the signature; it can only
									be invoked from within the component itself. </para>
							</listitem>
							<listitem>
								<para>OperationName—literal name of the operation; maximum length of
									32 bytes. The characters can be letters (A-Z), digits (0-9), and
									underscores (_), and must begin with a letter (A-Z). </para>
							</listitem>
							<listitem>
								<para>PredefinedOperationName—one of the following predefined
									operations, which define component behavior in specific
									circumstances: <itemizedlist>
										<listitem>
											<para>Init—executed when a component instance is created
												with newinstance or activate. </para>
										</listitem>
										<listitem>
											<para>Cleanup—executed when a component is removed
											</para>
										</listitem>
										<listitem>
											<para>Attach—executed when a contained DSP is attached
												to a parent DSP </para>
										</listitem>
										<listitem>
											<para>Detach—executed when an attached child DSP is
												detached from its parent. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>scopeBlock—see scope </para>
							</listitem>
							<listitem>
								<para>paramsBlock—see params </para>
							</listitem>
							<listitem>
								<para>variablesBlock—see variables </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The operation block defines an operation that can be called by an activate
						statement. It acts as an implicit end for the previous operation or Proc
						module. It can be used only in the Operations trigger. </para>
					<para>By default, an operation is public, meaning that it can be activated by
						other components. If you want it to be accessible only within the component,
						you must declare it as partner.</para>
					<para>If you define scope, parameters, or variables for the operation, they
						should be declared in that order—first the scope block, followed by the
						params block, and then the variables. </para>
				</sect2>
				<sect2>
					<title>Operation Names</title>
					<para>When specifying the operation name:</para>
					<itemizedlist>
						<listitem>
							<para>Do not enclose the name in double quotation marks ("). </para>
						</listitem>
						<listitem>
							<para>Do not use the names Exec, Accept, and Quit. (These are predefined
								operations that implemented in the triggers Execute, Accept, and
								Quit, respectively). </para>
						</listitem>
						<listitem>
							<para>Do not define operations named ABORT or COMPLETE, because these
								are reserved for future use. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Defining an Operation</title>
					<para>The following example shows the operation DISCOUNT, defined in the
						Operations trigger of a service component named SERV1: </para>
					<programlisting role="uniface"><![CDATA[; Operations trigger of service SERV1
operation DISCOUNT
params
   string CUSTID : IN
   numeric AMOUNT : INOUT
   numeric PERCENTAGE : OUT
endparams
; no discount till proven otherwise
; 20% discount for Compuware
; 15% discount for Acme
; adjust amount
PERCENTAGE = 0
if ( CUSTID == "cpwr" ) PERCENTAGE = 20
if ( CUSTID == "acme" ) PERCENTAGE = 15
AMOUNT = AMOUNT * ( 100 - PERCENTAGE) / 100
end
]]></programlisting>
					<para>The operation DISCOUNT could be referenced from another component as
						follows: </para>
					<programlisting role="uniface"><![CDATA[activate "SERV1".DISCOUNT (ID.CUST, TOTAL.INVOICE, $DISCOUNT$)]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Calling an Operation Recursively </title>
					<para>The following example shows the operation FACTORIAL, defined in the
						Operations trigger of a service component named CALCULATOR: </para>
					<programlisting role="uniface"><![CDATA[operation FACTORIAL
params
   numeric N : IN
   numeric F : OUT
endparams
variables
      numeric W
endvariables
if ( N &gt; 1 )
   W = N - 1
   activate "calculator".FACTORIAL (W, F)
   F = N * F
else
   if ( N = 1 )
      F = 1
   else
      F = 0
   endif
endif
end ; operation FACTORIAL]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.params">
				<title>params</title>
				<para>Define the parameter block for an operation, entry, or global Proc. </para>
				<sect2>
					<title>Syntax</title>
					<para>params </para>
					<para> DataType ParamName : Direction </para>
					<para> {DataType} LitFieldName . LitEntityName{. LitModelName} : Direction </para>
					<para> {DataType} $ CompVarName $ : Direction </para>
					<para> entity LitEntityName{. LitModelName} : Direction </para>
					<para> occurrence LitEntityName{. LitModelName} : Direction </para>
					<para> xmlstream [DTD: DTDName ] ParamName : Direction </para>
					<para>endparams </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>DataType—a Uniface Data Type. </para>
						</listitem>
						<listitem>
							<para>ParamName—string has a maximum length of 32 bytes, including
								letters (A-Z), digits (0-9), and underscores (_); the first
								character must be a letter. </para>
						</listitem>
						<listitem>
							<para>LitFieldName— literal name of a field that is painted on the
								component </para>
						</listitem>
						<listitem>
							<para>LitEntityName—literal name of a model entity (either database or
								non-database) that is painted on the component. On both the activate
								statement for this operation and in the params block, the
								corresponding entity parameters must represent the same entity, that
								is, the entity itself or one or its subtypes. </para>
						</listitem>
						<listitem>
							<para>CompVarName—name of a component variable that is defined in the
								component </para>
						</listitem>
						<listitem>
							<para>LitModelName—literal name of the model to which the entity
								belongs. </para>
						</listitem>
						<listitem>
							<para>DTDName—string or component constant that evaluates to the name of
								the DTD that defines the structure of XML stream variables. DTDName
								has the format: </para>
							<para>LitDTDName{. LitModelName} </para>
							<para>LitDTDName is the literal DTD name defined in the application
								model specified by LitModelName. </para>
						</listitem>
						<listitem>
							<para>Direction—direction for the parameter with respect to the
								operation; one of IN (input only), OUT (output only), or INOUT
								(input and output). </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components, and in global Proc
						modules. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The params statement defines the formal parameters for an operation, for
						an entry (either a global or local Proc module), or for a global Proc. A
						maximum of 64 parameters can be defined. When the operation or entry is
						referenced with an activate or call statement, the arguments provided on
						that statement must match this list of parameters in number and in type. </para>
					<para>The parameter block defined by params can occur in any of the following
						places:</para>
					<itemizedlist>
						<listitem>
							<para>The first statement following an operation statement in the
								Operations trigger </para>
						</listitem>
						<listitem>
							<para>The first statement in the Execute trigger (for an EXEC operation)
								in all components except dynamic server pages </para>
						</listitem>
						<listitem>
							<para>The first statement following an entry statement in an entry
								module </para>
						</listitem>
						<listitem>
							<para>The first statement of a global Proc module </para>
						</listitem>
					</itemizedlist>
					<para>If no parameters are required, the params block is not required. If a
						variables block is present, it should immediately follow the params block,
						or the operation statement if no parameters are defined. </para>
				</sect2>
				<sect2>
					<title>Uniface Data Types</title>
					<table>
						<title>Table 1. Basic Uniface Data Types</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Data Type</entry>
									<entry> Code</entry>
									<entry> Allowed Values</entry>
									<entry> Remarks</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> boolean </entry>
									<entry> B</entry>
									<entry> T or F </entry>
									<entry> Boolean</entry>
								</row>
								<row>
									<entry> date </entry>
									<entry> D</entry>
									<entry> Integer representing a date in the format ccyymmdd </entry>
									<entry> Date</entry>
								</row>
								<row>
									<entry> datetime </entry>
									<entry> E</entry>
									<entry> Integer representing a date and time in the format
										ccyymmddhhnnss </entry>
									<entry> Combined date and Time</entry>
								</row>
								<row>
									<entry> float </entry>
									<entry> F</entry>
									<entry> Number with a floating decimal point</entry>
									<entry> Floating decimal point to allow high precision data and
										calculations</entry>
								</row>
								<row>
									<entry> handle </entry>
									<entry> H</entry>
									<entry> Reference to component instance</entry>
									<entry> Handle can be designated as public or partner. Public
										handles can only access public operations. Partner handles
										can access partner operations and public operations.</entry>
								</row>
								<row>
									<entry> image </entry>
									<entry> I</entry>
									<entry> Binary data for an image</entry>
									<entry> Image</entry>
								</row>
								<row>
									<entry> lineardate </entry>
									<entry> LD</entry>
									<entry> Integer from 0 through 3652425 </entry>
									<entry> Linear Date represents a number of days</entry>
								</row>
								<row>
									<entry> lineardatetime </entry>
									<entry> LE</entry>
									<entry> Number from 0 through 10000 </entry>
									<entry> Linear Date and Time represents a number of days.
										Partial days (hours, minutes, seconds) can be expressed as a
										fraction of a day.</entry>
								</row>
								<row>
									<entry> lineartime </entry>
									<entry> LT</entry>
									<entry> Integer from 0 through 24 </entry>
									<entry> Linear Time represents a number of hours</entry>
								</row>
								<row>
									<entry> numeric </entry>
									<entry> N</entry>
									<entry> Number to a maximum of 9 decimal places, including +, -,
										and decimal point . </entry>
									<entry> Numeric</entry>
								</row>
								<row>
									<entry> raw </entry>
									<entry> R</entry>
									<entry> Binary data</entry>
									<entry> Raw</entry>
								</row>
								<row>
									<entry> string </entry>
									<entry> S</entry>
									<entry> Any characters in the UTF-8 character set, or an empty
										string.</entry>
									<entry> String</entry>
								</row>
								<row>
									<entry> time </entry>
									<entry> T</entry>
									<entry> Integer representing a date in the format hhnnss </entry>
									<entry> Time</entry>
								</row>
								<row>
									<entry> xmlstream </entry>
									<entry> XM</entry>
									<entry> Well-formed XML data</entry>
									<entry> XML Stream</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>In addition to the basic data types, it is also possible to specify any as
						the data type in an entry (either a global or local Proc module) or in a
						global Proc. </para>
				</sect2>
				<sect2>
					<title>Entity and Occurrence Parameters</title>
					<para>entity and occurrence parameters are known as <emphasis role="italic"
							>constructed</emphasis> parameters, while the field, component variable,
						and named parameters are called <emphasis role="italic">basic</emphasis>
						parameters. An entity parameter transfers all occurrences of the specified
						entity from one component to the other component. An occurrence parameter
						transfers the current occurrence of the specified entity from one component
						to the other component. (On each call to the operation, an implicit creocc
						is performed to set aside sufficient memory for the occurrence parameter;
						about 520 bytes for an In or Out occurrence parameter, or about 1040 bytes
						for an INOUT occurrence parameter, and is subsequently not released). </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Constructed parameters cannot be
						used in entries (global or local Proc modules) and in global Procs. </para>
				</sect2>
				<sect2>
					<title>XML Stream Parameters</title>
					<para>xmlstream parameters contain XML data. The XML data can be transferred
						between the parameter and the component's external data structure by Proc
						statements, using xmlsave and xmlload. </para>
				</sect2>
				<sect2>
					<title>Direction</title>
					<para>Use one of the qualifiers IN, OUT, or INOUT to define the direction for
						the parameter with respect to the operation, that is, input only, output
						only, or input and output, respectively. If a parameter is defined as OUT,
						its value at the start of the operation cannot be predicted. </para>
					<itemizedlist>
						<listitem>
							<para>If the entity parameter has direction IN or INOUT, when the
								operation starts, an implicit clear/e statement for that entity is
								performed in the component instance before the occurrences are
								filled with the data being transferred. </para>
						</listitem>
						<listitem>
							<para>If the entity parameter has direction OUT or INOUT, when the
								operation returns, an implicit clear/e statement for that entity is
								performed in the requesting component instance before the
								occurrences are filled with the data being returned. This is
								followed by a release/e/mod statement for the entity. </para>
						</listitem>
						<listitem>
							<para>If the occurrence parameter has direction IN or INOUT, when an
								operation starts, the current occurrence of the requesting component
								becomes the new occurrence in the requested component (such as an
								entity service). </para>
						</listitem>
						<listitem>
							<para>If the occurrence parameter has direction OUT or INOUT, when the
								operation returns, the current occurrence of the requested component
								becomes the new occurrence in the requesting component. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> If a component is activated
						asynchronously (for example, with the /async switch on the </para>
					<para>newinstance statement), you should not activate an operation that contains
						a parameter with the direction OUT or INOUT. </para>
				</sect2>
				<sect2>
					<title>Scope of Parameters</title>
					<para>An entity, occurrence, field, or component variable parameter is defined
						at the component level. The values of these parameters are component-wide in
						scope; that is, the values are available to all operations and modules in
						the component. </para>
					<para>A named parameter exists only in the operation or module in which it is
						defined. Its scope is limited to that operation or module. It cannot be
						directly referenced from another operation or module in the component, or
						from a local or global Proc called by the operation or module. If a named
						parameter has the same name as a field defined in the component, the
						parameter takes precedence over the field; to access the field, you must use
						the qualified field name. </para>
					<para>For example, consider a component that contains a field named DATE in the
						entity PO. The operation TODAY has a named parameter, DATE. To update the
						field DATE in the operation TODAY, the field must be referenced by its
						qualified name, including its entity: </para>
					<programlisting role="uniface"><![CDATA[operation TODAY
params
   date DATE : OUT
endparams
DATE = $date ;assign the current date to parameter DATE
DATE.PO = $date ;assign the current date to field DATE.PO
end ; operation TODAY
]]></programlisting>
					<para>xmlstream parameters have the same scope as named parameters. However, the
						data in an XML stream is not accessible to Uniface until the data has been
						loaded into the component's external data structure, which is accessible by
						all Proc modules in the component. </para>
				</sect2>
				<sect2>
					<title>Example: Defining an Operation</title>
					<para>The following example shows the operation DISCOUNT, defined in the
						Operations trigger of a service component named SERV1: </para>
					<programlisting role="uniface"><![CDATA[; Operations trigger of service SERV1
operation DISCOUNT
params
   string CUSTID : IN
   numeric AMOUNT : INOUT
   numeric PERCENTAGE : OUT
endparams
; no discount till proven otherwise
; 20% discount for Compuware
; 15% discount for Acme
; adjust amount
PERCENTAGE = 0
if ( CUSTID == "cpwr" ) PERCENTAGE = 20
if ( CUSTID == "acme" ) PERCENTAGE = 15
AMOUNT = AMOUNT * ( 100 - PERCENTAGE) / 100
end
]]></programlisting>
					<para>The operation DISCOUNT could be referenced from another component as
						follows: </para>
					<programlisting role="uniface"><![CDATA[activate "SERV1".DISCOUNT (ID.CUST, TOTAL.INVOICE, $DISCOUNT$)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.perform">
				<title>perform</title>
				<para>Call the specified 3GL function. </para>
				<sect2>
					<title>Syntax</title>
					<para>perform{/noterm} "{_}Lit3GLFunctionName " </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/noterm —the following sequence of processing is performed: </para>
					<orderedlist>
						<listitem>
							<para>Keyboard input driver and *busy* indicator are disabled. </para>
						</listitem>
						<listitem>
							<para>Keyboard setup is reset to its original value. </para>
						</listitem>
						<listitem>
							<para>Lit3GLFunctionName is performed. </para>
						</listitem>
						<listitem>
							<para>Keyboard is set to application mode. </para>
						</listitem>
						<listitem>
							<para>Input driver and *busy* indicator are enabled. </para>
						</listitem>
					</orderedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Lit3GLFunctionName—literal name of the 3GL function to call.
								</para>
							</listitem>
							<listitem>
								<para>_ (underscore)—puts the Lit3GLFunctionName in the dispatch
									list in lowercase characters (without the underscore). In this
									case, Lit3GLFunctionName can contain up to 15 characters. </para>
								<para>Otherwise, Lit3GLFunctionName is put in the dispatch list in
									uppercase characters and Lit3GLFunctionName can contain up to 16
									characters. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Description</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> &gt;=0</entry>
										<entry> Value returned by Lit3GLFunctionName. (Since Uniface
											expects -1 to be an error, it is not a good idea to
											return that value from the 3GL function.) </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values returned in $procerror following perform</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Symbolic error </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1121 </entry>
										<entry> &lt;UPROCERR_3GL&gt; </entry>
										<entry> The requested 3GL function was not found. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para><emphasis role="bold"> Note:</emphasis> The perform statement has been
						superceded by activate for C call-out. See Call-Out to 3GL and Call-Out
						Using activate. </para>
					<para>The perform statement calls the specified 3GL Lit3GLFunctionName. A 3GL
						function can access and modify variables, fields, and occurrences in the
						form. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Any 3GL function that you call with
						perform should be declared to return a long value (in C). </para>
					<para>Although perform "%%variable" is accepted by the Proc compiler, it is not
						substituted at run time. </para>
				</sect2>
				<sect2>
					<title>Function Name Limitations</title>
					<para>The name of the Lit3GLFunctionName can up to 15 or 16 characters,
						depending on whether you use an underscore to change the case of the
						function name. You cannot combine uppercase and lowercase in a function
						name. </para>
					<para>The limits on the length of Lit3GLFunctionName are Uniface limitations and
						do not imply that the linker can handle functions of this length. </para>
				</sect2>
				<sect2>
					<title>Example: Calling a 3GL Function </title>
					<para>The following example calls the 3GL function stringcheck: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Leave Field
if ($fieldendmod = 0)
   done
endif
perform "_stringcheck"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.pi">
				<title>pi [DEPRECATED]</title>
				<warning>
					<para> The command <function>pi</function> was replaced by <link
							linkend="langref.dollar_pi">
							<function>pi</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'pi' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_pi">
							<function>$pi</function>
						</link> was introduced to replace <literal>pi</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.postmessage">
				<title>postmessage</title>
				<para>Send an asynchronous message from one component instance to another. </para>
				<sect2>
					<title>Syntax</title>
					<para>postmessage Destination , MessageId , MessageData </para>
					<para>The Destination is of the form: {InstPath :}InstName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Destination—string defining the destination for the message,
									or a field (or indirect reference to a field), a variable, or a
									function that evaluates to the string. </para>
							</listitem>
							<listitem>
								<para>InstPath—name of a logical or physical path. The message is
									placed in the event input queue of the Uniface application at
									the receiving end of this path. </para>
								<para>If InstPath is omitted, InstName is assumed to be in the
									current application. </para>
							</listitem>
							<listitem>
								<para>InstName—name of an instance in the component pool. If
									InstName is longer than 16 characters, it is truncated to that
									length. Trailing blanks are removed. An empty string ("") is not
									allowed. </para>
							</listitem>
							<listitem>
								<para>MessageId—string containing an identifier for the message, or
									a field (or indirect reference to a field), a variable, or a
									function that evaluates to the string. MessageId must contain at
									least one nonblank character and be no more than 32 characters
									in total. If MessageId is longer than 32 characters, it is
									truncated to that length. Trailing blanks are removed. </para>
							</listitem>
							<listitem>
								<para>MessageData—constant, a field, or a variable that contains the
									data sent with the message. The data type of the data is
									maintained in the receiving form. </para>
								<para><emphasis role="bold"> Note:</emphasis> The amount of data
									that can be sent is limited only by the memory resources
									available on the machines, but be aware of the incompatibility
									that exists between Uniface V7 (and older versions of V8) that
									have a upper limit of 4KB.</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by postmessage in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Message for InstName successfully placed in event
											queue; this does not mean that the message was actually
											delivered, only that it has been ‘posted’. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> postmessage encountered in a modal form. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> InstName is not correct: field or variable not
											found, or the string is not a valid instance name.
										</entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> MessageId is not correct: field or variable not
											found, or the string is not a valid message identifier.
										</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								postmessage</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
										<entry> The named instance cannot be found in the component
											pool. For example, the name is an empty string ("").
										</entry>
									</row>
									<row>
										<entry> -159 </entry>
										<entry> &lt;UACTERR_QUEUE&gt; </entry>
										<entry> Message could not be delivered to requested queue.
										</entry>
									</row>
									<row>
										<entry> -1105 </entry>
										<entry> &lt;UPROCERR_INSTANCE&gt; </entry>
										<entry> The instance name provided is not valid. (See
											-new_instance- for more information.) For example, the
											argument contains incorrect characters. </entry>
									</row>
									<row>
										<entry> -1107 </entry>
										<entry> &lt;UPROCERR_PATH&gt; </entry>
										<entry> The path name is not correct or the path does not
											exist, for example, no assignment is found for the path.
										</entry>
									</row>
									<row>
										<entry> -1111 </entry>
										<entry> &lt;UPROCERR_MESSAGE&gt; </entry>
										<entry> The message identifier is not valid; the field or
											variable was not found, or the string is not a valid
											message identifier. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The postmessage statement sends an asynchronous message to the component
						instance specified. A Uniface client application can post a message only to
						an instance in the Asynchronous Application server that was created by the
						client application. (Use activate to send a synchronous message.) </para>
					<para>The instance sending the message does not automatically receive an
						acknowledgment that the message has been received. (If this behavior is
						required, an acknowledgment must be explicitly returned by the receiving
						instance.) </para>
				</sect2>
				<sect2>
					<title>Where Does the Message Go?</title>
					<para>The message being sent is placed in the event input queue for the target
						instance. When the structure editor regains control (probably at the end of
						the current trigger) and the message reaches the top of the input queue, an
						Asynchronous Interrupt trigger associated with InstName is activated: </para>
					<itemizedlist>
						<listitem>
							<para>If the component-level Asynchronous Interrupt trigger of InstName
								contains Proc code, that trigger is activated. </para>
						</listitem>
						<listitem>
							<para>If the component-level trigger is empty, the application-level
								Asynchronous Interrupt trigger is activated. </para>
						</listitem>
						<listitem>
							<para>If the application-level trigger is empty, there is no further
								action. </para>
						</listitem>
						<listitem>
							<para>If no instance named InstName is found in the component pool, the
								message is directed to the application-level Asynchronous Interrupt
								trigger. </para>
						</listitem>
					</itemizedlist>
					<para>When the application-level Asynchronous Interrupt trigger is activated,
						the application is the one that is the target of InstPath. </para>
				</sect2>
				<sect2>
					<title>What Does the Message Contain?</title>
					<para>In the Asynchronous Interrupt trigger that is activated: </para>
					<itemizedlist>
						<listitem>
							<para>$result contains the string "message". </para>
						</listitem>
						<listitem>
							<para>$msginfo contains MessageId, MessageData, and other information
								about the message. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> When a postmessage statement is
						encountered in the debugger, it is treated synchronously, that is, the
						Asynchronous Interrupt trigger of the target instance is activated
						immediately. </para>
				</sect2>
				<sect2>
					<title>Example: postmessage</title>
					<para>The following figure shows a non-modal form, RCP_LIST, that displays a
						list of recipes and has a command button, Update. Each time Update is
						clicked, a new instance of the form RCP_UPDATE is created for the current
						recipe. When the Store button on the RCP_UPDATE instance is clicked, the
						data is stored and RCP_LIST is notified that a change has taken place. </para>
					<para>non-modal forms</para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_4.jpg"/>
						</imageobject>
					</mediaobject>
					<para>When the form RCP_LIST starts, Proc code in the Execute trigger retrieves
						all recipes and sorts them by name: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute of RCP_LIST
; GOLD * in (technical) primary key of RECIPES
; retrieve all
; sort by name
RCP_NR = "<emphasis role="underline">*</emphasis>"
retrieve
sort "RECIPES", "RCP_NAME:A"
edit
]]></programlisting>
					<para>The Detail trigger of the command button Update creates an instance of the
						form RCP_UPDATE for the current recipe and activates the Execute trigger of
						that instance: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail of BTN_UPDATE
; tell the msg frame our troubles
$INST_NAME$ = "UPDATE_%%RCP_NR"
newinstance "RCP_UPDATE", $INST_NAME$, "MODALITY=NON-MODAL"
  putmess "newinstance: $status=%%$status"
  putmess "              $procerror=%%$procerror"
activate $INST_NAME$.EXEC(RCP_NR.RECIPES)
  putmess "activate    : $status=%%$status"
  putmess "              $procerror=%%$procerror"
]]></programlisting>
					<para>The Asynchronous Interrupt trigger of RCP_LIST handles messages from the
						instances and updates the list of recipes: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Asynchronous Interrupt of RCP_LIST
; tell the message frame how we got here
; this is the new or changed recipe
; we"ve got an update, occ is already in form
; get updated information
; we"ve got a new one here
; get new information
; make updated/new occurrence current
putmess " "
putmess "$msgid = %%$msgid"
putmess "%msgsrc = %%$msgsrc"
putmess "%msgdata = %%$msgdata"
RCP_NR = $msgdata
if ( $msgid = "RCP_UPDATE" )
   reload/nolock "RECIPES"
endif
if ( $msgid = "RCP_NEW" )
   retrieve/x "RECIPES"
endif
if ( $msgid = "RCP_UPDATE" | $msgid = "RCP_NEW")
   sort "RECIPES", "RCP_NAME:A"
   retrieve/o "RECIPES"
endif]]></programlisting>
					<para>When each instance of the form RCP_UPDATE starts, the Execute trigger
						retrieves the selected recipe, using the recipe number provided by RCP_LIST: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute of RCP_UPDATE
params
string RCP_NR.RECIPES : IN
endparams
retrieve
if ( $status &lt; 0 )
message "Retrieve did not succeed; see message frame"
endif
edit]]></programlisting>
					<para>When the user clicks the Store button, the Store trigger is activated: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail of BTN_STORE
macro "^STORE"
]]></programlisting>
					<para>The Store trigger stores the modified data, and, if that succeeds, uses
						postmessage to notify RCP_LIST that the recipe has been updated and
						setformfocus to return focus to the list of recipes so that the user can
						quickly select another to edit. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Store of RCP_UPDATE
store
if ($status &lt;0)
message $text(1500)
rollback
commit
else
if ($status = 1)
message $text(1723
else
      commit
      if ($status &lt; 0)
      rollback
      commit
   else
      message $text(1805)
;     Following 2 statements added to default Store trigger
      postmessage "RCP_LIST", $componentname, RCP_NR.RECIPES
      setformfocus "RCP_LIST"
   endif
endif
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.power">
				<title>power [DEPRECATED]</title>
				<warning>
					<para> The command <function>power</function> was replaced by <link
							linkend="langref.dollar_power">
							<function>$power</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'power'
						used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_power">
							<function>$power</function>
						</link> was introduced to replace <literal>power</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.pragma">
				<title>pragma</title>
				<para> Interpret profile characters in the Proc module as 'maybe' characters. </para>
				<sect2>
					<title>Syntax</title>
					<para> pragma v5profile | v6profile </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para><emphasis role="bold"> Note:</emphasis> The pragma command provides
						support for an obsolete feature which has been superceded by C call-out. See
						Call-Out to 3GL. </para>
					<para>The pragma v5profile statement maintains compatibility for profile
						characters used in constant strings handled by 3GL (executed via the perform
						statement) and with the following Proc statements: </para>
					<itemizedlist>
						<listitem>
							<para>Target = Expression (that is, all assignment operations) </para>
						</listitem>
						<listitem>
							<para>if </para>
						</listitem>
						<listitem>
							<para>lookup </para>
						</listitem>
						<listitem>
							<para>macro </para>
						</listitem>
						<listitem>
							<para>read </para>
						</listitem>
						<listitem>
							<para>reload </para>
						</listitem>
						<listitem>
							<para>scan </para>
						</listitem>
						<listitem>
							<para>selectdb </para>
						</listitem>
						<listitem>
							<para>repeat/until </para>
						</listitem>
						<listitem>
							<para>while/endwhile </para>
						</listitem>
					</itemizedlist>
					<para>When upgrading from Uniface V5, the upgrade procedure inserts a pragma
						v5profile statement in every Proc module it finds. In general, this insures
						that, after upgrading, Uniface behaves in the same way with each retrieve
						profile that contains "maybe" characters as it did in versions prior to
						V6.1. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> For reasons of efficiency, if a Proc
						contains fewer than 128 characters and Uniface detects no constant string or
						profile character, the pragma v5profile statement is not added to your code. </para>
					<para>Prior to V6.1, Uniface interpreted any profile character as either profile
						or literal, depending on the context. Beginning with V6.1, such characters
						are interpreted as a ‘maybe’ character if it occurs after the following Proc
						statement: </para>
					<programlisting role="uniface"><![CDATA[pragma v5profile]]></programlisting>
					<para>and before the following statement (if present): </para>
					<programlisting role="uniface"><![CDATA[pragma v6profile]]></programlisting>
					<para>Without the pragma v5profile statement, your Proc code behaves according
						to the default Uniface V6.1 behavior for profile characters. This is
						equivalent to the behavior requested by the pragma v6profile statement. </para>
					<para>When writing new Proc code, you are advised not to use the pragma
						statement. The pragma statement should be removed from upgraded Proc code
						and "maybe" characters replaced by GOLD profile characters as soon as it is
						practical. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example causes all occurrences of the relevant entities to
						be retrieved where NAME begins with ‘A’. The pragma v5profile statement
						causes Uniface to interpret the asterisk (*) as a ‘maybe’ character. </para>
					<programlisting role="uniface"><![CDATA[pragma v5profile
read u_where (name = "A*")
pragma v6profile
]]></programlisting>
					<para>You should replace the asterisk with an explicit GOLD * profile character
						and delete the pragma v5profile statement. </para>
					<programlisting role="uniface"><![CDATA[read u_where (name = "A<emphasis role="underline">*</emphasis>")]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.print">
				<title>print</title>
				<para>Activate printing. </para>
				<sect2>
					<title>Syntax</title>
					<para>print{/ask} {/preview} {PrintJobModel{, PrintMode{, USE_SYSTEM_SETTINGS= (
						TRUE | FALSE)}}} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/ask—presents the user with the Print form with PrintJobModel and
								PrintMode as default values, which can be edited by the user.
							</para>
						</listitem>
						<listitem>
							<para>/preview—presents the user with the Print Preview window, which
								enables the user to view the printout at different scales, navigate
								to previous and next pages, print the output, or close the window.
								By default, the zoom percentage is Entire Page. You can specify the
								default zoom percentage for the Preview window using the Printer tab
								of the Setup menu print/preview is supported only on Microsoft
								Windows 32-bit platforms and for the P_MSWIN3 and P_MSWINX device
								translation tables.</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>PrintJobModel—string that contains the name of the print job model
								to use for printing, or a field (or indirect reference to a field),
								a variable, or a function that evaluates to the string. The print
								job model determines where and how to print. If omitted, the print
								job model PRINTER is used. </para>
						</listitem>
						<listitem>
							<para>PrintMode—string that identifies the mode to use for printing, or
								a field (or indirect reference to a field), a variable, or a
								function that evaluates to the string. If PrintMode is omitted, the
								print mode A (All) is used. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Values for the PrintMode argument on the print
							statement</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> A </entry>
									<entry> All—print the form or report component and all data in
										the hitlist. </entry>
								</row>
								<row>
									<entry> C </entry>
									<entry> Like All, but clear the data from memory after printing.
										It is recommended that you use C when writing reports or
										report-like forms. </entry>
								</row>
								<row>
									<entry> F </entry>
									<entry> Current component and data—print the entire form or
										report component and all data currently in it. </entry>
								</row>
								<row>
									<entry> S </entry>
									<entry>
										<itemizedlist>
											<listitem>
												<para>In character mode, print what is on the
												screen. </para>
											</listitem>
											<listitem>
												<para>In GUI mode, same as F. </para>
											</listitem>
										</itemizedlist>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<itemizedlist>
						<listitem>
							<para>USE_SYSTEM_SETTINGS—determines whether the Microsoft Windows print
								settings are used or whether the current print job settings are
								used. If set to TRUE, the Microsoft settings are used. If set to
								FALSE, the current print job settings override the Windows settings. </para>
							<para>If a value other than TRUE or FALSE is provided, Uniface
								interprets the value as TRUE. Omitting USE_SYSTEM_SETTINGS is
								equivalent to FALSE. </para>
							<para>USE_SYSTEM_SETTINGS is only available on Microsoft Windows
								platforms, and is only supported for the P_MSWIN3 and P_MSWINX
								device translation tables. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 2. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Statement executed successfully</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Values commonly returned by $procerror following
							print</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -400 </entry>
									<entry> &lt;UMISERR_PRINT&gt; </entry>
									<entry><para>Uniface could not print, for example: </para><itemizedlist>
											<listitem>
												<para>Printing is already being performed
												($printing=1). </para>
											</listitem>
											<listitem>
												<para>^QUIT was used in the Print form. </para>
											</listitem>
											<listitem>
												<para>The print mode is not valid</para>
											</listitem>
										</itemizedlist></entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>print is allowed in form and report components (and in service components
						that are not self-contained). </para>
					<para>print/ask is allowed in form components. </para>
					<para>print/preview is allowed in form components and in report components in
						test mode. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The print statement activates printing in Uniface, using the
						PrintJobModel, PrintMode, and settings specified. </para>
					<para><emphasis role="bold"> Note:</emphasis> When a print statement is
						encountered in an operation that is being executed on the server, the print
						job models available are those on the server (in the Repository entity
						PRATT.PRINTER). </para>
					<para>The print statement is executed unseen by the user and is therefore best
						used in reports and batch mode applications.</para>
					<para>In forms, you can use print/ask to prompt for information, enabling the
						user to choose a different printer or a different layout to suit their
						requirements. The print/ask statement takes the supplied parameters (print
						job model and print mode) and presents the user with the Print form already
						filled in. This allows users to interactively tailor the printer
						specifications according to their requirements. </para>
				</sect2>
				<sect2>
					<title>Example: Printing Records in a Hitlist (With Confirmation)</title>
					<para>The following example prints all the information in the hitlist to the
						printer described by print job model SALESLASER. The user is prompted to
						confirm the values used. </para>
					<programlisting role="uniface"><![CDATA[print/ask "SALESLASER","A"]]></programlisting>
					<para>This produces the display shown in the following figure: </para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/printDialog_SALESLASER.gif"/>
						</imageobject>
					</mediaobject>
				</sect2>
				<sect2>
					<title>Example: Printing Records in a Hitlist (Without Confirmation)</title>
					<para>The following example prints all the records in the hitlist, using the
						values given in the SALESLASER print job model. The user is not given the
						opportunity to modify any values. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
; use SALESLASER print job model, option All
custname = $1
retrieve
print "SALESLASER", "A"
if ($status = 0)
   message "Print completed."
else
   message "Error %%$status, printing may have failed"
endif
exit (0)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.print_break">
				<title>print_break [DEPRECATED]</title>
				<para> Deprecated since: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$acos</command> ( <parameter>X</parameter>) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.printbreak">
				<title>printbreak</title>
				<para>Print the specified break frame. </para>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para> printbreak BreakFrameName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>BreakFrameName—string containing the name of the break frame whose Frame
						Gets Focus trigger is to be activated; can also be a field (or indirect
						reference to a field), a variable, or a function that evaluates to the
						string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0</entry>
										<entry> Frame Gets Focus trigger for the specified break
											frame returned a negative value. </entry>
									</row>
									<row>
										<entry> 1</entry>
										<entry> Frame Gets Focus trigger for the specified break
											frame returned a positive value.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								printbreak</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -401 </entry>
										<entry> &lt;UMISERR_PRINT_BREAK&gt; </entry>
										<entry><para>An error occurred during print_break:</para><itemizedlist>
												<listitem>
												<para>Uniface is not printing ($printing != 1)
												</para>
												</listitem>
												<listitem>
												<para>printbreak encountered in a header or
												trailer frame </para>
												</listitem>
											</itemizedlist></entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in only in the Occurrence Gets Focus and Leave Printed Occurrence
						triggers of form and report components (and in service components that are
						not self-contained), . </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The printbreak statement prints the break frame BreakFrameName. This is a
						report-writing statement which allows you to: </para>
					<itemizedlist>
						<listitem>
							<para>Print a break frame instead of a named area frame or entity frame.
							</para>
						</listitem>
						<listitem>
							<para>Include a break frame in the print file immediately after the
								occurrence that has just been printed. </para>
						</listitem>
					</itemizedlist>
					<para>If the printbreak statement is issued when Uniface is not actually
						printing (that is, when $printing is 0), the statement is not executed and
						$status is set to -1. This allows report-like forms to be used interactively
						without having to override printbreak statements and recompile. It is better
						programming practice, however, to make a test on $printing. </para>
					<para>If the printbreak statement is used in a header or trailer frame, the
						statement is not executed and $status is set to -1. </para>
				</sect2>
				<sect2>
					<title>Example: Ejecting a Page</title>
					<para>The following example shows how to use $lines to trigger an eject if there
						is not enough room left to print information: </para>
					<programlisting role="uniface"><![CDATA[; trigger : Leave Printed Occurrence
; entity : INVOICE
; compare date of next occurrence
compare (DATE) from "INVOICE"
; if next date different
if ($result = 0)
   ; if less than 5 lines left, start printing on new page
   if ($lines &lt; 5)
      eject
   endif
   
			; set date in Break Frame
			DATE.DAYTOT = DATE.INVOICE
   ; print break frame for day total
   printbreak "DAYTOT"
   ; reset to zero for new day
   AMOUNT.DAYTOT = 0
   ; if less than 10 lines left, eject after printing break frame
   if ($lines &lt; 10)
      eject
   endif
endif
return(0)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.proccompile">
				<title>proccompile</title>
				<para>Compile a piece of Proc at run time. </para>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para> proccompile /expression | /condition ProcToBeCompiled {, ContextList}
					</para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/expression—compiles the Proc as an expression. </para>
						</listitem>
						<listitem>
							<para>/condition—compiles the Proc as a condition. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>ProcToBeCompiled—Proc to be compiled. </para>
						</listitem>
						<listitem>
							<para>ContextList—list containing sublists with references to objects,
								such as fields and variables, used in ProcToBeCompiled. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Statement executed successfully</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The values in $status following proccompile are:</para>
					<itemizedlist>
						<listitem>
							<para>0, if the Proc compiled successfully </para>
						</listitem>
						<listitem>
							<para>&lt;0, if an error occurred; $abs($status) contains the position
								in the Proc string where the compiler error occurred, and $procerror
								contains the compiler error code. </para>
						</listitem>
					</itemizedlist>
					<para>$result returns the compiled Proc module created by proccompile, which can
						also be executed with $expression or $condition.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The proccompile statement compiles a piece of Proc code at run time so it
						can be checked before it is used in an $expression or $condition Proc
						function. </para>
					<para>Unknown references in ContextList result in compile errors, which will be
						returned in $procerror. Every sublist is identified by one of the following
						context identifiers, specifying the object type: </para>
					<itemizedlist>
						<listitem>
							<para>ITEMS—list of items allowed </para>
						</listitem>
						<listitem>
							<para>FIELDS—list of fields allowed </para>
						</listitem>
						<listitem>
							<para>VARIABLES—list of Parameters or Variables allowed </para>
						</listitem>
						<listitem>
							<para>COMPONENTVARIABLES—list of component variables allowed </para>
						</listitem>
						<listitem>
							<para>GLOBALVARIABLES—list of global variables allowed </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Compiling Proc at Runtime</title>
					<para>The following example demonstrates the use of proccompile, $condition, and
						$expression. proccompile is used to check the entered business rules in the
						DO_DISCOUNT and DISCOUNT fields, $condition is used to evaluate DO_DISCOUNT,
						and $expression is used to return the result of DISCOUNT.</para>
					<para>The field DO_DISCOUNT contains the condition for a discount and DISCOUNT
						contains the actual expression for the discount. At run time, values can be
						entered for both fields that will determine whether a discount should be
						given, and the actual amount of the discount. </para>
					<para>For example, the following line should be entered in the field DO_DISCOUNT
						if a discount should be given when more then 100 articles are ordered (where
						the field AMOUNT contains the number of ordered articles):</para>
					<programlisting role="uniface"><![CDATA[AMOUNT&gt;100]]></programlisting>
					<para>And the following line should be entered in the field DISCOUNT if the
						actual discount is 10 percent of the total cost of the articles (where the
						field PRICE contains the unit price of the ordered article): </para>
					<programlisting role="uniface"><![CDATA[0.1*AMOUNT*PRICE]]></programlisting>
					<para>The following Proc code checks the entered business rules and executes
						them accordingly:</para>
					<programlisting role="uniface"><![CDATA[entry total_cost
variables
   numeric vDiscount
endvariables
; This Proc entry calculates total cost of ordered article including discount
; Check syntax of discount condition in field DO_DISCOUNT
proccompile/condition DO_DISCOUNT, "FIELDS=AMOUNT"
if ($procerror &lt; 0)
   message/error "Incorrect syntax for discount condition (%%$procerror)"
   putmess $procerrorcontext
   return -1
endif
; Check discount condition
if ($condition($result)) ; Use compiled Proc in $result
; A discount should be given
; Check syntax of discount expression in field DISCOUNT
   proccompile/expression DISCOUNT, "FIELDS=AMOUNT<emphasis role="underline">!;</emphasis>PRICE"
   if ($procerror &lt; 0)
      message/error "Incorrect syntax for discount expression (%%$procerror)"
      putmess $procerrorcontext
      return -1
   endif
; Execute discount
; Use compiled Proc in $result
   vDiscount = $expression($result)
; Or, use uncompiled expression
; vDiscount = $expression(DISCOUNT)
else
; No discount should be given
; Set discount to 0
   vDiscount = 0
endif
COST = AMOUNT * PRICE - vDiscount
return 0
end ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.pulldown">
				<title>pulldown</title>
				<para>Activate or load the specified menu bar. </para>
				<sect2>
					<title>Syntax</title>
					<para>pulldown/load MenuBar </para>
					<para>pulldown {MenuBar} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/load—loads a menu bar into the application-level menu bar area. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>MenuBar—string containing the name of a menu bar, or a field (or indirect
						reference to a field), a variable, or a function that evaluates to the
						string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Option trigger of the selected menu item is
										empty</entry>
								</row>
								<row>
									<entry> &gt;0 </entry>
									<entry> Value returned by the Option trigger of the selected
										menu item</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							pulldown</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1125 </entry>
									<entry> &lt;UPROCERR_MENU&gt; </entry>
									<entry> The specified menu does not exist. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>pulldown is allowed in form components (and in service and report
						components that are not self-contained), only in the application-level and
						form-level Pulldown triggers. </para>
					<para>pulldown/load is allowed in form components (and in service and report
						components that are not self-contained), but not in the application-level
						and form-level Pulldown triggers. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>A Uniface application possesses two default menu bar areas which are
						defined declaratively: </para>
					<itemizedlist>
						<listitem>
							<para>Application menu bar—declared in the Initial Menu Bar field of the
								Define Start-up Shell form. </para>
						</listitem>
						<listitem>
							<para>Form menu bar—defined in the Menu Bar field of the Define Form
								Windows Properties form. </para>
						</listitem>
					</itemizedlist>
					<para>Using the /load switch . changes the menu bar loaded by the Initial Menu
						Bar declaration. The menu bar that is loaded depends on the current value of
						$variation </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> Avoid using the pulldown/load
						statement in the Pulldown triggers; the effect of this can be very
						disconcerting. </para>
				</sect2>
				<sect2>
					<title>Using pulldown (without /load)</title>
					<para>When using pulldown without the /load switch, note the following:</para>
					<itemizedlist>
						<listitem>
							<para>Use pulldown only when the TRIG parameter is present on the
								$MENU_BAR assignment setting. This indicates that Uniface should
								handle Pulldown triggers and menu bars as it did prior to V5.2. For
								more information, see $MENU_BAR</para>
						</listitem>
						<listitem>
							<para>Use pulldown only in the application-level and form-level Pulldown
								triggers. </para>
						</listitem>
					</itemizedlist>
					<para>The pulldown statement (without the /load switch) activates the current
						application-level menu bar; that is, it positions the cursor on the first
						option of the application menu bar and allows the user to select options
						using either the cursor keys or the mnemonic letter. </para>
					<para>If the MenuBar argument is present, the menu specified is loaded and then
						activated. (This is equivalent to a pulldown/load MenuBar statement followed
						by a pulldown statement.) The menu bar that is loaded depends on the current
						value of $variation. </para>
				</sect2>
				<sect2>
					<title>Changing the form-level menu bar</title>
					<para>You cannot change the form-level menu bar using a pulldown or
						pulldown/load statement. If you need to use different form-level menu bars
						for a form in different situations, define the menu bar in several different
						libraries. Then set $variation to the appropriate library <emphasis
							role="italic">before </emphasis>the form is run. </para>
				</sect2>
				<sect2>
					<title>Example: Loading a Menu </title>
					<para>The following example loads the menu P_USYS, but does not activate it,
						that is, the focus is not changed: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
pulldown/load "P_USYS"
edit NAME_FIELD]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Activating a Menu</title>
					<para>The following example activates a menu: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Pulldown pulldown ]]></programlisting>
					<para>This example only works if $MENU_BAR has been set to TRIG in the
						assignment file. It is better to do this declaratively, rather than use the
						Pulldown triggers. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.putitem">
				<title>putitem</title>
				<para>Add or replace an item in a list. </para>
				<sect2>
					<title>Syntax</title>
					<para>putitem List , N , Source </para>
					<para>putitem/id{/case} List , Index{, Source} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/id—replace a representation for the associative item whose
									value is Index, or append the item Index{= Source} to List.
								</para>
							</listitem>
							<listitem>
								<para>/case—causes matching to be case-sensitive; must be used with
									the /id switch </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>List—field, an indirect reference to a field, a variable, or an
								assignable function that can accept a string value. The string
								should contain the list into which an item is to be copied. </para>
						</listitem>
						<listitem>
							<para>Source—string, or a field (or indirect reference to a field), a
								variable, or a function that evaluates to a string. The item in
								Source is copied into List. </para>
						</listitem>
						<listitem>
							<para>N—constant, or a field (or indirect reference to a field), a
								variable, or a function that can be converted to a whole (integer)
								number; the value will be truncated to form an integer. </para>
						</listitem>
						<listitem>
							<para>Index—string, or a field (or indirect reference to a field), a
								variable, or a function that evaluates to a string; it may not be an
								expression. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> No item was replaced or added; Source is empty.
										</entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Sequence number of the list item that was replaced
											or added. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form, service, and report components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The putitem statement adds or replaces an item in List. </para>
					<para>To set the initial values in a list, it is easier to use a simple
						assignment. For example: </para>
					<programlisting role="uniface"><![CDATA[$valrep(DBMSFLD) = "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb" ;DBMSFLD is "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Indexed Lists</title>
					<para>Use the putitem statement without switches to put Source into the Nth
						position of List. Items are numbered starting with 1. </para>
					<itemizedlist>
						<listitem>
							<para>If N is -1, putitem appends Source as the last item in List.
							</para>
						</listitem>
						<listitem>
							<para>If N is 0 or if N &lt;-1, List is not changed. </para>
						</listitem>
						<listitem>
							<para>Otherwise, the Nth item in List is replaced by Source. If N is
								greater than the number of items in List, empty items are created
								until the Nth item is reached. </para>
						</listitem>
					</itemizedlist>
					<para>If List contains an associative list, the entire ValRep of the associative
						item is replaced by Source. </para>
					<para>An empty list cannot be distinguished from a list containing a single
						empty item. When an empty item is added to an empty list, the list remains
						empty. For example, after the following statements are executed, $LIST$
						contains only one item: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "" ;an empty list
$1 = ""
putitem $LIST$, -1, $1
putitem $LIST$, -1, $1
putitem $LIST$, -1, "Zeeland" ;$LIST$ contains "Zeeland"
]]></programlisting>
					<para>Empty items that are added to a list that already contains at least one
						nonempty item are simply empty items. For example, after the following
						statements are executed, $LIST$ contains three items: </para>
					<programlisting role="uniface"><![CDATA[$LIST$ = "" ;an empty list
$1 = ""
putitem $LIST$, -1, "Limburg" ;$LIST$ contains "Limburg"
putitem $LIST$, -1, $1 ;$LIST$ contains "Limburg<emphasis role="underline">;</emphasis>"
putitem $LIST$, -1, "Zeeland" ;$LIST$ contains "Limburg<emphasis role="underline">;</emphasis><emphasis role="underline">;</emphasis>Zeeland"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Associative Lists</title>
					<para>For associative lists, use the /id switch replace or append the specified
						item in the list. By default, matching Index with the item values is not
						case-sensitive. </para>
					<para>For example, the following statement replaces the first item in $LIST$
						whose value is ab, Ab, aB, or AB with the item ab=Limburg or adds that item
						to the end of the list if none of these are found: </para>
					<programlisting role="uniface"><![CDATA[putitem/id $list$, "ab", "Limburg"
]]></programlisting>
					<para>To make matching case sensitive, use the /case switch. For example, the
						following statement replaces or adds an item whose value is ab: </para>
					<programlisting role="uniface"><![CDATA[putitem/id/case $list$, "ab", "Limburg"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Building an Indexed List</title>
					<para>In the examples below, an underlined semicolon ( <emphasis
							role="underline">; </emphasis>) represents the Uniface subfield
						separator (by default, GOLD ;) and an underlined exclamation point (
							<emphasis role="underline">! </emphasis>) represents the retrieve
						profile character for logical NOT (GOLD !).</para>
					<para>The following example builds an indexed list with four items and copies
						the value of the third item to the variable $1: </para>
					<programlisting role="uniface"><![CDATA[; initialize list
; valrep is "rms<emphasis role="underline">;</emphasis>ora"
; valrep is "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb"
; valrep is "rms<emphasis role="underline">;</emphasis>ora<emphasis role="underline">;</emphasis>syb<emphasis role="underline">;</emphasis>rdb"
; "syb" copied to $1
$valrep(DBMSFLD) = "rms"
putitem $valrep(DBMSFLD), -1, "ora"
putitem $valrep(DBMSFLD), -1, "syb"
putitem $valrep(DBMSFLD), -1, "rdb"
getitem $1, $valrep(DBMSFLD), 3
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Building an Associative List </title>
					<para>The following example builds an associative list with four items. It then
						looks for an item whose value is 'tue' and copies the representation of that
						item to the variable $1. In addition, it copies the representation of the
						item whose value is 'weekend' to $2. Finally, assuming that the $2 now
						contains a list, it copies the first item in that list to $3. </para>
					<programlisting role="uniface"><![CDATA[; initialise list
; valrep is "mon=monday<emphasis role="underline">;</emphasis>tue=tuesday<emphasis role="underline">;</emphasis>wed=wednesday<emphasis role="underline">;</emphasis>weekend=sat<emphasis role="underline">!;</emphasis>sun"
; copy "tuesday" to $1
; copy "sat<emphasis role="underline">;</emphasis>sun" to $2
; copy "sat" to $3
$valrep(DATEFLD) = "mon=monday"
putitem/id $valrep(DATEFLD), "tue", "tuesday"
putitem/id $valrep(DATEFLD), "wed", "wednesday"
putitem/id $valrep(DATEFLD), "weekend", "sat<emphasis role="underline">;</emphasis>sun"
getitem/id $1, $valrep(DATEFLD), "tue"
getitem/id $2, $valrep(DATEFLD), "weekend"
getitem $3, $2, 1]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.putlistitems">
				<title>putlistitems</title>
				<para>Copy data from a specified source to the items of a list. </para>
				<sect2>
					<title>Syntax</title>
					<para>Put one field from successive occurrences into list items: </para>
					<para>putlistitems List , Field </para>
					<para>Put one or two fields from successive occurrences into list items: </para>
					<para>putlistitems/id List , {SourceValue}, SourceRepresentation </para>
					<para>putlistitems/id List , SourceValue </para>
					<para>Put fields of current occurrence into list items: </para>
					<para>putlistitems/occ{/modonly} List , Entity </para>
					<para>Fill representation part of list items: </para>
					<para>putlistitems/id{/field | /component | /global} List </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/id—copy the contents of one or two fields from successive
								occurrences into the items of a list </para>
						</listitem>
						<listitem>
							<para>/occ—copy the names and contents of all fields of the specified
								component Entity into the items of an associative list </para>
						</listitem>
						<listitem>
							<para>/modonly—loads the values from a field only if the field data has
								been modified. </para>
						</listitem>
						<listitem>
							<para>/component, /field, /global—if the name of the value part of a
								list item does not include a dollar sign, the names are treated as
								the indicated source type </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>List—indexed or associative list </para>
						</listitem>
						<listitem>
							<para>Field, SourceValue, SourceRepresentation—literal field name, or a
								string, variable, function, or parameter that evaluates to a string
								containing the name. </para>
						</listitem>
						<listitem>
							<para>Entity—entity from which a list is to be built. Can be a string,
								or a field, variable, function, or parameter that evaluates to a
								string containing the name. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> No data was copied to the list</entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> Number of the items copied</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>putlistitems/id/global is allowed in form components (and in service and
						report components that are not self-contained). </para>
					<para>Other forms of putlistitems are allowed in form, service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The putlistitems statement copies items from the specified source and puts
						them in List. This statement can be used to put: </para>
					<itemizedlist>
						<listitem>
							<para>The contents of the field Field from successive occurrences of its
								entity into items of an indexed list. </para>
						</listitem>
						<listitem>
							<para>The contents of the fields SourceValue and SourceRepresentation
								from successive occurrences of the current entity into the value and
								representation of items (ValRep) in an associative list. </para>
						</listitem>
						<listitem>
							<para>The names and contents of the fields in the field list of the
								named Entity into the value and representation of items in an
								associative list. </para>
						</listitem>
						<listitem>
							<para>The contents of a group of fields and variables (that are
								identified by the value part of each item in an associative list)
								into the corresponding representation of that item. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Copying from Successive Occurrences</title>
					<para>When items are copied into a list from a field or pair of fields in
						successive occurrences of an entity, the first item of the list is copied
						from the current occurrence of the entity in the component and remaining
						items from the following occurrences of the entity in the component. The
						hitlist is completed if necessary. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> To ensure that the entire set of
						occurrences in the component is being addressed, make the first occurrence
						the current occurrence. </para>
					<para>When copying data from successive occurrences, if one of the fields
						specified occurs in an entity that is painted as an up entity, then the
						nearest outer entity that is painted as a down entity is used to control the
						movement of data from occurrences. If both of the fields specified are
						painted as up entities, the nearest outer entity of the first field controls
						the movement. </para>
				</sect2>
				<sect2>
					<title>No Switch Used to Build a New List</title>
					<para>To copy the contents of a single field from successive occurrences into
						the items of a list, use putlistitems with no switch. Starting with an empty
						List, each item is copied from the field named by Field from successive
						occurrences in the component of its entity. </para>
					<para>The argument Field should be one of the following: </para>
					<itemizedlist>
						<listitem>
							<para>The literal name of a field painted on the component. For example,
								INV_NBR. </para>
						</listitem>
						<listitem>
							<para>A string that evaluates to the name of a field. For example,
								"INV_NBR". </para>
						</listitem>
						<listitem>
							<para>A variable, function, or parameter that evaluates to a string that
								contains the name of a field. For example: <itemizedlist>
									<listitem>
										<para>$1, where $1 contains "INV_NBR". </para>
									</listitem>
									<listitem>
										<para>PARAM1, where PARAM1 contains "INV_NBR". </para>
									</listitem>
									<listitem>
										<para>$fieldname, where $fieldname contains "INV_NBR".
										</para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
					<para>If an unqualified field name is present, the current entity is used. (See
						Building a list from a field in successive occurrences, below.) </para>
				</sect2>
				<sect2>
					<title>/id Used to Build a New List</title>
					<para>To copy the contents of one or two fields from successive occurrences into
						the items of a list, use putlistitems with the /id switch and at least one
						of SourceValue and SourceRepresentation. The fields named by SourceValue and
						SourceRepresentation are used to build a new (associative) list in List. In
						this situation, if one of the switches /field, /component, or /global
						appears with /id, it is ignored. </para>
					<itemizedlist>
						<listitem>
							<para>If both SourceValue and SourceRepresentation are present, items in
								an associative list are created by copying the item values from the
								contents of the field identified by SourceValue and the item
								representations from the contents of the field identified by
								SourceRepresentation in successive occurrences of the current
								entity. </para>
							<para>For example, consider a case where there are three occurrences of
								entity ENT in a component. Field FLD1 in the three occurrences
								contains 'day1', 'day2', and 'day3', while FLD2 contains 'Mon',
								'Tue', and 'Wed'. The following statements build a list that
								contains those values and representations: </para>
<!-- DVO -->
<programlisting role="uniface"><![CDATA[
setocc "ENT", 1
putlistitems/id $LIST$, FLD1, FLD2 ;$LIST$ is "day1=Mon<GOLD>;day2=Tue<GOLD>;day3=Wed"
]]></programlisting>
						</listitem>
						<listitem>
							<para>If SourceValue is omitted, only the representations are copied.
								For example, if field FLD2 in three occurrences of entity ENT in a
								component contains 'Mon', 'Tue', and 'Wed', the following statements
								build a list that contains those representations: </para>
							<programlisting role="uniface"><![CDATA[
setocc "ENT", 1
putlistitems/id $LIST$,, FLD2 ;$LIST$ is <gold>;Tue<gold>;Wed"
]]></programlisting>
							<para>Notice that the following statements have the same effect: </para>
<programlisting role="uniface"><![CDATA[
setocc "ENT", 1 
putlistitems $LIST$, FLD2 ;$LIST$ is "Mon<gold>;Tue<gold>;Wed" 
]]></programlisting>
						</listitem>
						<listitem>
							<para>If SourceRepresentation is omitted, only the values are copied.
								For example, if field FLD1 in three occurrences of entity ENT in a
								component contains 'day1', 'day2', and 'day3', the following
								statements build a list that contains those values: </para>
<programlisting role="uniface"><![CDATA[
setocc "ENT", 1 
putlistitems/id $LIST$, FLD1 ;$LIST$ is "day1=<gold>;day2=<gold>;day3=" 
]]></programlisting>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>/occ Used to Build a New List</title>
					<para>To build an associative list that contains the names and contents of all
						fields of the specified Entity that are defined in the field list for that
						entity in the current component, use putlistitems with the /occ switch. </para>
					<para>For more information about defining the field list for a component entity
						see the example titled <emphasis role="italic">Building an associative list
							from fields in a named entity</emphasis> below.) </para>
					<para>The argument Entity should specify the entity from which a list is to be
						built as one of the following: </para>
					<itemizedlist>
						<listitem>
							<para>A string that evaluates to the name of an entity. For example,
								"INVOICES". </para>
						</listitem>
						<listitem>
							<para>A variable, function, or parameter that evaluates to a string that
								contains the name of an entity. For example: <itemizedlist>
									<listitem>
										<para>$1, where $1 contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>PARAM1, where PARAM1 contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>$entname, where $entname contains "INVOICES". </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
					<para>If the /modonly switch is used with the /occ switch, the values will only
						be loaded from a field if the field data has been modified (that is, if
						$fieldmod = 1). Field IDs from fields that have not been modified are
						removed from the list. </para>
				</sect2>
				<sect2>
					<title>/id to Update Representations of List Items</title>
					<para>To update the representation part of items in an associative list, use
						putlistitems with the /id switch, a List name and no further arguments. The
						representation for each item is updated from the source specified in the
						value part of that item. The value part of a list item can contain the name
						of a field, a component variable, a global variable, or a general variable.
						For example: </para>
<programlisting role="uniface"><![CDATA[
NAME = "Frodo"
$LOC_TOT$ = 14
$$GLOB_TOT = 329
$1 = -8
$LIST$ = "NAME<gold>;$LOC_TOT$<gold>;$$GLOB_TOT<gold>;$1"
putlistitems/id $LIST$ ;"NAME=Frodo<gold>;$LOC_TOT$=14<gold>;$$GLOB_TOT=329<gold>;$1=-8"
]]></programlisting>
					<para>For each item in List, if the field or variable named by the value cannot
						be found, the associated representation remains unchanged. </para>
					<para>If the value part of a list item does not contain a dollar sign ($), the
						source is assumed to be a field unless one of the source switches /field,
						/component, or /global is specified. (You can use the switch /local as a
						synonym for /component.) In this situation, component variables are still
						the target for the putlistitems statement; local variables are not used). If
						one of these source switches is used, names that do not include a dollar
						sign are treated as the selected source type. (If a name includes a dollar
						sign, it is treated as the type specified.) </para>
					<para>In the following example, a field NAME, a component variable $NAME$, and a
						global variable $$NAME are all available, as well as a field TOTAL and a
						component variable $TOTAL$: </para>
<programlisting role="uniface"><![CDATA[
NAME = "Field"
$NAME$ = "Component"
$$NAME = "Global"
TOTAL = 987.65
$TOTAL$ = 123.45
$LIST$ = "name<gold>;$total$"
putlistitems/id $LIST$ ;$LIST$ is"NAME=Field<gold>;$TOTAL$=123.45"
putlistitems/id/field $LIST$ ;$LIST$ is "NAME=Field<gold>;$TOTAL$=123.45"
putlistitems/id/component $LIST$ ;$LIST$ is "NAME=Component<gold>;$TOTAL$=123.45"
putlistitems/id/global $LIST$ ;$LIST$ is "NAME=Global<gold>;$TOTAL$=123.45"
]]></programlisting>
					<para>Although it is usually good practice to include the dollar signs ($) that
						form part of the variable name in each list item’s value, these must be
						omitted to take advantage of the power of the source switches. </para>
					<para>Because the list argument is evaluated at run time, you should consider
						the following points when you create the component: </para>
					<itemizedlist>
						<listitem>
							<para>The existence of the referenced objects (fields and variables)
								cannot be verified by the compiler </para>
						</listitem>
						<listitem>
							<para>Any referenced fields cannot be included in an Automatic field
								list </para>
						</listitem>
					</itemizedlist>
					<para>Be sure that all the fields that will be referenced are included in the
						entity's field list (by using All Fields or a User-Defined field list) and
						that all the component and global variables are defined.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the examples, the underlined semicolon ( <emphasis role="underline">;
						</emphasis>) represents the Uniface subfield separator (by default, GOLD
						;).</para>
				</sect2>
				<sect2>
					<title>Example: Building a List from a Field in Successive Occurrences </title>
					<para>The current component contains three occurrences of the entity CALENDAR.
						The field DAY in these three occurrences contains 'Monday', 'Tuesday', and
						'Wednesday'. The following example copies the contents of the field DAY from
						these occurrences into an indexed list contained in the component variable
						$LIST$: </para>
<programlisting role="uniface"><![CDATA[
; make first occurrence of CALENDAR current
; $LIST$ is "Monday<gold>;Tuesday<gold>;Wednesday"
setocc "CALENDAR", 1
putlistitems $LIST$, DAY.CALENDAR
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling an Associative List from Fields and Variables </title>
					<para>For each item in an associative list, the following example copies the
						representation of the item from the source identified by the value. The type
						of the source (that is, whether it is a field, component variable, or global
						variable) is derived from the value of the item. </para>
<programlisting role="uniface"><![CDATA[
$LIST$ = "day1<gold>;$day2$<gold>;$$day3<gold>;$9"
day1 = "Mon"
$day2$ = "Fri"
$$day3 = "Wed"
$9="Thu"
putlistitems/id $LIST$
; $LIST$ is "day1=Mon<gold>;$day2$=Fri<gold>;$$day3=Wed<gold>;$9=Thu"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling an Associative List from Fields in the Current
						Occurrence </title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item from the field (in the current entity)
						identified by the value of the item: </para>
<programlisting role="uniface"><![CDATA[
$LIST$ = "day1<gold>;day2<gold>;day3"
day1 = "Sun"
day2 = "Tue"
day3 = "Wed"
putlistitems/id/field $LIST$
; $LIST$ is "day1=Sun<gold>;day2=Tue<gold>;day3=Wed"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Filling an Associative List from Component Variables </title>
					<para>For each item in an associative list, the following example copies the
						representation part of the item from the component variable identified by
						the item value: </para>
<programlisting role="uniface"><![CDATA[
$LIST$ = "day1<gold>;$day2<gold>;day3"
$day1$ = "Sun"
$day2$ = "Tue"
$day3$ = "Wed"
putlistitems/id/component $LIST$
; $LIST$ is "day1=Sun<emphasis role="underline">;</emphasis>day2=Tue<emphasis role="underline">;</emphasis>day3=Wed"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Building an Associative List from a Pair of Fields in Successive
						Occurrences </title>
					<para>The current component contains three occurrences of the entity CALENDAR.
						The field NUM in these three occurrences contains 'd1', 'd2', and 'd3',
						while the field NAME contains 'Mon', 'Tue', and 'Wed'. The following example
						copies those values into an associative list contained in the component
						variable $LIST$: </para>
<programlisting role="uniface"><![CDATA[
setocc "CALENDAR", 1
; make first occurrence current
putlistitems/id $LIST$, NUM.CALENDAR, NAME.CALENDAR
; $list$ is "d1=Mon<gold>;d2=Tue<gold>;d3=Wed"</programlisting>
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Building an Associative List from Fields in a Named Entity </title>
					<para>If the entity WEEK is painted with three fields (DAY1, DAY2, and DAY3),
						the following example builds the value and representation of each list item
						from the names and contents of these fields: </para>
<programlisting role="uniface"><![CDATA[
DAY1.WEEK = "Mon"
DAY2.WEEK = "Tue"
DAY3.WEEK = "Wed"
putlistitems/occ $LIST$,"WEEK"
; $LIST$ is "day1=Mon<gold>;day2=Tue<gold>;day3=Wed"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Copying Fields from One Occurrence to Another </title>
					<para>The following example copies the fields from the first occurrence of MYENT
						to a new occurrence. You can use this technique to create a 'copy
						corresponding' feature in your Proc code. </para>
<programlisting role="uniface"><![CDATA[
; make first occurrence current
; put field values into the list
; create new occurrence
; put values into fields of new occ
setocc "MYENT", 1
putlistitems/occ $COPYFIELDS$, "MYENT"
creocc "MYENT", -1
getlistitems/occ $COPYFIELDS$ , "MYENT"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.putmess">
				<title>putmess</title>
				<para>Append text to the message frame. </para>
				<sect2>
					<title>Syntax</title>
					<para> putmess {MessageText} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>MessageText—string, or a field (or indirect reference to a field), a
						variable, or a function that evaluates to a string. If MessageText is
						omitted, an empty line is added to the message frame. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in form, service, session service, entity service, and report
						components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The putmess statement appends MessageText to the text already present (if
						any) in the message frame. (The contents of the message frame are available
						to the application with the function $putmess.) </para>
					<para>The putmess statement is ignored in an Asynchronous Interrupt trigger if
						the user is currently in the message frame when the Asynchronous Interrupt
						trigger is activated. </para>
					<para>You can dump the contents of the message frame to a file when you are in
						the Proc debugger. </para>
				</sect2>
				<sect2>
					<title>Batch Mode</title>
					<para>In batch mode, the putmess statement writes the message directly to the
						screen or batch log file, depending on your operating system settings.
					</para>
				</sect2>
				<sect2>
					<title>Example: Putting Message Information in the Message Frame </title>
					<para>The following example shows how the putmess statement is used to put
						message information in the message frame: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Execute
CUSTNAME.CUSTOMER = $1
COUNTRY.CUSTOMER = $2
retrieve
if ($status &lt; 0)
   putmess "Retrieve problem. No printout."
   apexit ; end application
else
   print "SALESLASER","A"
   putmess "Printout sent to LaserJet II"
endif
]]></programlisting>
					<para>For an example of how to dump the contents of the message frame to a
						timestamped file, see the macro statement. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.read">
				<title>read</title>
				<para>Fetch an occurrence of the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para>read{/lock} %\ </para>
					<para>{using Index | options "{index= n} }{ <emphasis role="underline">;
						</emphasis>maxhits= n }{ <emphasis role="underline">; </emphasis>cache= n |
						ALL }{ <emphasis role="underline">; </emphasis>step= n "} }%\ </para>
					<para>{u_where (SelectionCriteria) | where DMLStatement | u_condition
						(Condition)} %\ </para>
					<para>{order by OrderBySpecs} </para>
				</sect2>
				<sect2>
					<title>Switches and Clauses</title>
					<para><itemizedlist>
							<listitem>
								<para>/lock—locks the occurrence when it is read, if the DBMS
									supports this feature. The Lock trigger is not activated when
									the /lock switch is used. </para>
							</listitem>
							<listitem>
								<para>using—specifies which index Uniface should use for
									record-level DBMSs; ignored for field-level DBMSs. Check the
									appropriate DBMS connector documentation to verify that the
									using clause is available for your DBMS. </para>
							</listitem>
							<listitem>
								<para>options—specifies gold-separated list of performance-related
									parameters when reading from a DBMS. <itemizedlist>
										<listitem>
											<para>index—index that Uniface should use for
												record-level DBMSs; equivalent to the using clause.
											</para>
										</listitem>
										<listitem>
											<para>maxhits—maximum number of hits that can be
												returned by a query. </para>
										</listitem>
										<listitem>
											<para>cache—maximum size (in bytes) of an occurrence
												that can be retrieved and placed in the select
												cache. If field length &lt; n, the complete
												occurrence is placed in select cache. If cache =
												ALL, all occurrences that do not have overflow or
												BLOBs can be retrieved and placed in the select
												cache. If the cache size is not specified, the
												default value is 512 bytes. </para>
										</listitem>
										<listitem>
											<para>step—step size of the query. If not set, the
												default value is 10. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
							<listitem>
								<para>u_where—specifies additional criteria by which records are to
									be read. It is inserted into the Select statement for the DBMS
									driver, in addition to any retrieve profiles generated by
									Uniface. For more information, see u_where </para>
							</listitem>
							<listitem>
								<para>where—passes the value of DMLStatement 'as is' to the DBMS.
									The DBMS must therefore support some form of DML, such as SQL,
									QUEL, or RDO. </para>
							</listitem>
							<listitem>
								<para>u_condition—provides a DBMS-independent profile for selection.
									For more information, see PROC-STATEMENT:ucondition </para>
							</listitem>
							<listitem>
								<para>order by—specifies the ordering sequence of the selected
									records. Works only on fixed-length fields that are stored in
									the database. <itemizedlist>
										<listitem>
											<para>desc—sort in descending order </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
						<emphasis role="bold"> Note:</emphasis> You can use either the using clause
						or the options clause. You cannot use both clauses within the same read
						statement. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Index—numeric expression that evaluates to the index number
								required. </para>
						</listitem>
						<listitem>
							<para>n—a number or numeric expression. </para>
						</listitem>
						<listitem>
							<para>ParamDef—parameter definitions are described below. </para>
						</listitem>
						<listitem>
							<para>SelectionCriteria—criteria for reading records. </para>
						</listitem>
						<listitem>
							<para>DMLStatement—string containing a DML statement, or a field (or
								indirect reference to a field), a variable, or a function that
								evaluates to the string. </para>
						</listitem>
						<listitem>
							<para>Condition— is described at u_condition. </para>
						</listitem>
						<listitem>
							<para>OrderBySpecs—comma-separated list containing one or more
								specifications of the form: </para>
							<para>LitFieldName {desc} </para>
							<para>The list can be a string, or a field (or indirect reference to a
								field), a variable, or a function that evaluates to the string.
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by read in $status</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Occurrence was successfully read. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> Record not found: end of file encountered. Or, no
											entities are painted on the component. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> Occurrence not found: table is empty. (Usually, the
											table or file is empty.) </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -4 </entry>
										<entry> Open request for table or file failed. The table or
											file is not painted, or it does not exist. </entry>
									</row>
									<row>
										<entry> -11 </entry>
										<entry> read/lock only: Occurrence already locked. </entry>
									</row>
									<row>
										<entry> -15 </entry>
										<entry> Uniface network error. </entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
									<row>
										<entry> -20 </entry>
										<entry> Nonexistent field in a u_where clause. </entry>
									</row>
									<row>
										<entry> -31 </entry>
										<entry> The TRX-formatted DML statement from a where clause
											exceeds 16 KB. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								read</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -11 </entry>
										<entry> &lt;UIOSERR_LOCKED&gt; </entry>
										<entry> read/lock only: Occurrence already locked. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -403 </entry>
										<entry> &lt;UMISERR_UWHERE&gt; </entry>
										<entry> Nonexistent field in a u_where clause. </entry>
									</row>
									<row>
										<entry> -404 </entry>
										<entry> &lt;UMISERR_TRX&gt; </entry>
										<entry> The TRX-formatted DML statement from a where clause
											or an sql statement exceeds 16 KB.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The read statement should be used only in the Read trigger. It fetches an
						occurrence from the hitlist and activates any field-level Decrypt triggers
						that contain Proc code. If necessary, it first builds the next step of the
						hitlist. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> A read statement can be quite long.
						Using the line continuation markers (%\) can improve the </para>
				</sect2>
				<sect2>
					<title>Using read/lock</title>
					<para>The optional /lock switch locks the occurrence when it is read, if the
						DBMS supports this feature. (This is called <emphasis role="italic">paranoid
							locking</emphasis>.) </para>
					<para>Using /lock eliminates the extra read action implicit in the normal lock
						statement and overrides <emphasis role="italic">optimistic
							locking</emphasis> in any DBMS. </para>
					<para>The Lock trigger is not activated when the /lock switch is used. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Locking actions, including the use
						of read/lock, are not supported by the TXT driver. </para>
				</sect2>
				<sect2>
					<title>where</title>
					<para>The where clause is DBMS-specific: the value of DMLStatement is passed 'as
						is' to the DBMS. This means that the DBMS must support some form of DML,
						such as SQL, QUEL, or RDO. To check whether the where clause is supported
						for your DBMS, see Data Retrieval Support. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The DML statement from the where
						clause is inserted into the Select connector function call (for the DBMS
						connector) in TRX format. The TRX-formatted data may be double the size of
						the original DML statement. This data is limited to 16 kilobytes.</para>
					<para>Since the DMLStatement is not parsed by Uniface, it is wise to check the
						return value of the read statement and, if necessary, the value of $dberror. </para>
					<para><emphasis role="bold"> Caution:</emphasis> Do not use local languages as
						part of the profile clause because Uniface interprets the local languages
						using an internal format. Use the u_where clause instead. </para>
					<para>Because subtypes are a Uniface feature, they are not understood by DBMSs.
						If you are using the field name bound to an entity name, the entity name
						must be either the supertype or omitted. </para>
				</sect2>
				<sect2>
					<title>u_where and where</title>
					<para>When a u_where or where clause is used on a read statement, all
						occurrences that match the selection criteria are read. If the entity is
						painted as an up (foreign) entity, the u_where or where clause is considered
						only if the foreign key is complete and not NULL. These clauses can be used
						to further restrict the number of occurrences read for the up entity. </para>
					<para>You can use the more general u_where clause, which is DBMS-independent.
					</para>
				</sect2>
				<sect2>
					<title>order by</title>
					<para>The order by clause specifies the ordering sequence of the selected
						records and is valid for all DBMSs. Each field name provided must be
						unqualified; for example, you can use the unqualified field name INVAMOUNT,
						but not the qualified field name INVAMOUNT.INVOICES. </para>
					<para>However, order by only works on fixed-length fields. Also, you cannot use
						a field that has been defined as part of an entity <emphasis role="italic"
							>but is not stored in the database </emphasis>to sort records in an
						order by clause. If you require records sorted on such a field, use the sort
						Proc statement. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> The compiler does not flag
						invalid fields as an error if you attempt it, nor does Uniface check for the
						existence of the field names in an order by clause. Using an unknown field
						name can cause unpredictable results in sorting.</para>
					<para>If you use an order by clause in combination with a DBMS that does not
						support ordering, Uniface retrieves and sorts all matching records. This can
						have a noticeable impact on performance. Additionally, when the component
						ends, the retrieved data must be dropped from memory. Consequently, the
						order by clause can affect performance not only for retrieval, but also when
						exiting the component. </para>
					<para>Not all DBMSs support descending sorts, so check the appropriate connector
						documentation to see if your DBMS supports this feature. </para>
				</sect2>
				<sect2>
					<title>Example: Reading and Sorting Occurrences </title>
					<para>The following example reads in occurrences from the component, ordering
						them by the INVOICE_MONTH field: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read read order by "INVOICE_MONTH"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Ordering Read Occurrences by a Dynamic Profile </title>
					<para>The following example defines the sort profile dynamically. The contents
						of the dummy field SORT_PROFILE specify by which field to order the
						occurrences: </para>
					<programlisting role="uniface"><![CDATA[; trigger Execute
if ($1="month")
   SORT_PROFILE.DUMMY = "INVOICE_MONTH"
else
   SORT_PROFILE.DUMMY = "INVOICE_AMOUNT"
endif]]></programlisting>
					<programlisting role="uniface"><![CDATA[; trigger: Read read order by SORT_PROFILE.DUMMY
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Reading and Sorting occurrences </title>
					<para>The following example uses order by to sort the records read: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read
$1 = "custnumber desc, invoice_date"
read order by $1]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: read u_where </title>
					<para>The following example returns all occurrences of the current entity for
						which no PAYDATE has been entered: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read read u_where (paydate = "") order by "invoice_amount"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: read where </title>
					<para>The following example retrieves occurrences of the entity INVOICE which
						have an INVAMOUNT greater than 100: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read (of entity "INVOICES")
read where "INVAMOUNT &gt; 100"
]]></programlisting>
					<para>You may have to qualify the name of the field with the entity name. This
						qualification is DML-specific. For example, if you were using an Ingres
						database, the QUEL statement in the where clause would be: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read (of entity "INVOICES")
read where "INVOICES.INVAMOUNT &gt; 100"
]]></programlisting>
					<para>If you had defined the entity INVOICES in the model as a subtype of the
						entity TRANSACT, you would have to use the supertype as a qualifier. This is
						because DBMSs do not recognize subtypes; subtypes are a Uniface feature. The
						previous example would therefore have to be rewritten as: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read (of entity "INVOICES")
read where "TRANSACT.INVAMOUNT &gt; 100"
]]></programlisting>
					<para>You can use the more general u_where clause, which is DBMS-independent.
						The previous example would then be rewritten as: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Read (of entity "INVOICES")
read u_where (INVOICES.INVAMOUNT &gt; 100)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.reconnect">
				<title>reconnect</title>
				<para> Introduced in: U9 </para>
				<para>Reconnect data loaded from an XML or JSON stream with the occurrences in a
					database or component. </para>
				<sect2>
					<title>Syntax</title>
					<para> reconnect {/readcheck} {EntityName} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/readcheck—for read-only fields, ignores any user modifications and
						restores the field value from database. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>EntityName—component entity; can be a string, or a field, variable,
						function, or parameter that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> Occurrence was successfully reconnected. </entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Number of errors retrieve/reconnect encountered. In
											this context, an error is defined as the number of times
											an On Error trigger returned a negative value. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Used after the xmlload or webload statements, reconnect resolves the
						occurrence state information stored in the processing information attributes
						of the XML stream. The procedure followed for each occurrence depends on the
						value of the XML status attribute for each occurrence in the XML stream. </para>
					<para>The reconnect statement merges all disconnected occurrences that have the
						XML states "", "new", "mod" and "del". Occurrences that have the XML state
						"est" are not be reconnected. This improves performance and avoids CRC
						errors on occurrences that were not modified in this session anyway. </para>
					<para>The XML ID attribute is used to merge disconnected occurrences with
						connected occurrences. Duplicate key checks are not done by reconnect. CRC
						checks are done for every merged occurrence. </para>
					<para>Depending on the value of the XML status attribute, as set in $occstatus,
						Uniface modification flags are set or reset.</para>
					<table>
						<title>Table 2. Effect of XML status Attribute on Uniface Modification
							Flags</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> $occstatus </entry>
									<entry> $occmod </entry>
									<entry> $storetype </entry>
									<entry> $occdel </entry>
									<entry> Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> "" </entry>
									<entry> 1 </entry>
									<entry> 1 </entry>
									<entry> 0 </entry>
									<entry> Treated as a new occurrence</entry>
								</row>
								<row>
									<entry> "new" </entry>
									<entry> 1 </entry>
									<entry> 1 </entry>
									<entry> 0 </entry>
									<entry> New occurrence</entry>
								</row>
								<row>
									<entry> "est" </entry>
									<entry> 0 </entry>
									<entry> 0 </entry>
									<entry> 0 </entry>
									<entry> Existing unmodified occurrence</entry>
								</row>
								<row>
									<entry> "mod" </entry>
									<entry> 1 </entry>
									<entry> 0 </entry>
									<entry> 0 </entry>
									<entry> Existing modified occurrence</entry>
								</row>
								<row>
									<entry> "del" </entry>
									<entry> X </entry>
									<entry> X </entry>
									<entry> 1 </entry>
									<entry> Marked as deleted occurrence</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The Uniface modification flags of all fields in an occurrence get the same
						modification state. All modified occurrences and fields are flagged for
						validation ($occvalidation, $fieldvalidation, and so on). These flags can be
						reset in Proc. $formmod and $instancemod are recalculated. If no occurrences
						or fields have set modification flags, $formmod and $instancemod are reset
						again. All modified occurrences are locked in the database if the locking
						type is cautious.</para>
					<para>For more information, see Reconnect Process.</para>
				</sect2>
				<sect2>
					<title>Reconnecting Read-Only Fields</title>
					<para>Fields are marked as read-only if:</para>
					<itemizedlist>
						<listitem>
							<para>The field syntax definition specifies NED (no edit allowed)
							</para>
						</listitem>
						<listitem>
							<para>The field syntax has been changed to NED at runtime by the
								fieldsyntax or $fieldsyntax Proc instructions. </para>
						</listitem>
					</itemizedlist>
					<para>When the /readcheck switch is used in a reconnect process, any
						modifications made by the user to a read-only field are ignored and the
						field value is restored from the database. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.refresh">
				<title>refresh</title>
				<para>Redraw the screen. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$refresh</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The refresh statement causes Uniface to repaint the current form. The
						principle use is after a spawn statement to clean up the screen. This
						statement has the same effect as the user using the structure editor
						function ^REFRESH. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> This function has no effect when
						running your application under a GUI. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example under OpenVMS uses the spawn statement to list all
						the directories, then uses refresh to redraw the screen: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
spawn "dir *.dir"
askmess "Press space bar to return."," ",-1
refresh ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.release">
				<title>release</title>
				<para>Release database controls. </para>
				<sect2>
					<title>Syntax</title>
					<para>release{/mod} </para>
					<para>release/e{/mod} {Entity} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/e—releases the controls for the current or specified entity.
								</para>
							</listitem>
							<listitem>
								<para>/mod—flags each released occurrence as modified. This ensures
									that these occurrences are inserted in the database at the next
									>store operation. If the primary key of each occurrence is not
									changed before the data is stored, a 'duplicate key' error will
									occur at the store operation. </para>
								<para><emphasis role="bold"> Note:</emphasis> The release/mod
									statement includes an implicit setocc "*",-1 to fetch all
									selected occurrences. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity whose controls are to be released. Can be a string, or a
						field, variable, function, or parameter that evaluates to a string
						containing the name. If omitted, the controls for the current entity
						($entname) are released. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by release in $status. If EntityName
								does not exist, $status is not set; $error is 0145, and the
								corresponding message is displayed. If EntityName does exist, the
								usual values returned in $status during database interaction apply. </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Data successfully released. </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								release</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The release statement releases the data in the component (for the fetched
						occurrences, $totocc) from database controls. Each occurrence is marked in
						the hitlist as a non-database occurrence. Used without the /e switch, all
						occurrences in the component are released. </para>
					<para>Uniface treats the released data as if it had just been entered by the
						user; in particular, this means that the primary key field can be modified.
						When the store statement is executed, occurrences modified by the user are
						inserted rather than updated. The release statement is sometimes used in the
						Clear trigger. </para>
					<para>Keep the following in mind when using release: </para>
					<itemizedlist>
						<listitem>
							<para>Any locked database occurrences are not unlocked; they remain
								locked until a commit or rollback is performed. </para>
						</listitem>
						<listitem>
							<para>An occurrence in the component that has been removed (for example,
								with the structure editor function ^REM_OCC), but not yet stored at
								the time of the release, remains in the hitlist and is available in
								the component. </para>
						</listitem>
					</itemizedlist>
					<para>
						<emphasis role="bold"> Note:</emphasis> Prior to Version 6, the first
						occurrence became the current occurrence following a release. Beginning with
						Version 6, the last fetched occurrence becomes the current occurrence
						following a release. It is a good idea to use setocc to establish the new
						current occurrence. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example checks to see if any data in the form has been
						retrieved from the database ($formdb equals 1). If so, it releases database
						controls on this data so that it can be modified and inserted as new
						occurrences. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Clear
if ($formdb = 1)
   release
   message "Control released; data available as default"
   return (0)
else
   clear
   return (0)
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.reload">
				<title>reload</title>
				<para>Reread and lock the current occurrence from the database. </para>
				<sect2>
					<title>Syntax</title>
					<para> reload{/nolock} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/nolock—reread the current occurrence without locking them in the
						database. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by reload in $status . If the occurrence
							exists, the usual values returned in $status during database interaction
							apply. </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Data successfully reloaded. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> Record not found: end of file encountered. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> Occurrence not found: table is empty. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							reload</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The reload statement reads the updated version of the current occurrence
						into the component and locks it in the database. This statement is used in
						combination with the lock statement to reload an occurrence from the
						database which has been modified by another user. It should only appear in
						the Lock trigger. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Neither reload nor reload/nolock is
						supported by the TXT driver. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example locks the record (with the lock statement) and if
						the record has been modified ($status is -10), performs a reload : </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Lock&gt;
lock
if ($status = -10)
reload
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.remocc">
				<title>remocc</title>
				<para>Mark an occurrence of the specified entity for deletion at the next store. </para>
				<sect2>
					<title>Syntax</title>
					<para> remocc Entity , OccurrenceNumber </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Entity—entity where an occurrence is to be removed. Can be a
								string, or a field, variable, function, or parameter that evaluates
								to a string containing the name. </para>
						</listitem>
						<listitem>
							<para>OccurrenceNumber—sequence number (in the component) of the
								occurrence to be removed; can be a constant, or a field (or indirect
								reference to a field), a variable, or a function that can be
								converted to a whole (integer) number; the value will be truncated
								to form an integer. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The values returned in $status following remocc are: </para>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0 </entry>
									<entry> Sequence number of the occurrence that became current
										after removing an occurrence. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							remocc</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1 </entry>
									<entry> &lt;UGENERR_ERROR&gt; </entry>
									<entry> An error occurred. Entity is the outer entity of a
										Record component. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> Entity is not a valid name or the entity is not painted
										on the component. </entry>
								</row>
								<row>
									<entry> -1203 </entry>
									<entry> &lt;UPROCERR_RANGE&gt; </entry>
									<entry> Value out of range. For example, OccurrenceNumber is
										greater than the number of occurrences of Entity.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The remocc statement removes an occurrence of Entity from the component
						and marks it for deletion during the next store operation. The occurrence
						will be found if a retrieve/o is used; in this case, retrieve/o sets $status
						to 3. </para>
					<para>If OccurrenceNumber is: </para>
					<itemizedlist>
						<listitem>
							<para>&lt; 0, the last occurrence in the component structure is removed.
							</para>
						</listitem>
						<listitem>
							<para>0, the current occurrence of Entity is removed (default). </para>
						</listitem>
						<listitem>
							<para>Greater than the number of occurrences of Entity, $status is set
								to -1 and no occurrence is removed. </para>
						</listitem>
					</itemizedlist>
					<para>The behavior following remocc is governed by the location of the removed
						occurrence: </para>
					<itemizedlist>
						<listitem>
							<para>If the removed occurrence is not the last occurrence, the
									<emphasis role="italic">next</emphasis> occurrence is made
								active after a remocc. </para>
						</listitem>
						<listitem>
							<para>If the removed occurrence is the last occurrence, the <emphasis
									role="italic">previous</emphasis> occurrence is made active
								after remocc. </para>
						</listitem>
						<listitem>
							<para>If the component contains only one occurrence, that occurrence is
								removed and a new, empty occurrence becomes the <emphasis
									role="italic">current</emphasis> occurrence. </para>
						</listitem>
					</itemizedlist>
					<para>If you want to filter out occurrences that you have retrieved but do not
						want to process, rather than using a remocc statement, you should use the
						discard statement or the u_where clause with the read statement. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The remocc statement sets the
						current entity, causing a change in the active path. This can result in the
						structure editor activating certain data validation triggers. </para>
				</sect2>
				<sect2>
					<title>Example: Removing Occurrences </title>
					<para>The statements in the following example remove the current occurrence of
						the CUSTOMER entity if the INVAMOUNT field is less than or equal to 0: </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Leave Modified Occurrence&gt;
if (INVAMOUNT &lt;= 0)
   remocc "CUSTOMER", 0
   message "Customer with no debt removed."
endif
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.repeat">
				<title>repeat</title>
				<para>Define a repeat/until loop. </para>
				<sect2>
					<title>Syntax</title>
					<para>repeat </para>
					<para> ... one or more Proc statements ... </para>
					<para>until (Condition) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Condition—boolean expression that must evaluate to TRUE before the repeat
						loop can end. Uniface performs implicit data type conversion if the
						expression is of a data type other then Boolean. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The repeat statement does not affect $status. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The repeat statement loops through the Proc statements that follow it
						until the Condition on the until clause is evaluated as TRUE (that is,
						nonzero). Uniface then leaves the loop and continues with the statement
						following the until clause (if any). </para>
					<para>You are advised to indent all statements between the repeat and
						corresponding until. Use the break statement to terminate a repeat/until
						loop early. </para>
					<para>Conditional statements such as if/endif, while/endwhile, and repeat/until
						can be nested up to 32 levels. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the repeat statement. The example
						loops through all the occurrences of entity E1, until it finds an occurrence
						where the values of the fields F2 and NAMEDUMMY are the same, or until all
						the occurrences have been checked. </para>
					<programlisting role="uniface"><![CDATA[; (where F2.E1 is a character string field
; containing a name)
; loop until field matches or
; setocc is out of occurrences
; trigger: Help
; field: NAMEDUMMY.E1
if (F2.E1 != NAMEDUMMY)
   $CURR_OCC$ = $curocc
   $NAME$ = NAMEDUMMY
   $COUNTER$ = 1
   repeat
      setocc "E1", $COUNTER$
      $COUNTER$ = ($COUNTER$ + 1)
		until ((f2.E1 = $NAME$) | ($status &lt; 0))
		if ($status &lt; 0)
		   message "%%$NAME$%%% is not available."
			setocc "E1", $CURR_OCC$
			return (-1)
		endif
endif
$prompt = F2.E1
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.reset">
				<title>reset</title>
				<para>Reset the value of the specified Proc function to 0. </para>
				<sect2>
					<title>Syntax</title>
					<para>reset LitProcFunctionName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>LitProcFunctionName—literal name of a Proc function, including the leading
						dollar sign ($). </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0 </entry>
										<entry> reset cannot be used with LitProcFunctionName
										</entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> LitProcFunctionName was successfully reset. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page and form components (and in service,
						session service, entity service, and report components that are not
						self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The reset statement resets the value of the Proc function
						LitProcFunctionName to FALSE (0). It can be used only with functions where
						this is indicated in the Synopsis. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example sets the CITY field in a form, then resets the
						component instance modification indicator, $instancemod: </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Execute&gt;
city = "New Orleans"  ; this sets $instancemod to 1
reset $instancemod
edit NAME
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.retrieve">
				<title>retrieve</title>
				<para>Activate the Read trigger for the first outermost entity and all related
					entities, or for a specific entity. </para>
				<sect2>
					<title>Syntax</title>
					<para>retrieve{/&lt;switch> {Entity}} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/e—activates the Read trigger of the current entity ($entname) or of
						Entity. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity to be retrieved. Can be a string, or a field, variable,
						function, or parameter that evaluates to a string containing the name. If
						omitted, retrieve/e works only if there is an active entity. For example, in
						the Execute trigger of a component, the retrieve/e is in the Execute
						trigger. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by retrieve in $status . Since retrieve
								can activate Read triggers, the values in $status and $procerror
								after retrieve may have been set by the Proc code in the Read
								trigger. Keep this in mind when testing following a retrieve
								statement. </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Data was successfully retrieved. Or, no entities are
											painted on the component. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> Record not found: end of file encountered. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> Occurrence not found: table is empty. (No hits were
											found in the table or file.) </entry>
									</row>
									<row>
										<entry> -3 </entry>
										<entry> Exceptional I/O error (hardware or software).
										</entry>
									</row>
									<row>
										<entry> -4 </entry>
										<entry> Open request for table or file failed. The table or
											file is not painted, or it does not exist. </entry>
									</row>
									<row>
										<entry> -9 </entry>
										<entry> An attempt to open a DBMS failed because the maximum
											number of DBMS logons has already been reached. </entry>
									</row>
									<row>
										<entry> -15 </entry>
										<entry> The entity is painted as an up (foreign) entity and
											multiple hits were found during the database lookup.
										</entry>
									</row>
									<row>
										<entry> -16 </entry>
										<entry> Network error: unknown. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								retrieve</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> -4 </entry>
										<entry> &lt;UIOSERR_OPEN_FAILURE&gt; </entry>
										<entry> The table or file could not be opened. The entity is
											not painted or the corresponding table or file does not
											exist in the database. </entry>
									</row>
									<row>
										<entry> -9 </entry>
										<entry> &lt;UIOSERR_LOGON_ERROR&gt; </entry>
										<entry> DBMS logon error; for example, the maximum number of
											DBMS logons has already been reached. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -35 </entry>
										<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
										<entry> A trigger returned a negative value in $status.
										</entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Without the /e switch, the retrieve statement activates the Read trigger
						of the first outermost entity on the component. If the /e switch is
						included, it activates the Read trigger of the current entity ($entname) or
						of Entity. In either case, activating the Read trigger causes the Read
						triggers of any inner entity to be activated. Any previously built hitlists
						are discarded. </para>
					<para>If a retrieve statement is used in a Retrieve trigger, the Read triggers
						that it activates depend on the profile supplied by the user or by Proc code
						in the Retrieve trigger. If a specific primary key value for an outer entity
						is supplied, only the Read trigger of a single outer entity (and all its
						inner entities) is activated. </para>
					<para>The retrieve statement activates the Read triggers only for entities
						painted on the screen. As a result, the retrieve statement does not fetch
						all the occurrences in the hitlist, only enough occurrences to populate the
						component with data. (This functionality is influenced by the select cache
						mechanism.) To retrieve all the occurrences into the component, you need,
						use a setocc "*",-1. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> A setocc "*",-1 has drastic
						consequences if the user issues an ^ERASE on a form component.</para>
					<para>You cannot use a Uniface variable-length field to provide the selection
						criteria. This also applies to any fields in the variable portion of an
						entity. </para>
					<para>A retrieve statement in the Retrieve Sequential trigger behaves exactly
						the same as one in the Retrieve trigger. However, the Retrieve Sequential
						trigger is only activated when a component has Record behavior. This type of
						component only allows one occurrence of the outer entity. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows some Proc code that uses the retrieve/e
						statement to display an unrelated entity. </para>
					<para>In the form in the following illustration, there is no direct relationship
						between occurrences in B and occurrences in C. However, occurrences in C
						share a common foreign key with occurrences in B. </para>
					<para> Figure 1. Unrelated inner entities</para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_7.jpg"/>
						</imageobject>
					</mediaobject>
					<para>In the Occurrence Gets Focus trigger of entity C, there is a retrieve/e
						statement to display the relevant occurrence of B. This can be necessary
						when there is no direct relationship between two inner entities. </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Occurrence Gets Focus&gt;
; Set up foreign key in other entity (entity C)
; and then get the correct occurrence of B
PRODUCT_VERSION.B = PRODUCT_VERSION.C
retrieve/e "B"
]]></programlisting>
					<para>If you have painted two or more unrelated outer entities, you will need to
						include additional retrieve statements. The single default retrieve
						statement will only cause the first outer entity (and its related entities)
						to be retrieved. To retrieve any other outer entities, you need to include
						additional retrieve/e statements in the Retrieve trigger. The following
						figure illustrates this: </para>
					<para>Figure 2. Unrelated outer entities</para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_8.jpg"/>
						</imageobject>
					</mediaobject>
					<para>When the Retrieve trigger is activated, the default single retrieve
						statement only retrieves data from entity A. To retrieve data for entities B
						and C, the following Proc code should be placed in the Retrieve trigger: </para>
					<programlisting role="uniface"><![CDATA[trigger _retr
retrieve
if ($status &lt;0)
   message "Retrieve did not succeed; see message frame"
endif
retrieve/e "B"
if ($status &lt;0)
   message "Retrieve on B did not succeed; see message frame"
endif
end ; retrieve trigger
]]></programlisting>
					<para>This will ensure that the form is correctly populated with data when the
						^RETRIEVE structure editor function is activated. Be aware that the Proc
						compiler will generate the warning that there is no path to entity B. It is
						your responsibility to define this path if it is required. </para>
					<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>...</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.retrieve_a">
				<title>retrieve/a</title>
				<para>Retrieve multiple additional occurrences of the specified entity without
					discarding the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para>retrieve/a {Entity} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/a—uses the current occurrence of Entity as a profile to retrieve multiple
						occurrences matching that profile statement. It is an extension of the
						retrieve/x statement. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity for which additional occurrences are to be retrieved. Can be
						a string, or a field, variable, function, or parameter that evaluates to a
						string containing the entity name. If omitted, the current entity is used.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. Since retrieve/a can activate Read triggers, the
											values in $status and $procerror after retrieve/a might
											have been set by the Proc code in the Read trigger. Keep
											this in mind when testing following a retrieve/a
											statement. </entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Success. Number of occurrences that match the
											retrieve/a profile occurrence.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								retrieve/a</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
										<entry> Errors during database I/O. </entry>
									</row>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>When using the retrieve/a statement, you need to create a separate
						occurrence for the new retrieve profile. </para>
					<para>Uniface searches for the occurrence in the following way: </para>
					<orderedlist>
						<listitem>
							<para>If the currently active hitlist is stepped and not yet completed,
								it is completed first. </para>
						</listitem>
						<listitem>
							<para>A where clause is generated based on the retrieve profile (the
								current occurrence of Entity). A database query for retrieving
								multiple records is executed. </para>
						</listitem>
						<listitem>
							<para>The hits from the new hitlist returned by the DBMS are added to
								the existing hitlist. </para>
						</listitem>
						<listitem>
							<para>The retrieve profile occurrence is deleted. </para>
						</listitem>
						<listitem>
							<para>The extended hitlist is completed if it was stepped. </para>
						</listitem>
						<listitem>
							<para>Duplicate entries from the hitlist are removed. </para>
						</listitem>
						<listitem>
							<para>The first newly added occurrence is loaded. </para>
						</listitem>
					</orderedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example retrieves occurrences with a new profile using
						retrieve/a : </para>
					<programlisting role="uniface"><![CDATA[clear
PK = 1
retrieve
creocc ; create occurrence for profile
PK = "&gt;10"
retrieve/a ; retrieve ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.retrieve_o">
				<title>retrieve/o</title>
				<para>Attempt to locate an occurrence of an entity using the current primary key
					value. </para>
				<sect2>
					<title>Syntax</title>
					<para>retrieve/o {Entity} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity where an occurrence is to be located. Can be a string, or a
						field, variable, function, or parameter that evaluates to a string
						containing the name. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by retrieve/o in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 4 </entry>
									<entry> The occurrence was found in the component. The current
										occurrence is removed and the cursor repositioned on the
										found occurrence. </entry>
								</row>
								<row>
									<entry> 3 </entry>
									<entry> The occurrence was found among the removed occurrences;
										it was unremoved. </entry>
								</row>
								<row>
									<entry> 2 </entry>
									<entry> The entity is painted as an up (foreign) entity and one
										hit was found in the database. </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> The entity is painted as an up (foreign) entity with
										code in the Write Up trigger and the key value was not found
										during the database lookup. It is assumed that this is a new
										occurrence. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> A new occurrence was created. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> Record not found: end of file encountered. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> The entity is painted as an up (foreign) entity and the
										key value was not found during the database lookup. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> Open request for table or file failed. The table or file
										is not painted, or it does not exist. </entry>
								</row>
								<row>
									<entry> -7 </entry>
									<entry> The key exists in the database but was not found in the
										hitlist. This occurs when the user tries to enter a
										duplicate key. </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -14 </entry>
									<entry> The entity is painted as a normal down entity and
										multiple hits were found during the database lookup
										(ambiguous key). </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> The entity is painted as an up (foreign) entity and
										multiple hits were found during the database lookup.
									</entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							retrieve/o</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> &lt;UIOSERR_OCC_NOT_FOUND&gt; </entry>
									<entry> The entity is painted as an up entity and the key value
										was not found during the database lookup. </entry>
								</row>
								<row>
									<entry> -7 </entry>
									<entry> &lt;UIOSERR_DUPLICATE_KEY&gt; </entry>
									<entry> The key exists in the database but was not found in the
										hitlist. This occurs when the user tries to enter a
										duplicate key. </entry>
								</row>
								<row>
									<entry> -14 </entry>
									<entry> &lt;URETERR_MULTIPLE_DOWN&gt; </entry>
									<entry> The entity is painted as a normal down entity and
										multiple hits were found during the database lookup
										(ambiguous key). </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> &lt;URETERR_MULTIPLE_UP&gt; </entry>
									<entry> The entity is painted as an up entity and multiple hits
										were found during the database lookup. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The retrieve/o statement tries to find an occurrence with the current
						primary key, both in the DBMS and in the component. If the primary key data
						is not available, it tries to find an occurrence using the candidate key
						data, if available. You should use the retrieve/o statement in the Leave
						Modified Key trigger, where it can be used instead of a lookup statement. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The retrieve/o statement does not
						activate the Read trigger of an entity. By definition, it makes the
						retrieved occurrence current. If no primary key fields are painted, the
						retrieve/o statement positions the cursor at an arbitrary place. </para>
					<para>If an entity is defined as non-database, retrieve/o does not search the
						component for an occurrence. If this is required, define the entity as
						stored in a database, but remove the write statement from the Write or Write
						Up triggers for the entity. This should be done in the application model.
						This ensures that an entity does not get stored in the database, and has the
						same effect as defining the entity as non-database. </para>
					<para>When the retrieve/o statement is executed, Uniface searches for the
						occurrence in the following way: </para>
					<orderedlist>
						<listitem>
							<para>It inspects the component. If Uniface finds a matching occurrence,
								the current occurrence is removed and the cursor scrolls forward or
								backward to the found occurrence. If the occurrence was removed, it
								is unremoved, unless the profile contained a wildcard. </para>
						</listitem>
						<listitem>
							<para>If Uniface does not find a matching occurrence in the component,
								the entire hitlist is inspected. If it finds a match in the hitlist,
								occurrences are fetched until the matching occurrence is found. If
								the occurrence is not found in the hitlist, but it is present in the
								database, $status is set to -7. </para>
						</listitem>
					</orderedlist>
					<para>The above steps are equivalent to Uniface doing a setocc to the
						appropriate occurrence. </para>
					<para>The Leave Modified Key trigger often contains a retrieve/o statement to
						prevent the user from entering a primary key value which is already in use.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the default Proc code present in the Leave
						Modified Key trigger. Note that a retrieve/e statement is used if a single
						occurrence is found in an up entity. The example shows the use of checks on
						$status to determine the result of a retrieve/o statement: </para>
					<programlisting role="uniface"><![CDATA[retrieve/o
if ($status &lt; 0)
if ($status=-15) message $text(2202);Multiple hits: in foreign entity
if ($status=-14) message $text(2205);Multiple hits: not in foreign entity
   if ($status=-11) message $text(2009);Occurrence currently locked
   if ($status=-7) message $text(2006);Duplicate key
   if ($status=-4) message $text(2003);Cannot open table or file
   if ($status=-3) message $text(2002);Exceptional I/O error
   if ($status=-2) message $text(2200);Key not found:in foreign entity
else
   if ($status=1) message $text(2201);Key not found:foreign entity w/WRITE UP
   if ($status=2);One occurrence found in foreign entity
      retrieve/e
      if ($status &lt; 0) message $text(2002);I/O error detected
   endif
   if ($status=3) message $text(2203);Occurrence un-removed
   if ($status=4) message $text(2204);Key found:occurrence repositioned
endif
return ($status)]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.retrieve_reconnect">
				<title>retrieve/reconnect/o</title>
				<para> Introduced in: U8 </para>
				<para>Reconnect data loaded from an XML stream with the occurrences in a database or
					component. </para>
				<sect2>
					<title>Syntax</title>
					<para>retrieve/reconnect {EntityName} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>EntityName—entity painted on the component. Can be a string, or a field,
						variable, function, or parameter that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> Occurrence was successfully reconnected. </entry>
									</row>
									<row>
										<entry> &gt;0</entry>
										<entry> Number of errors retrieve/reconnect encountered. In
											this context, an error is defined as the number of times
											an On Error trigger returned a negative value. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Used after an xmlload, retrieve/reconnect resolves the occurrence state
						information stored in the processing information attributes of the XML
						stream. The procedure followed for each occurrence depends on the value of
						the status attribute, described in the following paragraphs, for each
						occurrence in the XML stream. </para>
				</sect2>
				<sect2>
					<title>Example: Receiving an XML Stream</title>
					<para>The following code shows an operation that receives an XML stream, and
						loads the data from the XML into the component’s data structure. </para>
					<programlisting role="uniface"><![CDATA[operation XMLIN
; This operation receives and
; reconnects an XML stream.
params
   xmlstream [DTD:ABCDTD.ABC] MYSTREAM : IN
endparams
clear
xmlload MYSTREAM, "DTD:ABCDTD.ABC"
retrieve/reconnect
...
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.retrieve_x">
				<title>retrieve/x</title>
				<para>Retrieve an additional occurrence of the specified entity without discarding
					the hitlist. </para>
				<sect2>
					<title>Syntax</title>
					<para>retrieve/x Entity </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity for which additional occurrences are to be retrieved. Can be
						a string, or a field, variable, function, or parameter that evaluates to a
						string containing the name. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The values returned in $status following retrieve/x are: </para>
					<table>
						<title>Table 1. Values returned by retrieve/x in $status . The retrieve/x
							statement can set $status; however, since retrieve/x can activate Read
							triggers, the value in $status after retrieve/x can have been set by the
							Proc code in the Read trigger. </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 5 </entry>
									<entry> One hit was found in the database. </entry>
								</row>
								<row>
									<entry> 4 </entry>
									<entry> The occurrence was found in the component. The current
										occurrence is removed and the cursor repositioned on the
										found occurrence. </entry>
								</row>
								<row>
									<entry> 3 </entry>
									<entry> The occurrence was found among the removed occurrences;
										it was unremoved. </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> The entity is painted as an up (foreign) entity with
										code in the Write Up trigger and the key value was not found
										during the database lookup. It is assumed that this is a new
										occurrence. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> The occurrence does not exist. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -14 </entry>
									<entry> The entity is painted as a normal down entity and
										multiple hits were found during the database lookup
										(ambiguous key). </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> The entity is painted as an up (foreign) entity and
										multiple hits were found during the database lookup.
									</entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							retrieve/x</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -14 </entry>
									<entry> &lt;URETERR_MULTIPLE_DOWN&gt; </entry>
									<entry> The entity is painted as a normal down entity and
										multiple hits were found during the database lookup
										(ambiguous key). </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> &lt;URETERR_MULTIPLE_UP&gt; </entry>
									<entry> The entity is painted as an up entity and multiple hits
										were found during the database lookup. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The retrieve/x statement allows you to retrieve an additional occurrence
						of an entity without discarding the current hitlist. This is useful when you
						want to retrieve an occurrence that does not match the profile provided, but
						which is still related to occurrences already fetched. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If there is a partially completed
						stepped hitlist, it is completed before the new occurrence is
						retrieved.</para>
					<para>The retrieve/x statement tries to find an occurrence with the current
						primary key, (not the candidate key) both in the DBMS and in the component.
						Uniface searches for the occurrence in the following way: </para>
					<orderedlist>
						<listitem>
							<para>It inspects the component. If Uniface finds a matching occurrence,
								the current occurrence is removed and the cursor scrolls forward or
								backward to the found occurrence. If that occurrence was removed, it
								is put back, unless the profile contained a wildcard. </para>
						</listitem>
						<listitem>
							<para>If Uniface does not find a matching occurrence in the component,
								the entire hitlist is inspected: <itemizedlist>
									<listitem>
										<para>If it finds a match in the hitlist, occurrences are
											fetched until the matching occurrence is found. </para>
									</listitem>
									<listitem>
										<para>If the occurrence is not found in the hitlist, but is
											present in the database, the occurrence is loaded and
											added to the hitlist. (The Read trigger is activated to
											fetch the occurrence into the component.) If Entity is
											painted as a down entity, the new occurrence is added to
											the hitlist even if it is not related to the up entity.
										</para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</orderedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting></para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.return">
				<title>return</title>
				<para>Exit from the Proc module, optionally returning a value to $status. </para>
				<sect2>
					<title>Syntax</title>
					<para>return {Expression} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Expression—expression that evaluates to a numeric value; this value is
						placed in $status. To improve readability, parentheses (()) are often
						included as a part of Expression. Return Values </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Expression is not present.</entry>
								</row>
								<row>
									<entry> &gt;0 </entry>
									<entry> Value of Expression </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>$procerror is 0. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The return statement exits from the Proc module. </para>
					<para>If you use Expression to return a status, you should be aware that In many
						triggers, returning a negative value causes the cursor to remain in the
						field. For more information, see the descriptions of the individual
						triggers</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the return statement to prevent the user from
						quitting a modified form without confirming the action: </para>
					<programlisting role="uniface"><![CDATA[; trigger Quit
; check for modifications: if no changes
; end and set $status = 0
; return (-1) prevents user from leaving form
if ($formmod = 0)
   return
else
   askmess "Data modified! Do you want to store? (Y/N)"
   if ($status = 1)
      store
      if ($status &lt; 0)
         message "Store error number %%$status%%%"
         return (-1)
      endif
   else
      return (0) ;leave form without storing
   endif
endif
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.returns">
				<title>returns</title>
				<para> Introduced in: U8 </para>
				<para>Define the returned data type of a Proc module. </para>
				<sect2>
					<title>Syntax</title>
					<para>returns DataType </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>DataType—any Uniface datatypes. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The returns statement does not affect $status. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The returns Proc statement defines the returned data type of a Proc
						module. It should be placed before the Params block. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following code is an example of how to code for the Proc statement
						returns: </para>
					<programlisting role="uniface"><![CDATA[entry MULTIPLY
returns numeric
params
   numeric PAR1 : IN
   numeric PAR2 : IN
endparams
variables
   numeric MULTIPLYRESULT
endvariables
MULTIPLYRESULT = PAR1 * PAR2
return MULTIPLYRESULT
end ; MULTIPLY
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.rollback">
				<title>rollback</title>
				<para>Undo the transaction (if supported by DBMS). </para>
				<sect2>
					<title>Syntax</title>
					<para>rollback {" PathString "} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>PathString—string constant that contains the required path name: </para>
					<itemizedlist>
						<listitem>
							<para>If PathString starts with a dollar sign ($), the argument is
								assumed to be a path name. Updates to all entities accessed through
								that path are committed. In this case, assignments determine which
								entities are rolled back. </para>
						</listitem>
						<listitem>
							<para>Otherwise, the argument is assumed to be a DBMS (driver path)
								defined in the application model. Updates to all entities assigned
								to that DBMS are rolled back. In this case, the model definition
								determines which entities are rolled back. </para>
						</listitem>
					</itemizedlist>
					<para>If PathString is omitted, all updates made by the transaction to all DBMSs
						are rolled back. If the target DBMS does not support rollback, this
						statement is ignored. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by rollback in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Data was successfully rolled back. </entry>
								</row>
								<row>
									<entry> &lt; 0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -9 </entry>
									<entry> An attempt to open a DBMS failed because the maximum
										number of DBMS logons has already been reached. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							rollback</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -1107 </entry>
									<entry> &lt;UPROCERR_PATH&gt; </entry>
									<entry> The path name is not correct or the path does not exist,
										for example, no assignment is found for the path. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The rollback statement undoes all updates to the database made since the
						last commit or rollback was issued (or since the application started or the
						path was opened), and unlocks all occurrences. </para>
					<para>This statement is usually used when a store or commit fails. </para>
					<para>To avoid currency problems, use rollback (or commit) at the highest level
						of the component tree for the current transaction, unless the component has
						the property Keep Data in Memory clicked <emphasis role="italic">on
						</emphasis>. In this case, you should use rollback at that level. The
						following illustration shows how to do this: </para>
					<para>Figure 1. Transaction control at the highest level of the component
						tree</para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_9.jpg"/>
						</imageobject>
					</mediaobject>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses rollback when a store statement fails: </para>
					<programlisting role="uniface"><![CDATA[; trigger Store
store
if ($status &lt; 0)
   message "Store error number %%$status."
   rollback
else
   message "Store done."
   commit
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.run">
				<title>run [DEPRECATED]</title>
				<para>Starts the specified form. </para>
				<warning>
					<para> The command <function>run</function> was replaced by <link
							linkend="langref.activate">
							<function>activate</function>
						</link> in Uniface 7. Due to the backward compatibillity the
							<function>run</function> statement still works in versions 7 and higher.
						However we strongly advise you to start using the <link
							linkend="langref.activate">
							<function>activate</function>
						</link> instead. </para>
					<para> Deprecated since: U7. </para>
				</warning>
				<sect2>
					<title>Syntax</title>
					<para>run {/display | /query} FormSpec{, VertPos , HorizPos{, VertSize ,
						HorizSize}} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/display—display the form as read-only. </para>
							</listitem>
							<listitem>
								<para>/query—displays the form as retrieve-only; that is, data can
									be entered into the fields, but only for a retrieve profile.
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>FormSpec—string, or field (or indirect reference to a field),
								variable, or function that evaluates to a string (maximim fo 32
								characters) containing the form file specification. If FormSpec does
								not include the complete file specification and the form is not
								located using an assignment, Uniface looks for the requested form in
								the current directory. </para>
						</listitem>
						<listitem>
							<para>VertPos, HorizPos, VertSize and HorizSize—position and size of the
								form, expressed as integers representing character cells from the
								upper left corner of the application window </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Sets $status to the value returned by the Execute trigger of the form that
						was started, if that trigger contains a return or exit statement. In this
						case, $procerror is 0. </para>
					<table>
						<title>Table 1. Values returned by run in $status . The default values
							returned by run (that is, if no return or exit statement is present) are
							shown in this table. </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 10 </entry>
									<entry> The user used ^QUIT to leave the form that was started
										with run. </entry>
								</row>
								<row>
									<entry> 9 </entry>
									<entry> The user used ^ACCEPT to leave the form that was started
										with run. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> The form did not contain an edit or display statement in
										its Execute trigger. </entry>
								</row>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> FormSpec could not be found, or there is already a form
										with this name in the form stack. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> The form that was started with run is a non-modal form
										and cannot be started with run. Use newinstance (or
										activate) instead. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following run</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -58</entry>
									<entry> &lt;UACTERR_NO_COMPONENT&gt;</entry>
									<entry> The named component cannot be found. This error is also
										returned in case a modal form is started using run, and the
										form is already running.</entry>
								</row>
								<row>
									<entry> -154 </entry>
									<entry> &lt;UACTERR_INSTANCE_NAME_EXISTS&gt; </entry>
									<entry><para>An instance with this name already exists. This
											error code is returned, for example, in the following
											cases:</para><itemizedlist>
											<listitem>
												<para>when a modal form which is already active is
												activated again </para>
											</listitem>
											<listitem>
												<para>when an attempt is made to activate a modal
												form from a non-modal form </para>
											</listitem>
										</itemizedlist></entry>
								</row>
								<row>
									<entry> -1106 </entry>
									<entry> &lt;UPROCERR_COMPONENT&gt; </entry>
									<entry> The component name provided is not valid; for example,
										the argument contains an empty string (""). </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service and report components that are
						not self-contained), as well as in the Application Execute trigger of
						start-up shells. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para><emphasis role="bold"> Note:</emphasis> The run command has been
						superceded by activate, which provides much more functionality and
						flexiblity than run. </para>
					<para>The run statement loads the form named by FormSpec and executes the
						statements in the Execute trigger. After the form has been loaded, the form
						is known by its name in the Repository, excluding any file specification
						provided in FormSpec. For example, in the form started by the following
						statement, the function $formname returns the name of the form, 'QRY1': </para>
					<programlisting role="uniface"><![CDATA[run "c:\t_forms\qry1.frm"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Restrictions Using run</title>
					<para>The activate statement provides the same functionality as run, but
						provides more possibilities for the component being started. Forms started
						with run have the following restrictions:</para>
					<itemizedlist>
						<listitem>
							<para>They are always modal and, thus, attached </para>
						</listitem>
						<listitem>
							<para>They do not offer a callable interface that allows operations to
								be activated and parameters to be passed </para>
						</listitem>
						<listitem>
							<para>They cannot receive messages sent with postmessage. </para>
						</listitem>
						<listitem>
							<para>They are not considered a form instances; functions such as
								$componentname and $instancename return the form name, and
								$instanceparent returns an empty string. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Logical Names and OpenVMS</title>
					<para>If Uniface is running under OpenVMS, a logical name can be used in
						FormSpec; for example: </para>
					<programlisting role="uniface"><![CDATA[run "MYLOGICAL:myhelp"
]]></programlisting>
					<para>Logical names with other operating systems are not supported. </para>
				</sect2>
				<sect2>
					<title>Labels with $text</title>
					<para>When there are labels painted on the form that are filled with $text, the
						values of $language and $variation when the run statement is encountered
						determine the language and library that are used for these labels. If Proc
						code in the Execute trigger of the form changes the values of these
						functions, the changes are not reflected in the labels, since the labels are
						loaded before the Execute trigger is activated. </para>
					<para>You can override this behavior to some extent by clicking the form
						component property Drop Component from Memory <emphasis role="italic">on
						</emphasis>. In this case, the form is not maintained in the form stack; the
						language and library are reestablished each time the form is loaded. </para>
				</sect2>
				<sect2>
					<title>Use of Functions</title>
					<para>When referring to a form created with run, the function $formname returns
						the name of the form. The functions $formdb, $formdbmod, and $formmod return
						various modification statuses associated with the form. </para>
					<para>When referring to a form created with run, the functions $componentname,
						$componenttype, $instancechildren, $instancename, and $instanceparent return
						an empty string (""), while the functions $instancedb, $instancedbmod, and
						$instancemod return -1. These functions are meaningful only in component
						instances started (explicitly or implicitly) with the newinstance statement.
					</para>
				</sect2>
				<sect2>
					<title>Example: Running a Form 1</title>
					<para>The following example runs the form specified in the field FORMNAME: </para>
					<programlisting role="uniface"><![CDATA[; trigger Detail
run FORMNAME
if ($status &lt; 0)
   message "Form named %%FORMNAME%%% not found."
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Running a Form 2</title>
					<para>The following example tries to run the form whose name is contained in the
						component variable $FORM$. If the form has already been run, the current
						form exits, returning to $FORM$. </para>
					<programlisting role="uniface"><![CDATA[run $FORM$
if ($status = -1)
; the form is already running
   exit 0, $FORM$
endif
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: run/query on OpenVMS</title>
					<para>The following OpenVMS example runs the form dua0:[77,2]myform : </para>
					<programlisting role="uniface"><![CDATA[; trigger Detail
run/query "duaO:[77,2]myform"]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.scan">
				<title>scan</title>
				<para>Scans a field or variable for a specified profile and returns the starting
					position of the profile. </para>
				<sect2>
					<title>Syntax</title>
					<para>scan String , Profile </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>String—string, or a field (or indirect reference to a field), a
								variable, or a function that evaluates to a string. If the String to
								be scanned is a Date, Time, or Datetime field, Uniface first
								converts the value to a string according to the default format from
								the language setup before performing the scan. </para>
						</listitem>
						<listitem>
							<para>Profile—string or syntax string, with a maximum length of 128
								characters, that contains the profile to be matched. A string in
								Profile can be a string, or a field (or indirect reference to a
								field), a variable, or a function that evaluates to a string. A
								syntax string is enclosed in single quotation marks (' '). </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>No affect on $status. </para>
					<table>
						<title>Table 1. Values returned by scan in $result</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;0 </entry>
									<entry> Starting position in String of the first match. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Profile not found or String is an empty string ("").
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The scan statement returns to $result the position of the first character
						of String that matches the Profile provided. (The first character of a
						string is at position 1.) </para>
				</sect2>
				<sect2>
					<title>Profile</title>
					<para>If a string is provided for Profile, scan looks for an exact match for
						Profile in String, and not just a pattern. Lowercase is seen as lowercase,
						and uppercase as uppercase. </para>
					<para>If a syntax string is provided for Profile, lowercase is seen as both
						uppercase and lowercase, and uppercase is seen as uppercase only. </para>
					<para>You can also use $syntax to specify that Profile is a syntax string. Use
						$syntax to perform case-insensitive scans when the string contains
						diacritics (for example an umlaut). </para>
					<para>If no character attributes (bold, underline, and so on) are specified in
						the profile string, Uniface ignores them. In this case, <emphasis
							role="bold">abc</emphasis> (bold) is the same as abc (not bold). The
						asterisk wildcard (*) in Uniface stands for 0-<emphasis role="italic"> n
						</emphasis>characters, so spaces also qualify in the syntax check. However,
						one asterisk in the syntax string causes Uniface to check only the following
						32 characters. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following examples show different ways of using the scan statement: </para>
					<programlisting role="uniface"><![CDATA[$1 = "Nibble1"
NAME = "Myrtle"
scan $1,"bbl" ; $result = 3
scan $1,"house" ; $result = 0 (string not found)
scan $1,'#' ; $result = 7 (first number in string)
scan NAME,"yr*e" ; $result = 0
; (syntax strings must be in single quotes)
scan NAME,'yr*e' ; $result = 2 (syntax strings allowed)
scan $1, NAME[5,6] ; $result = 5 (scan $1, "le")
$2="schön"
scan $2, $syntax("hö*") ; $result=3
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.scope">
				<title>scope</title>
				<para> Introduced in: U9 </para>
				<para>Declares the beginning of a scope declaration which specifies the data that is
					to be included in a DSP request-response exchange. </para>
				<sect2>
					<title>Syntax</title>
					<para>public | partner web </para>
					<para>{scope </para>
					<para> {input </para>
					<para> {output}</para>
					<para> {operation InstanceSelector1.OperationSelector1 </para>
					<para> {operation InstanceSelectorN.OperationSelectorN} }</para>
					<para>{endscope}}</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<itemizedlist>
						<listitem>
							<para>public | partner web—see web </para>
						</listitem>
						<listitem>
							<para>scope—beginning of the scope declaration, which defines the data
								to be included in a DSP request-response exchange. If omitted, all
								component data (with the exception of properties) is sent from the
								browser to the server, and all component data (including properties)
								is sent back from server to browser. </para>
						</listitem>
						<listitem>
							<para>input—specifies that all component data (with the exception of
								properties) is sent from browser to server. </para>
						</listitem>
						<listitem>
							<para>output—specifies that all component data (including properties) is
								sent back from the server to browser. </para>
						</listitem>
						<listitem>
							<para>operation—specifies that the specified fully-qualified names of
								one or more operations are to be included in the DSP
								request-response exchange </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in Dynamic Server Page components in the following
						locations:</para>
					<itemizedlist>
						<listitem>
							<para>Execute trigger </para>
						</listitem>
						<listitem>
							<para>Any operation </para>
						</listitem>
						<listitem>
							<para>Any field trigger that is valid for the assigned widget. For valid
								triggers, see the specific widget description. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The scope declaration specifies the data that is to be included in a DSP
						request-response exchange. If no explicit scope declaration is specified,
						the default is used, which is: </para>
					<itemizedlist>
						<listitem>
							<para>All component data with the exception of properties is sent from
								the browser to the server </para>
						</listitem>
						<listitem>
							<para>All component data including properties are returned from the
								server to the browser </para>
						</listitem>
					</itemizedlist>
					<para>The scope block is used by the browser to select the input for a specified
						operation, or to block selected data to ensure that data on the client and
						server are kept synchronized. </para>
				</sect2>
				<sect2>
					<title>Qualifying the Scope</title>
					<para>If the web statement is omitted, the operation is not available from the
						web. This ensures that Uniface components are protected from unauthorized
						calls or attacks.</para>
					<para>Setting the qualifier to public web, makes it possible for a Web browser
						to execute the trigger or operation in which the scope statement occurs.
						This obviously has security risks associated with it, so you need to use it
						appropriately. Typically, you can use it in the Detail and OnChange triggers
						to accept some kind of user interaction, but you would not use it in an
						operation, especially one that stores data.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following code sets the input scope of the showDetails operation
						called in the Detail trigger of a field, then activates the operation. When
						the user clicks on this field in the browser, the showDetails operation on
						another server page is called. </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger of Picture field
public web
scope
   input
   operation MUSICDETAILS.ShowDetails ; where MUSICDETAILS is the instance name
endscope
; newinstance "DETAILS", "MUSICDETAILS" ; if instance != component
activate "MUSICDETAILS".ShowDetails(ITEMID)]]></programlisting>
					<para>The output scope of the called operation blocks the data on the browser
						until the response containing that data is sent.</para>
					<programlisting role="uniface"><![CDATA[operation ShowDetails
   partner web
   scope
      output
   endscope
   params
      string pItemId : IN
   endparams
   ITEMID.ITEMDETAILS/init = pItemId
   retrieve/e "ITEMDETAILS"
end]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example for a Clear button clears the contents of the DSP.
						To prevent the current contents of the DSP from being sent to the browser,
						which creates extra network traffic for data that is being discarded, only
						the output scope is defined. After a clear command, Uniface returns an empty
						occurrence.</para>
					<programlisting role="uniface"><![CDATA[;BTN_CLEAR DETAIL Trigger
public web
scope
  output
endscope
clear/e "PERSON"
if ($status &lt; 0)
  webmessage/error "Clear failed ($status = %%$status%%%)"
endif
return 0]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.selectcase">
				<title>selectcase</title>
				<para>Define a block of conditional case selections. </para>
				<sect2>
					<title>Syntax</title>
					<para>selectcase MatchExpression </para>
					<para>{case Expression 1 </para>
					<para> ... zero or more Proc statements ... </para>
					<para>case Expression 2 </para>
					<para> ... zero or more Proc statements ... </para>
					<para>... </para>
					<para>case Expression n </para>
					<para> ... zero or more Proc statements ... } </para>
					<para>{elsecase </para>
					<para> ... zero or more Proc statements ... } </para>
					<para>endselectcase </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>case—marks the beginning of a conditional block of Proc code to be
								evaluated </para>
						</listitem>
						<listitem>
							<para>elsecase—marks the Proc code to be executed if none of the case
								expressions match MatchExpression. </para>
						</listitem>
						<listitem>
							<para>endselectcase—marks the end of the case definitions </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>MatchExpression, Expression—expressions that evaluate to any data type.
						Data type conversion may be performed to allow a proper comparison to be
						made. See Data Handling in Proc. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The selectcase statement defines a series of conditional blocks of Proc
						code. Each block is defined as a case.</para>
					<para>The MatchExpression is compared to the Expression on each case statement
						in turn. If MatchExpression=Expression is TRUE, the Proc statements in that
						block (up to the next case, elsecase, or endselectcase statement, are
						executed). If no Expression matches MatchExpression, the elsecase clause is
						executed. </para>
					<para>If several cases are to be handled in the same manner, you can put
						multiple expressions on the case statement. For example:</para>
					<programlisting role="uniface"><![CDATA[selectcase $1
   case 1, 2, 3
   Proc code
   case 4
  Proc
            code
   elsecase
Proc code
endselectcase]]></programlisting>
					<para>A selectcase/endselectcase block is equivalent to the following if/endif
						block: </para>
					<para>if (MatchExpression=Expression 1 ) </para>
					<para>...</para>
					<para>elseif (MatchExpression=Expression 2 ) </para>
					<para>...</para>
					<para>... </para>
					<para>elseif (MatchExpression=Expression n ) </para>
					<para>...</para>
					<para>else </para>
					<para>... </para>
					<para>endif</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example illustrates the possibilities of the selectcase
						statement: </para>
					<programlisting role="uniface"><![CDATA[selectcase $1
   case "" ;an empty string
      message "$1 is empty"
   case "ABC" ;a string
      message "$1 is ABC"
   case "abc" ;a string
      message "$1 is abc"
   case "a*" ;a syntax string
      message "$1 matches syntax a*"
   case "DEF%%$2XYZ%%%" ;a string
      message "$1 is DEF%%$2XYZ%%%"
   case 123 ;an ordinary number
      message "$1 is 123"
   case 1.23e_+13 ;a floating point number
      message "$1 is 1.23e_+13"
   case MYFIELD.MYENTITY ;a field
      message "$1 is abc"
   case $date ;a date
      message "$1 is today"
   case $date + 7 ;a date
      message "$1 is one week from today"
   elsecase
      message "$1 is not what we expected"
endselectcase
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.selectdb">
				<title>selectdb</title>
				<para>Calculate aggregate values for specified fields in the database.</para>
				<sect2>
					<title>Syntax</title>
					<para>selectdb ( LitFieldName ) | ( Function ( LitFieldName )) %\ </para>
					<para>{, ( LitFieldName ) | ( Function ( LitFieldName ))}n %\ </para>
					<para> {from Entity} {using Index} %\ </para>
					<para> { {u_where ( SelectionCriteria )} | {u_condition ( Condition )} } %\ </para>
					<para> to ( Destination 1 {, Destination 2 , ..., Destination n }) </para>
					<para>Since a selectdb statement can be quite complex, using the line
						continuation marker (%\) can greatly improve the readability of the
						statement. </para>
				</sect2>
				<sect2>
					<title>Clauses</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>from—specifies the entity whose occurrences are to be
									compared; if omitted, the active occurrence of the current
									entity (available in $entname) is used. </para>
							</listitem>
							<listitem>
								<para>using—specifies the index Uniface should use for record-level
									DBMSs; ignored for field-level DBMSs. See the appropriate DBMS
									connector documentation to verify that the using clause is
									available for your DBMS. </para>
							</listitem>
							<listitem>
								<para>u_where—specifies DBMS-independent selection criteria. It
									allows you to perform calculations on data in all occurrences
									that match the selection criteria, even if these have not yet
									become active in the component. If the entity is painted as an
									up entity, the u_where clause is considered only if the foreign
									key is complete and not NULL. The clause can be used to further
									restrict the number of occurrences read for the up entity.
								</para>
							</listitem>
							<listitem>
								<para>u_condition—provides a DBMS-independent profile for selection.
								</para>
							</listitem>
							<listitem>
								<para>to—specifies the destinations of the requested values </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>LitFieldName—literal name of database field. If used alone
								(without Function), Uniface transports the value of the specified
								field from one of the selected records. (This is usually the last
								record, but see the appropriate connector documentation for
								information about your DBMS.) </para>
						</listitem>
						<listitem>
							<para>Function—one of the functions shown in <emphasis role="italic"
									>Table: Functions and Data Types for selectdb</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>Entity—entity to use. Can be a string, or a field, variable,
								function, or parameter that evaluates to a string containing the
								entity name. </para>
						</listitem>
						<listitem>
							<para>Index—numeric expression that evaluates to the index number
								required. </para>
						</listitem>
						<listitem>
							<para>SelectionCriteria </para>
						</listitem>
						<listitem>
							<para>Condition </para>
						</listitem>
						<listitem>
							<para>Destination—literal name of a field or variable in the component.
								There must be one destination for each requested value (defined by
								Function and <emphasis role="italic">LitFieldName</emphasis>).
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by selectdb in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;=0 </entry>
									<entry> For a record-level DBMS, the number of occurrences that
										matched the selection criteria. For a field-level DBMS, the
										value is always 1, indicating that 0 or more occurrences
										matched. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> A LitFieldName does not exist, or Function cannot be
										used with this field type. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> Open request for table or file failed. The table or file
										is not painted, or it does not exist. </entry>
								</row>
								<row>
									<entry> -9 </entry>
									<entry> An attempt to open a DBMS failed because the maximum
										number of DBMS logons has already been reached. </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> Uniface network error. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
								<row>
									<entry> -20 </entry>
									<entry> Nonexistent field in a u_where clause. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							selectdb</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> &lt;UGENERR_ERROR&gt; </entry>
									<entry> An error occurred. A LitFieldName does not exist, or
										Function cannot be used with this field type. </entry>
								</row>
								<row>
									<entry> -403 </entry>
									<entry> &lt;UMISERR_UWHERE&gt; </entry>
									<entry> Nonexistent field in a u_where clause. </entry>
								</row>
								<row>
									<entry> -404 </entry>
									<entry> &lt;UMISERR_TRX&gt; </entry>
									<entry> The TRX-formatted DML statement from a where clause or
										an sql statement exceeds 16 KB. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The selectdb statement calculates the requested values from the database
						and transports them to the destinations specified. Each Function can be
						applied to a field in multiple occurrences in the database to produce the
						calculated value. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The selectdb statement does not work
						with variable-length fields. </para>
					<para>If the from clause is supplied, Entity should identify the entity whose
						occurrences are to be compared as one of the following: </para>
					<itemizedlist>
						<listitem>
							<para>String that evaluates to the name of an entity: "INVOICES".
							</para>
						</listitem>
						<listitem>
							<para>A field, variable, or parameter that contains the name of an
								entity: <itemizedlist>
									<listitem>
										<para>FIELD1, where FIELD1 contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>$1, where $1 contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>$entname, where $entname contains "INVOICES". </para>
									</listitem>
									<listitem>
										<para>PARAM1, where PARAM1 contains "INVOICES". </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</itemizedlist>
					<para>In the to clause, there should be one Destination specified for each
						requested value. If only one requested value and Destination are specified,
						the parentheses are not required. (For the precise usage, see the examples.)
						If no data is retrieved, the destinations remain unchanged. </para>
				</sect2>
				<sect2>
					<title>Functions</title>
					<para>The functions available with selectdb, along with the allowed data types
						for each, are shown in the following table. If the specified function cannot
						be used with the given data type, Uniface returns an error in $status.
						Depending on the packing code and target DBMS, there can be further
						restrictions on the use of these functions. For more information, see the
						appropriate connector documentation for your DBMS. </para>
					<table>
						<title>Table 3. Functions and Data Types for selectdb </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Function </entry>
									<entry> Result </entry>
									<entry> String </entry>
									<entry> Raw </entry>
									<entry> Numeric </entry>
									<entry> Float </entry>
									<entry> Date </entry>
									<entry> Time </entry>
									<entry> Datetime </entry>
									<entry> Boolean </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> ave </entry>
									<entry> Sum of all values in the named field in the database
										divided by count. </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> No </entry>
								</row>
								<row>
									<entry> count </entry>
									<entry> Number of fields in the database that are filled. </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
								</row>
								<row>
									<entry> max </entry>
									<entry> Largest value in the named field in the database (NULL
										is ignored). </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes 1<footnote>
											<para>In this case, the value returned to the
												destination field or variable has data type
												Datetime. If the destination has data type $, the
												Datetime data remains. Otherwise, the value is
												converted to the destination data type.</para>
										</footnote></entry>
									<entry> Yes 1 </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
								</row>
								<row>
									<entry> min </entry>
									<entry> Smallest value in the named field in the database (NULL
										is ignored). </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> Yes 1 </entry>
									<entry> Yes 1 </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
								</row>
								<row>
									<entry> sum </entry>
									<entry> Sum of all values in the named field in the database. </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> Yes </entry>
									<entry> Yes </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> No </entry>
									<entry> No </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Guidelines and Limitations</title>
					<para>In general, use the selectdb statement when very specific values need to
						be loaded from the database at run time; for example, to generate the next
						unique number, or for loading sums, averages, and so on, into dummy fields
						when building a report. </para>
					<para>The selectdb statement is not very fast with DBMSs that do not support
						this type of aggregate function. This is always the case with record-level
						DBMSs such as RMS, because the driver and Uniface have to perform the
						relevant sorting and aggregate function. </para>
					<para>Using selectdb in combination with a u_where clause with record-level
						DBMSs can result in poor performance, because it is not possible to use the
						criteria to specify a preferred index (this is a general drawback of the
						u_where clause in record-level environments). Instead, the primary key index
						is used. If this is not the field to which you are referring, expect poor
						performance. </para>
					<para>Be careful when using the selectdb statement in the Read trigger
						immediately after a read statement, for the following reasons: </para>
					<itemizedlist>
						<listitem>
							<para>When selectdb is used in combination with a u_where clause that
								references one of the fields of the occurrence just read, the
								attempted selection fails because the occurrence has not been
								fetched yet. </para>
						</listitem>
						<listitem>
							<para>When one of the fields of the occurrence just read is used as the
								Destination, the selection fails because the destination field is
								overwritten at the subsequent fetch. In the following example the
								value of PAYDATE is overwritten at the subsequent fetch:
								<programlisting role="uniface"><![CDATA[; trigger: Read
read u_where (PAYDATE = "") order by "INVOICE_AMOUNT"
selectdb (PRIMARY_KEY) from "INVOICES" to PAYDATE
]]></programlisting></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Calculations Based on Selection Criteria </title>
					<para>In the following example, the selectdb statement retrieves the highest
						invoice number and computes the total invoice amount from the INVOICE entity
						for the customer named in $1. The invoice number is loaded into $2 and the
						total invoice amount is placed in the dummy field TOTAL_DUM. </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Occurrence Gets Focus&gt;
selectdb (max(INV_NUM), sum(AMOUNT)) %\
   from "INVOICES" %\
   u_where (CUSTOMER = $1) %\
   to ($2, TOTAL_DUM)
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Generating Sequence Numbers </title>
					<para>The following example uses selectdb to generate the next unique sequence
						number: </para>
					<programlisting role="uniface"><![CDATA[; trigger Add/Insert Occurrence
selectdb max(INVOICE_NUMBER) %\
   from "INVOICES" %\
   to $1
INVOICE_NUMBER = $1 + 1]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Calculations Using Selected Data </title>
					<para>The following example uses selectdb to produce a report giving a total for
						a certain period: </para>
					<programlisting role="uniface"><![CDATA[; trigger Print
SELECTDB sum(INV_AMOUNT) %\
   from "INVOICES" %\
   u_where (INV_DATE &gt; $date(31-dec-1989)) %\
   &amp; (INV_DATE &lt; $date(01-apr-1990)) %\
   to Q1TOTAL.DUMMY
print "SALESLASER", "A"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Counting Selected Occurrences </title>
					<para>In the following example, the selectdb statement returns a count of the
						number of occurrences in ENT2 that have the same name as the occurrence of
						ENT1 that was just read. Note: It is necessary to qualify the field name
						left of the relational operator = in the u_where clause to force it to refer
						to ENT2, rather than the current entity, ENT1. ; trigger &lt;Read> (of ENT1)
						read if ($status = 0) selectdb count(NAME) from "ENT2" %\ u_where (NAME.ENT2
						= NAME.ENT1) %\ to DUMMYFIELD endif </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.set">
				<title>set</title>
				<para>Set the value of the specified Proc function to 1 (TRUE). </para>
				<para> Introduced in: U8 </para>
				<sect2>
					<title>Syntax</title>
					<para>set LitProcFunctionName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>LitProcFunctionName—literal name of a Proc function, including the leading
						dollar sign ($). </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0 </entry>
										<entry> set cannot be used with LitProcFunctionName </entry>
									</row>
									<row>
										<entry> 1 </entry>
										<entry> 1, if LitProcFunctionName was successfully
											set.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Pages and form components (and in service,
						session service, entity service, and report components that are not
						self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The set statement sets the value of the Proc function LitProcFunctionName
						to TRUE (1). It can be used only with functions where this is indicated in
						the Synopsis. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses set to change the value of $occcheck to TRUE
						(1): </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Execute&gt;
; set $occcheck to TRUE to enable checking
name = $1
retrieve
set $occcheck(INVOICE)
edit NAME]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.sendmessage">
				<title>sendmessage [DEPRECATED]</title>
				<warning>
					<para>As of version 9.1 this function is deprectaed. Use activate
						instead.</para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.setformfocus">
				<title>setformfocus</title>
				<para>Set the focus to the specified form instance. </para>
				<sect2>
					<title>Syntax</title>
					<para>setformfocus {InstanceName} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>InstName—name of a form instance in the component pool.; can be a string,
						or a field (or indirect reference to a field), a variable, or a function
						that evaluates to the string. </para>
					<itemizedlist>
						<listitem>
							<para>If omitted, focus is set to the current form instanceInstanceName.
							</para>
						</listitem>
						<listitem>
							<para>If longer than 16 characters, the fomr name is truncated to that
								length. Trailing blanks are removed. </para>
						</listitem>
						<listitem>
							<para>If InstanceName does not currently have focus, Uniface activates
								the Form Loses Focus trigger of the form instance that loses focus
								and Form Gets Focus trigger of the form instance that receives
								focus. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned by setformfocus in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0 </entry>
										<entry> Focus change requested from component manager.
										</entry>
									</row>
									<row>
										<entry> &lt; 0 </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> InstName is not in the component pool or is not
											correct (field or variable not found, or the string is
											not a valid instance name) </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> A modal form has focus; setformfocus cannot be used
											to change the focus. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								setformfocus</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> </entry>
										<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
										<entry> Errors during network I/O. </entry>
									</row>
									<row>
										<entry> -57 </entry>
										<entry> &lt;UACTERR_NO_INSTANCE&gt; </entry>
										<entry> The named instance cannot be found in the component
											pool. </entry>
									</row>
									<row>
										<entry> -405 </entry>
										<entry> &lt;UMISERR_SETFORMFOCUS&gt; </entry>
										<entry> Modal form has focus. In this case, setformfocus
											cannot be used to change the focus. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in form components (and in service, session service, entity
						service, and report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The setformfocus statement sends an asynchronous request to the component
						manager to set the form focus to the requested form instance. </para>
					<para>To set focus to a form that represents a page of a tab widget, assign the
						instance name of the desired form to the tab widget field. However, you can
						also use the setformfocus statement with the instance name of a tab page to
						make that page active. </para>
					<para>For an example using setformfocus, see postmessage.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.setocc">
				<title>setocc</title>
				<para>Make a specific occurrence the current occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para> setocc Entity , OccurrenceNumber </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Entity—entity in which an occurrence is to be made current. Can be
								a string, or a field, variable, function, or parameter that
								evaluates to a string containing the name. It can also be "*", in
								which case all entities in the current instance are set to the
								occurrence specified. </para>
						</listitem>
						<listitem>
							<para>OccurrenceNumber—position of the new current occurrence; can be a
								constant, or a field (or indirect reference to a field), variable,
								or function that can be converted to a whole (integer) number; the
								value will be truncated to form an integer. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0 </entry>
									<entry> Sequence number of the new current occurrence in Entity.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							setocc</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1 </entry>
									<entry> &lt;UGENERR_ERROR&gt; </entry>
									<entry> An error occurred. Entity is the outer entity of a
										Record component. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The setocc statement makes current the occurrence of Entity that is
						identified by OccurrenceNumber. If OccurrenceNumber is :</para>
					<itemizedlist>
						<listitem>
							<para>&lt;0—last occurrence in the hitlist becomes current. This entails
								fetching all the occurrences in the hitlist. </para>
						</listitem>
						<listitem>
							<para>0 or not specified—current occurrence is not changed. </para>
						</listitem>
						<listitem>
							<para>Between 1 and the current number of occurrences of Entity in the
								component, inclusive—indicated occurrence becomes current. </para>
						</listitem>
						<listitem>
							<para>Greater than the number of occurrences of Entity in the
								component—$status is set to -1 and the current occurrence remains
								current. </para>
						</listitem>
					</itemizedlist>
					<para>Using setocc to change the current occurrence causes the Occurrence Gets
						Focus trigger to be activated when the trigger containing the setocc
						completes. The Occurrence Gets Focus trigger is only activated once, though,
						for the occurrence that is active at the end of the trigger containing the
						setocc statement. </para>
					<para>setocc has an immediate effect on the value of $curocc. For example, a
						statement such as setocc $entname,$curocc+1 immediately increments the value
						of $curocc. </para>
					<para>The statement setocc "*",-1 does not return a total number of occurrences
						in $status, because the painted entities are not likely to have the same
						number of occurrences. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> Be careful with statements such
						as setocc "*",-1, since they can have drastic effects when combined with
						statements like erase. Issuing an erase after a setocc "*",-1 removes all
						the data that matches the profile given by the user in the entities of the
						component. </para>
				</sect2>
				<sect2>
					<title>Example: Giving Focus to the Last Occurrence in a Form</title>
					<para>The following example uses setocc to find the last customer number used in
						the database: </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Execute&gt;
; fetch all occurrences into form
retrieve
setocc "CUSTOMER",-1
message "Last customer is %%custnumber%%%."
edit
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Looping Through a Hitlist and Checking Occurrences </title>
					<para>The following example shows the use of the setocc statement to loop
						through a hitlist, checking that all occurrences have been entered by the
						user. </para>
					<programlisting role="uniface"><![CDATA[; Trigger Accept from Form W_ENTR4
$occ_num$ = 1
repeat
   setocc "ENTRANT", $occ_num$
   if (DRIVER_ID.ENTRANT = 0)
      message/info/nobeep "Not all places have been filled. %\
      Please complete the grid or Cancel."
      return(-1)
   endif
   $occ_num$ = $occ_num$ + 1
until ($occ_num$ &gt; $totocc(ENTRANT))]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.show">
				<title>show</title>
				<para> Introduced in: U8 </para>
				<para>Display a form component. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$show</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values commonly returned in $procerror following
							show</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1402</entry>
									<entry> &lt;UPROCERR_STATEMENT&gt; </entry>
									<entry> show used in service component.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in form components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The show statement displays a form component. All current field values are
						displayed. </para>
				</sect2>
				<sect2>
					<title>Example: Redisplaying values as They are Updated </title>
					<para>The following example shows the show statement being used to redisplay
						values in a form as they are updated (that is, while processing continues): </para>
					<programlisting role="uniface"><![CDATA[entry CountDown()
variables
   numeric j
endvariables
MyField.MyEnt = 10
while (MyField.MyEnt &gt; 0)
   show
   j = 10000
   while (j&gt;0)
      j = j - 1
   endwhile
   MyField.MyEnt = MyField.MyEnt - 1
endwhile ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.skip">
				<title>skip</title>
				<para>Skip the specified number of lines when printing. </para>
				<sect2>
					<title>Syntax</title>
					<para> skip {Expression} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Expression—number of lines to skip; can be a constant, field, variable, or
						function that can be converted to a whole non-negative number. The value
						will be truncated to form an integer value. If Expression is omitted or is
						0, one line is skipped. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &lt;0</entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> &gt;=0</entry>
										<entry> Statement executed successfully</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 2. Values commonly returned by $procerror following
								skip</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1404 </entry>
										<entry> &lt;UPROCERR_NO_PRINTING&gt; </entry>
										<entry> Not printing (that is, $printing is 0). The skip
											statement is ignored. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form and report components (and in
						service, session service and entity service components that are not
						self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The skip statement skips the number of lines defined in Expression. </para>
					<para>The following rules are valid for skip: </para>
					<itemizedlist>
						<listitem>
							<para>If Uniface is not printing $printing is 0) when this statement is
								issued, it is ignored. </para>
						</listitem>
						<listitem>
							<para>If the number of lines to be skipped is more than the number of
								lines left on the page, Uniface issues an eject instead and begins
								printing again at the top of the following page. </para>
						</listitem>
						<listitem>
							<para>When Uniface encounters a skip statement, it is carried out
								immediately; no other triggers are activated in the current line.
							</para>
						</listitem>
					</itemizedlist>
					<para>Negative expressions are not supported.</para>
				</sect2>
				<sect2>
					<title>Example: Skipping Lines When Printing </title>
					<para>The following example shows Proc code which causes Uniface to skip two
						lines if the invoice date in the next occurrence to be printed is not the
						same as the invoice date in the occurrence just printed. You are advised to
						test if Uniface is printing ($printing is 1), before using the skip
						statement, as shown here: </para>
					<programlisting role="uniface"><![CDATA[; trigger &lt;Leave Printed Occurrence&gt;
; $printing checks if printing is in process
if ($printing = 1)
   compare/next (INVDATE) from "INVOICE"
   if ($result = 0)
      skip 2
   endif
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.sleep">
				<title>sleep</title>
				<para> Introduced in: U8 </para>
				<para>Set the current Uniface process in sleep mode for the specified amount of
					time.</para>
				<sect2>
					<title>Syntax</title>
					<para> sleep Ticks </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Ticks—time period, specified in hundredths of a second. There is no
						default value; you must specify a positive integer. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The sleep Proc statement requests the current Uniface application to pause
						execution for <emphasis role="italic">approximately</emphasis> the specified
						period of time. The actual clock time blocked is dependent on the underlying
						operating system. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> sleep is guaranteed to block for
						at least the requested time, but, depending on the operating system, the
						actual blocking time could be longer, because not all systems support time
						resolution in ticks. </para>
					<para><emphasis role="bold"> Note:</emphasis> On Microsoft Windows, while a
						process is blocked using sleep, the screen is not repainted, which could
						result in parts of the application screen going blank until the sleep
						finishes. When you wish to use sleep for more than a few seconds, consider
						using multiple sleep commands, or putting them in a loop, so the screen can
						be repainted in between.</para>
					<para>The following example sets the application to sleep for at least 5
						seconds: </para>
					<para>sleep 500</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.sort">
				<title>sort</title>
				<para>Sort the occurrences in the hitlist for the specified entity. </para>
				<sect2>
					<title>Syntax</title>
					<para>sort{/e} Entity , {LiteralFieldName : SortOptions {<emphasis
							role="underline">;</emphasis> LiteralFieldName: SortOptions}}</para>
					<para>Syntax of SortOptions: </para>
					<para>{Order} {Unique} {Type} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/e—no meaning. sort and sort/e are synonymous. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Entity—entity whose occurrences are to be sorted. Can be a string,
								or a field, variable, function, or parameter that evaluates to a
								string containing the entity name. </para>
						</listitem>
						<listitem>
							<para>LiteralFieldName—name of the field to sort on; the name can be
								fully qualified. </para>
						</listitem>
						<listitem>
							<para>SortOptions—list of sort options; can be a string, or a field (or
								indirect reference to a field), a variable, or a function that
								evaluates to a string. All sort options are optional. After the
								Field, they can be defined in any order. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Sort Options</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Sort Option</entry>
									<entry> Meaning</entry>
									<entry> Valid Values</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Ordering </entry>
									<entry> Sort order</entry>
									<entry> ascending | A descending | D </entry>
								</row>
								<row>
									<entry> Unique </entry>
									<entry> Keep only unique items; discard duplicates</entry>
									<entry> unique | U </entry>
								</row>
								<row>
									<entry> Type </entry>
									<entry> Sort the data as a specified data type, or apply
										locale-based sorting conventions. It is also possible to
										specify case-insensitive sorting or level-based sorting. If
										not specified, the value of $nlssortorder is used. If this
										is not set, the value of $nlslocale is used. If this is not
										set, a binary sort is performed.</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort using the value of $nlslocale, as set by the
										$NLS_LOCALE assignment setting or $nlslocale Proc
										function.</entry>
									<entry> nlslocale | NLS </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort as a case-sensitive string, ignoring locale-based
										sorting conventions</entry>
									<entry> classic | CaseSensitive | CS |</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort as a case-insensitive string, using the 1-to-1
										character matching for Unicode uppercase and lowercase
										rules.</entry>
									<entry> CaseInsensitive | CI </entry>
								</row>
								<row>
									<entry/>
									<entry> Sort data as level ID (n.n.n), so that 9.2 is sorted
										before 10.1 </entry>
									<entry> level </entry>
								</row>
								<row>
									<entry> </entry>
									<entry><emphasis role="bold"> Note:</emphasis> When specifying
										the following sort options, it is assumed the data is in a
										format that can be interpreted as the specified data
										type:</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Numeric</entry>
									<entry> Numeric </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Float</entry>
									<entry> Float </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Boolean</entry>
									<entry> Boolean </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Date</entry>
									<entry> Date </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Time</entry>
									<entry> Time </entry>
								</row>
								<row>
									<entry> </entry>
									<entry><emphasis role="bold"> Note:</emphasis> When specifying
										the following sort options, Uniface converts the data to the
										specified data type before sorting:</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $number ( String ) </entry>
									<entry> $number </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $float ( String ) </entry>
									<entry> $float </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $boolean ( String ) </entry>
									<entry> $boolean </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $date ( String ) </entry>
									<entry> $date </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $clock ( String ) </entry>
									<entry> $time </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $datim ( String ) </entry>
									<entry> $datim </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as string ( String ) </entry>
									<entry> $string </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 2. Values returned by sort in $status</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> &gt;=0 </entry>
										<entry> The number of occurrences sorted. </entry>
									</row>
									<row>
										<entry> &lt;0 </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> -1 </entry>
										<entry> An error occurred in SortSpecs, for example, the
											field specified is not on the active path. </entry>
									</row>
									<row>
										<entry> -2 </entry>
										<entry> An error occurred in EntityName, for example, the
											entity specified is not painted on the form. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 3. Values commonly returned by $procerror following
								sort</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Error constant </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1102 </entry>
										<entry> &lt;UPROCERR_ENTITY&gt; </entry>
										<entry> The entity name provided is not a valid name or the
											entity is not painted on the component. </entry>
									</row>
									<row>
										<entry> -1126 </entry>
										<entry> &lt;UPROCERR_PROPERTY&gt; </entry>
										<entry> A property is not valid. An error occurred in
											SortSpecs. For example, the field specified is not on
											the active path. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
						<table>
							<title>Table 4. Sort List Errors Commonly Returned in $procerror</title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Error</entry>
										<entry> Error Constant</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -1112 </entry>
										<entry> UPROCERR_OPTION</entry>
										<entry> SortOption: Ascending assumed: When an option starts
											with an "A" and is not "A" / "ASC" / "ASCENDING"</entry>
									</row>
									<row>
										<entry> SortOption: Descending assumed: When an option
											starts with an "D" and is not "D" / "DESC" /
											"DESCENDING"</entry>
									</row>
									<row>
										<entry> SortOption: Unique assumed: When an option starts
											with an "U" and is not "U" / "UNI" / "UNIQUE"</entry>
									</row>
									<row>
										<entry> SortOption: Invalid option: When an option can't be
											recognized</entry>
									</row>
									<row>
										<entry> SortOption: Duplicate order: When an Ascending is
											defined over a Descending v.v.</entry>
									</row>
									<row>
										<entry> SortOption: Duplicate type: When a DataType or
											$Typing is defined twice.</entry>
									</row>
									<row>
										<entry> -1101 </entry>
										<entry> UPROCERR_FIELD</entry>
										<entry> SortOption: Field does not exist For sort "entity"
											when a fieldname is wrong or excluded </entry>
									</row>
									<row>
										<entry> -1129 </entry>
										<entry> UPROCERR_ITEM</entry>
										<entry> SortOption: SubItemId does not exist</entry>
									</row>
									<row>
										<entry> SortOption: SubItemNr does not exist</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The sort statement sorts the occurrences in the hitlist according to the
						specified criteria. </para>
					<para>Sorting occurs along the active path starting with the specified entity.
						Consequently, you can sort on fields that are not contained in the specified
						entity, as long as these fields occur in subsequent nodes on the active
						path. For more information, see Trigger Activation and the Active Path. </para>
					<para>By default, Uniface sorts in binary order, but you can apply locale-based
						sorting using $nlssortorder. For more information see Sorting Based on
						Locale </para>
					<para>For information on sorting entities using the sort options, see Sorting
						Entities and Lists.</para>
				</sect2>
				<sect2>
					<title>Example: Sorting Occurrences </title>
					<para>The following example sorts the occurrences of the entity RESULT on the
						availability of the component variable $1_car$. It sorts all occurrences of
						TEAM_NAME.RESULT in an ascending or descending manner: </para>
					<programlisting role="uniface"><![CDATA[; FORMULA 1 Application
; field: L_CAR.RACE.FORMULA1
; trigger: Leave Field (of the sort button of the heading)
$1_car$ = !$1_car$
if ($1_car$)
   sort/e "RESULT","TEAM_NAME.RESULT:a"
else
   sort/e "RESULT","TEAM_NAME.RESULT:d"
endif]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.sort_list">
				<title>sort/list</title>
				<para>Sort an associative list, an indexed list, or an indexed list of sublists. </para>
				<sect2>
					<title>Syntax</title>
					<para>sort/list List{, SortElement : SortOptions {<emphasis role="underline"
							>;</emphasis> SortElement : SortOptions}} </para>
					<para>Syntax of SortOptions: </para>
					<para>{Order} {Unique} {Type} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>List—field or variable that evaluates to a string containing an
								associative list of items. The current value of List is replaced by
								a list with the same items sorted by the representation. </para>
						</listitem>
						<listitem>
							<para>SortElement—element of an associative list, or a sublist element,
								on which to sort <itemizedlist>
									<listitem>
										<para>$idpart—sort on the IdPart of an associative list
										</para>
									</listitem>
									<listitem>
										<para>$valuepart—sort on the ValuePart of an asociative list
										</para>
									</listitem>
									<listitem>
										<para>$string( SublistItemId )— </para>
									</listitem>
									<listitem>
										<para>SublistItemNr—sort on the sequence number of an
											indexed sublist </para>
									</listitem>
									<listitem>
										<para>SublistItemId—sort on the IdPart of an associative
											sublist </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
						<listitem>
							<para>SortOptions—comma-separated or GOLD ; separated list of sort
								options; can be a string, or a field (or indirect reference to a
								field), a variable, or a function that evaluates to a string. All
								sort options are optional. After the ElementToSort, they can be
								defined in any order. </para>
						</listitem>
					</itemizedlist>
					<table>
						<title>Table 1. Sort Options</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Sort Option</entry>
									<entry> Meaning</entry>
									<entry> Valid Values</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> Ordering </entry>
									<entry> Sort order</entry>
									<entry> ascending | A descending | D </entry>
								</row>
								<row>
									<entry> Unique </entry>
									<entry> Keep only unique items; discard duplicates</entry>
									<entry> unique | U </entry>
								</row>
								<row>
									<entry> Type </entry>
									<entry> Sort the data as a specified data type, or apply
										locale-based sorting conventions. It is also possible to
										specify case-insensitive sorting or level-based sorting. If
										not specified, the value of $nlssortorder is used. If this
										is not set, the value of $nlslocale is used. If this is not
										set, a binary sort is performed.</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort using the value of $nlslocale, as set by the
										$NLS_LOCALE assignment setting or $nlslocale Proc
										function.</entry>
									<entry> nlslocale | NLS </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort as a case-sensitive string, ignoring locale-based
										sorting conventions</entry>
									<entry> classic | CaseSensitive | CS |</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort as a case-insensitive string, using the 1-to-1
										character matching for Unicode uppercase and lowercase
										rules.</entry>
									<entry> CaseInsensitive | CI </entry>
								</row>
								<row>
									<entry/>
									<entry> Sort data as level ID (n.n.n), so that 9.2 is sorted
										before 10.1 </entry>
									<entry> level </entry>
								</row>
								<row>
									<entry> </entry>
									<entry>
										<emphasis role="bold"> Note:</emphasis> When specifying the
										following sort options, it is assumed the data is in a
										format that can be interpreted as the specified data
										type:</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Numeric</entry>
									<entry> Numeric </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Float</entry>
									<entry> Float </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Boolean</entry>
									<entry> Boolean </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Date</entry>
									<entry> Date </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort data as Time</entry>
									<entry> Time </entry>
								</row>
								<row>
									<entry> </entry>
									<entry>
										<emphasis role="bold"> Note:</emphasis> When specifying the
										following sort options, Uniface converts the data to the
										specified data type before sorting:</entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $number ( String ) </entry>
									<entry> $number </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $float ( String ) </entry>
									<entry> $float </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $boolean ( String ) </entry>
									<entry> $boolean </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $date ( String ) </entry>
									<entry> $date </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $clock ( String ) </entry>
									<entry> $time </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as $datim ( String ) </entry>
									<entry> $datim </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> Sort Data as string ( String ) </entry>
									<entry> $string </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 2. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Success</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Number of items remaining in List. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 3. Sort List Errors Commonly Returned in $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Error</entry>
									<entry> Error Constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1112 </entry>
									<entry> UPROCERR_OPTION</entry>
									<entry> SortOption: Ascending assumed: When an option starts
										with an "A" and is not "A" / "ASC" / "ASCENDING"</entry>
								</row>
								<row>
									<entry> SortOption: Descending assumed: When an option starts
										with an "D" and is not "D" / "DESC" / "DESCENDING"</entry>
								</row>
								<row>
									<entry> SortOption: Unique assumed: When an option starts with
										an "U" and is not "U" / "UNI" / "UNIQUE"</entry>
								</row>
								<row>
									<entry> SortOption: Invalid option: When an option can't be
										recognized</entry>
								</row>
								<row>
									<entry> SortOption: Duplicate order: When an Ascending is
										defined over a Descending v.v.</entry>
								</row>
								<row>
									<entry> SortOption: Duplicate type: When a DataType or $Typing
										is defined twice.</entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> UPROCERR_FIELD</entry>
									<entry> SortOption: Field does not exist For sort "entity" when
										a fieldname is wrong or excluded </entry>
								</row>
								<row>
									<entry> -1129 </entry>
									<entry> UPROCERR_ITEM</entry>
									<entry> SortOption: SubItemId does not exist</entry>
								</row>
								<row>
									<entry> SortOption: SubItemNr does not exist</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>By default, sort/list sorts on the value part of a list item, in ascending
						order. Uniface sorts in binary order, but you can apply locale-based sorting
						using $nlssortorder. For more information see Sorting Based on Locale </para>
					<para>For information on sorting lists using the sort options, see Sorting
						Entities and Lists.</para>
				</sect2>
				<sect2>
					<title>Example: Sorting List Items in Descending Order </title>
					<para>Sort the items in the DAYS field in descending order: </para>
					<programlisting role="uniface"><![CDATA[;
DAYS = "1=Monday<emphasis role="underline">;</emphasis>2=Tuesday<emphasis role="underline">;</emphasis>3=Wednesday<emphasis role="underline">;</emphasis>4=Thursday"
sort/list DAYS, "d"
; DAYS is "3=Wednesday<emphasis role="underline">;</emphasis>2=Tuesday<emphasis role="underline">;</emphasis>4=Thursday<emphasis role="underline">;</emphasis>1=Monday"]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Sorting Lists in Fields </title>
					<para>In the following example, STATE is a field that is painted as a drop-down
						list. The ValRep for the field STATE contains four possibilities; the field
						STATE, however, has only a single value so it is not possible to sort on
						STATE. </para>
					<programlisting role="uniface"><![CDATA[$valrep(STATE) = "ak=Alaska<emphasis role="underline">;</emphasis>al=Alabama<emphasis role="underline">;</emphasis>ar=Arkansas<emphasis role="underline">;</emphasis>az=Arizona"]]></programlisting>
					<para>The ValRep list must be moved into a variable or field before sorting can
						be effective. </para>
					<programlisting role="uniface"><![CDATA[; trigger: Occurrence Gets Focus
$valrep(STATE) = "ak=Alaska<emphasis role="underline">;</emphasis>al=Alabama<emphasis role="underline">;</emphasis>ar=Arkansas<emphasis role="underline">;</emphasis>az=Arizona"
$vStates$ = $valrep(STATE)
sort/list $vStates$,"A" ;  $1 is now "al=Alabama;ak=Alaska;ar=Arkansas;az=Arizona"
$valrep(STATE) = $vStates$]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.spawn">
				<title>spawn</title>
				<para>Pass the specified command to the operating system. </para>
				<sect2>
					<title>Syntax</title>
					<para>spawn OSCommand </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>OSCommand—operating system command; can be a string, or a field (or
						indirect reference to a field), a variable, or a function that evaluates to
						a string. The string can be up to 255 bytes. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0 </entry>
									<entry> An operating system error occurred.</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> OSCommand was successfully spawned. $result is set to
										the value returned by OSCommand.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The spawn statement clears the screen and passes the OSCommand to the
						operating system on which the application is running. In a client/server
						environment, this is the client machine. </para>
					<para>You may need to use the >refresh statement to repaint the Uniface screen
						following spawn. </para>
					<para>The OSCommand is spawned as an asynchronous process, making it appropriate
						for interactive applications. To run a synchronous OS command and catch the
						result, implement an OS service and use activate to call the COMMAND
						operation on the service. </para>
				</sect2>
				<sect2>
					<title>Windows</title>
					<para>On Microsoft Windows platforms, you can spawn the command as a synchronous
						process by prefixing the command with a hash character (#). In the following
						example, the Uniface application is suspended until the program conv_val
						ends: </para>
					<programlisting role="uniface"><![CDATA[; start conv_val to convert file specified in $1
spawn "#conv_val.exe %%$1.raw"
; load processed values into $2
fileload "%%$1.dat",$2
]]></programlisting>
				</sect2>
				<sect2>
					<title>Unix</title>
					<para>Under Unix, a spawned process that detaches itself from the parent process
						can be used for interprocess communication. </para>
				</sect2>
				<sect2>
					<title>MS-DOS</title>
					<itemizedlist>
						<listitem>
							<para>To execute an MS-DOS command such as copy or del, you must invoke
								the MS-DOS command shell, <emphasis role="bold"
									>command.com</emphasis>. For example:
								<programlisting role="uniface"><![CDATA[; delete the temporary file temp.dat
spawn "dosprompt /c del temp.dat"]]></programlisting></para>
							<para>If the spawned command is found in your command path as an
									<emphasis role="bold">.exe</emphasis> or <emphasis role="bold"
									>.com</emphasis> file, it is not necessary to include the
								command shell in OSCommand. </para>
						</listitem>
						<listitem>
							<para>To run a MS-DOS program, it is recommended that you use a
									<emphasis role="bold">.pif</emphasis> file. This gives you
								greater control over the environment in which it is run. For
								information on <emphasis role="bold">.pif</emphasis> files, see your
								Microsoft documentation. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example: Getting OpenVMS Directory Listing</title>
					<para>The following example uses the spawn statement to get a directory listing
						from the OpenVMS operating system: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
spawn "dir *.*"
askmess "Press space bar to return."," ",-1
refresh
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example: Interactively Removing Print Files</title>
					<para>The following example uses the spawn statement to interactively remove any
						print files (those ending in <emphasis role="bold">.p00</emphasis> through
							<emphasis role="bold">.p99</emphasis>). This example uses the Unix rm
						command, which should be in the user's path (Unix systems only). </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail
spawn "rm -i *.p[0-9][0-9] "
askmess "Press space bar to return."," ",-1
refresh]]></programlisting>
					<para>For example, the form in the following figure uses the Detail triggers of
						the fields to spawn commands to the (Unix) operating system: </para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_10.jpg"/>
						</imageobject>
					</mediaobject>
					<para>The Proc code in the Detail triggers of each field in the form is: </para>
					<programlisting role="uniface"><![CDATA[; trigger: Detail of Button "View Print Queue"
spawn "lpq"
refresh
; trigger: Detail of Button "Remove old print files"
spawn "/bin/rm -i *.p[0-9][0-9]"
refresh
; trigger: Detail of Button "View current directory"
spawn "ls -l | /bin/pg"
refresh
; trigger: Detail of Button "Print the selected files"
if (print_files != "")
   spawn "lpr %%print_files%%%"
else
   askmess "What do you want to print?","Continue"
endif
refresh]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.sql">
				<title>sql</title>
				<para>Pass a DML statement to the specified DBMS path. </para>
				<sect2>
					<title>Syntax</title>
					<para> sql{/print} DMLStatement , " PathString " </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para> ... /print—puts the complete output of the DML statement into $result (as
						seen in the SQL Workbench). </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>DMLStatement—Data Manipulation Language (DML) statement that obeys
								the syntax rules of the DML of the DBMS referred to by the specified
								path; it can be a string, or a field (or indirect reference to a
								field), a variable, or a function that evaluates to a string.
								Uniface does not check the syntax of DMLStatement. </para>
							<para>DMLStatement can contain up to 16 kilobytes of data; it cannot
								contain a carriage return, unless DMLStatement refers to a blockdata
								label. </para>
						</listitem>
						<listitem>
							<para>PathString—string constant that contains the name of a path. The
								leading dollar sign ($) should not be present; for example, "SYB".
								If omitted, no action is performed and an error is returned in
								$status. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by sql in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;=0 </entry>
									<entry> The number of hits. </entry>
								</row>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> Path was omitted from the sql statement or is not valid;
										for example, it is not defined in the assignment file.
									</entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). Or, the
										DBMS reached by Path does not support a DML. Or, the DML
										statement is empty. </entry>
								</row>
								<row>
									<entry> -9 </entry>
									<entry> An attempt to open a DBMS failed because the maximum
										number of DBMS logons has already been reached. </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
								<row>
									<entry> -31 </entry>
									<entry> The DML statement on an sql instruction exceeds 16 KB.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following sql</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -404 </entry>
									<entry> &lt;UMISERR_TRX&gt; </entry>
									<entry> The TRX-formatted DML statement from a where clause or
										an sql statement exceeds 16 KB. </entry>
								</row>
								<row>
									<entry> -1107 </entry>
									<entry> &lt;UPROCERR_PATH&gt; </entry>
									<entry> The path name is not correct or the path does not exist,
										for example, no assignment is found for the path. </entry>
								</row>
								<row>
									<entry> -1203 </entry>
									<entry> &lt;UPROCERR_RANGE&gt; </entry>
									<entry> Value out of range. The DMLStatement is empty. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Following sql, if DMLStatement includes a DML select or retrieve
						statement, the value in the first column of the last selected occurrence is
						returned to the $result general variable. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The sql statement passes DMLStatement via the specified path to the
						database. </para>
					<para>Only one DMLStatement can be used with each sql statement. If you need to
						issue more statements, use the required number of sql statements. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> You should not use transaction
						control statements such as commit or rollback, because these upset Uniface's
						internal consistency controls. </para>
				</sect2>
				<sect2>
					<title>Portability</title>
					<para>Be careful when using the sql statement. There is often a more direct way
						to get the same information using Proc code or standard Uniface I/O, which
						is faster and more maintainable. Using more than two or three sql statements
						in one trigger usually indicates that the function should be reexamined.
						Using only the functionality provided by Uniface provides a much more
						portable solution than using features of a specific DBMS. </para>
					<para>For the ORA driver version U4.0 and higher, when you use the sql Proc
						statement or the SQL Workbench to retrieve Long data, it is truncated at 42
						bytes. To avoid this truncation, use a Uniface entity that maps to the table
						and do a normal retrieve of the entity. </para>
				</sect2>
				<sect2>
					<title>Example: sql/print </title>
					<para>The following example uses the /print switch to return the entire result
						of the select and place it in the message frame: </para>
					<programlisting role="uniface"><![CDATA[$1="leek"
sql/print "select last_name,first_name from people %\
where favorite_vegetable="%%$1"", "syb"
clrmess
if ($status &gt; 0)
   putmess $result
else
   putmess "No one likes a %%$1."
endif
macro "^message"
]]></programlisting>
					<para>After this code has been executed, the message frame contains: </para>
					<programlisting role="uniface"><![CDATA[LAST_NAME            FIRST_NAME
==================== ==============================
Brittmann            Emma
Gabriel              Zoe
Grieder              Dalton
Forcher              Cullen
Crew                 Christine]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.store">
				<title>store</title>
				<para>Activate Validate triggers as required, then Write and Delete triggers for all
					occurrences marked as modified. </para>
				<sect2>
					<title>Syntax</title>
					<para>store{/complete | /truncate} </para>
					<para>store/e{/complete | /truncate} {Entity} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<itemizedlist>
						<listitem>
							<para>/complete— builds any incomplete hitlists by issuing the
								appropriate DBMS calls, prior to starting the actual store process.
								This allows the user to continue working through the hitlists after
								the function has been processed. </para>
							<para><emphasis role="bold"> Note:</emphasis> store/complete may affect
								performance when operating on extensive sets of data. </para>
						</listitem>
						<listitem>
							<para>/truncate—truncates all hitlists (both inner and outer) after the
								store statement has been executed. This is the default behavior.
								This switch is provided for compatibility with pre-Version 6
								implementations. If you need to maintain complete hitlists, you
								should use store/complete instead. </para>
						</listitem>
						<listitem>
							<para>/e—stores the modified occurrences starting with Entity. All
								entities painted within the stored entity are also stored. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity to be stored. Can be a string, or a field, variable,
						function, or parameter that evaluates to a string containing the entity
						name. If omitted, the current entity ($entname) is stored. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by store in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 1 </entry>
									<entry> No data was stored because no modifications were made to
										the data since the last retrieve or store statement. Or, no
										entities are painted on the component. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Data successfully stored. </entry>
								</row>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> -1 </entry>
									<entry> Constraint violation. Restricted link violation.
									</entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> Open request for table or file failed. The table or file
										is not painted, or it does not exist. </entry>
								</row>
								<row>
									<entry> -5 </entry>
									<entry> Update request for nonupdatable occurrence. </entry>
								</row>
								<row>
									<entry> -6 </entry>
									<entry> Exceptional I/O error on write request; for example,
										lack of disk space, no write permission, or violation of a
										database constraint. Check the message frame for details.
									</entry>
								</row>
								<row>
									<entry> -7 </entry>
									<entry> Duplicate key. </entry>
								</row>
								<row>
									<entry> -9 </entry>
									<entry> An attempt to open a DBMS failed because the maximum
										number of DBMS logons has already been reached. </entry>
								</row>
								<row>
									<entry> -10 </entry>
									<entry> Occurrence has been modified or removed since it was
										retrieved; the occurrence should be reloaded. </entry>
								</row>
								<row>
									<entry> -11 </entry>
									<entry> Occurrence already locked. </entry>
								</row>
								<row>
									<entry> -15 </entry>
									<entry> Uniface network error. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							store</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> </entry>
									<entry> &lt;UIOSERR_*&gt; (-2 through -12) </entry>
									<entry> Errors during database I/O. </entry>
								</row>
								<row>
									<entry> </entry>
									<entry> &lt;UNETERR_*&gt; (-16 through -30) </entry>
									<entry> Errors during network I/O. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -301 </entry>
									<entry> &lt;UVALERR_CONSTRAINT&gt; </entry>
									<entry> Violation of restricted delete constraint. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, session service, entity service and
						service components (and in report components that are not self-contained).
					</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The store statement updates the database with data of all modified
						occurrences.</para>
					<para>The store statement begins by performing any validation that is still
						outstanding. An implicit validate statement is performed, affecting each
						occurrence that needs validation (except those that will be deleted):
						declarative checks are performed and the Validate Field, Validate Key, and
						Validate Occurrence triggers are activated as necessary. If any validation
						action fails, the appropriate On Error trigger is activated; no data is
						stored. </para>
					<para>If validation completes successfully, store then builds a profile from the
						modifications made to the occurrences in the component. This profile of
						modified occurrences is created with the aid of the $occdbmod function. The
						Write, Write Up, Delete, or Delete Up trigger for each modified occurrence
						is activated. </para>
					<para>Finally, if the message level for the application is greater than 0, the
						store statement clears the message frame as it completes. (When the message
						level is 0, the message frame is never cleared.) The message level can be
						set with the /pri switch or defined in the application definitions. </para>
					<para>After a store statement has been executed, Uniface truncates all hitlists.
						Uniface then treats the occurrence of the outermost entity as if it has been
						retrieved from the database. The user cannot modify the primary key. Use the
						release statement to allow the user to modify the primary key field or
						fields. Remember that store locks database occurrences; these occurrences
						remain locked until a commit or rollback is performed. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If the release statement is used,
						any fields subsequently modified in Proc code with the /init switch will not
						set the modification status. The database will not be updated if the store
						statement is then issued. $status will be set to 1. </para>
				</sect2>
				<sect2>
					<title>Up Entities</title>
					<para>When Uniface detects that an entity is painted as an up entity, the Write
						Up and Delete Up triggers are activated instead of the Write and Delete
						triggers. If the occurrences in the up entity should be written and deleted
						as well as read, include a write and delete statement in these triggers. </para>
					<para>
						<emphasis role="bold"> Caution:</emphasis> Writing and deleting up entities
						can have serious effects on the integrity of the database. </para>
				</sect2>
				<sect2>
					<title>Locking Behavior</title>
					<para>After you retrieve an occurrence from the database, modify it, and store
						it successfully, if you then modify the occurrence a second time without
						retrieving it again, Uniface always applies cautious locking, overriding the
						user-defined locking method. </para>
				</sect2>
				<sect2>
					<title>Validation Status</title>
					<para>As each step in the validation process is completed, the corresponding
						validation status function ($fieldvalidation, $keyvalidation,
						$occvalidation, and $instancevalidation) is reset to indicate that
						validation has been successful and is not required again (unless further
						modifications are made). This ensures that validation will not be needlessly
						repeated. </para>
				</sect2>
				<sect2>
					<title>Modification Status</title>
					<para>The modification status functions for all the occurrences in the component
						are reset only after the store operation has completed successfully. If the
						store operation did not succeed, no modification status functions are
						changed. This allows you to retry a store if a DBMS error occurred, once the
						reason for that error is eliminated. Uniface applies optimistic locking upon
						retrying the store. </para>
				</sect2>
				<sect2>
					<title>Compatibility</title>
					<para>Beginning with V7.2, the store statement initiates implicit validation,
						including both declarative checks (data type, syntax, and ValRep) and
						procedural checks (Validate Field, Validate Key, and Validate Occurrence
						triggers) for all modified, but nonvalidated data in the component. Prior to
						this, only data on the active path when the store statement was encountered
						was subject to declarative validation. Until the next release, the
						assignment setting $VALIDATION can be used to restore the older
						functionality. You are encouraged to update all your components to consider
						the complete validation. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example uses the store statement in the Detail trigger to
						navigate to the last occurrence in the hitlist: </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger
retrieve
setocc "DEPT", 4
store/e/complete "DEPT"
commit
macro "^LAST_OCC"
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In the following example the hitlist is reduced and the last occurrence is
						‘4’: </para>
					<programlisting role="uniface"><![CDATA[; Detail trigger
retrieve
setocc "DEPT", 4
store/e "DEPT"
commit
macro "^LAST_OCC"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.stripattributes">
				<title>stripattributes</title>
				<para> Introduced in: U8 </para>
				<para>Remove character attributes, frames, and rulers from Source and put the result
					in Target. </para>
				<sect2>
					<title>Syntax</title>
					<para>stripattributes Source, Target </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Source, Target—string, or a field (or indirect reference to a field), a
						variable, or a function that evaluates to a string. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The values returned by $status are given in the following table: </para>
					<table>
						<title>Table 1. Values commonly returned by $status following
							stripattributes. The $status values can be logically OR'd to determine a
							combination of the results.</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> Nothing stripped </entry>
								</row>
								<row>
									<entry> 1 </entry>
									<entry> Attributes stripped. </entry>
								</row>
								<row>
									<entry> 4 </entry>
									<entry> Frames stripped. </entry>
								</row>
								<row>
									<entry> 8 </entry>
									<entry> Rulers stripped. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>stripattributes removes character attributes (bold, italic, and
						underline), frames, and rulers from Source and puts the result in Target. </para>
					<para>Characters that are not known in the target character set are not stripped
						from the string, unlike the behavior in Uniface 8 in which they were
						stripped. </para>
				</sect2>
				<sect2>
					<title>Example: stripattributes</title>
					<para>The following Proc example shows how character attributes are stripped
						from field UNIFIELD, so the text can be used in field EDITBOX: </para>
					<programlisting role="uniface"><![CDATA[MYFIELD = "aaabbb"
stripattributes MYFIELD, EDITBOX ; EDITBOX contains "aaabbb" and the value of $status is 1.]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.trigger">
				<title>trigger</title>
				<para> Introduced in: U9 </para>
				<para>Label the begining of an extended trigger</para>
				<sect2>
					<title>Syntax</title>
					<para> trigger ExtendedTriggerName </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>ExtendedTriggerName—extended trigger name. For the names,
									parameters, and descriptions of extended triggers, see Triggers:
									Extended. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>Not applicable.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Use the trigger statement to define extended triggers in the Extended
						Triggers trigger of fields that use a tree, map, grid, or drag-and-drop
						widget. </para>
					<para>To mark the end of the trigger definition, use the end statement.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.sqrt">
				<title>sqrt [DEPRECATED]</title>
				<warning>
					<para> The command <function>sqrt</function> was replaced by <link
							linkend="langref.dollar_sqrt">
							<function>$sqrt</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'sqrt' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_sqrt">
							<function>$sqrt</function>
						</link> was introduced to replace <literal>sqrt</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.tan">
				<title>tan [DEPREATED]</title>
				<warning>
					<para> The command <function>tan</function> was replaced by <link
							linkend="langref.dollar_tan">
							<function>$tan</function>
						</link> in Uniface 8. Compiling this statement will result in a compile
						warning: <literal>warning: 1000 - Deprecated function 'tan' used</literal>. </para>
					<para> In U8 the function <link linkend="langref.dollar_tan">
							<function>$tan</function>
						</link> was introduced to replace <literal>tan</literal>. </para>
					<para> Deprecated since: U8. </para>
				</warning>
			</sect1>
			<sect1 xml:id="langref.u_condition">
				<title>u_condition</title>
				<para>Provide a DBMS-independent profile for selection. </para>
				<sect2>
					<title>Syntax</title>
					<para>u_condition (Condition) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Condition—conditional statement used as a retrieve profile; can be a
						string, a field (or indirect reference to a field), a variable, or a
						function that evaluates to a string. The string can contain any legal
						conditional Proc expression, but each operand in the expression cannot
						contain yet another expression. In addition, if the string contains a Proc
						status function, for example $fieldmod, that is not allowed in a service or
						report, that Condition is only allowed in a form. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>For values returned in status, see read or show, as appropriate.</para>
					<table>
						<title>Table 1. Value commonly returned by $procerror following the
							u_condition clause. See read or selectdb for additional values. </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1301 </entry>
									<entry> &lt;UPROCERR_SYNTAX&gt; </entry>
									<entry> Syntax error. </entry>
								</row>
								<row>
									<entry> -1302 </entry>
									<entry> &lt;UPROCERR_SERVICE&gt; </entry>
									<entry> Function not allowed in service. </entry>
								</row>
								<row>
									<entry> -1303 </entry>
									<entry> &lt;UPROCERR_REPORT&gt; </entry>
									<entry> Function not allowed in report. </entry>
								</row>
								<row>
									<entry> -1304 </entry>
									<entry> &lt;UPROCERR_UNKNOWN_CONTEXT&gt; </entry>
									<entry> Function not allowed, unknown context. </entry>
								</row>
								<row>
									<entry> -1305 </entry>
									<entry> &lt;UPROCERR_EXPRESSION&gt; </entry>
									<entry> Expression not allowed. </entry>
								</row>
								<row>
									<entry> -1306 </entry>
									<entry> &lt;UPROCERR_CONDITION&gt; </entry>
									<entry> Condition not allowed. </entry>
								</row>
								<row>
									<entry> -1307 </entry>
									<entry> &lt;UPROCERR_EXTRACTION_EXPR&gt; </entry>
									<entry> Extraction expression is a condition. </entry>
								</row>
								<row>
									<entry> -1308 </entry>
									<entry> &lt;UPROCERR_INDIRECTION&gt; </entry>
									<entry> Indirection followed by brackets. </entry>
								</row>
								<row>
									<entry> -1309 </entry>
									<entry> &lt;UPROCERR_PARENTHESES&gt; </entry>
									<entry> Operand followed by parentheses. </entry>
								</row>
								<row>
									<entry> -1310 </entry>
									<entry> &lt;UPROCERR_BRACKETS&gt; </entry>
									<entry> Operand followed by square brackets. </entry>
								</row>
								<row>
									<entry> -1311 </entry>
									<entry> &lt;UPROCERR_UNRESOLVED_OPERAND&gt; </entry>
									<entry> A field, parameter, or variable could not be found in
										current context. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service, and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The u_condition clause is used to specify DBMS-independent selection
						criteria for a read or selectdb statement. Although u_condition is not a
						statement by itself, it is included here to avoid duplicating the
						information. u_condition cannot be used with u_where. The u_where and
						u_condition clauses are very similar. However, the u_condition clause is
						interpreted at run time, while u_where is interpreted at compilation. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The SelectionCriteria generated from
						the u_condition clause are passed to the DBMS driver. This data is limited
						to 8192 bytes. In addition, a maximum of 45 retrieve profile characters can
						be entered, including those on the u_condition as well as those entered on
						the form in a query-by-form action; if the search profile of a single field
						exceeds 512 bytes, it is truncated to 512 bytes. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example is taken from the Read trigger of an entity service. </para>
					<programlisting role="uniface"><![CDATA[; u_condition is interpreted at run-time, so the value
; of $uconditions$ provides a variable retrieve profile.
read u_condition($uconditions$)
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.u_where">
				<title>u_where</title>
				<para>Provide a DBMS-independent profile for selection with read and selectdb. </para>
				<sect2>
					<title>Syntax</title>
					<para>u_where ( SelectionCriteria ) </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>SelectionCriteria—one or more relational phrases with the operands linked
						by relational operators (&lt;, !=, and so on), connected by logical
						operators (&amp;, |, and so on). The operand to the left of the operator
						must be a field in an entity; the operand to the right can be a value.
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>See read or selectdb, as appropriate.</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The u_where clause is used to specify DBMS-independent selection criteria
						for a read or selectdb statement. It is not an independent Proc statement.
						u_where cannot be used with u_condition. </para>
					<para>The SelectionCriteria generated from the u_where clause are passed to the
						DBMS driver. This data is limited to 8192 bytes. In addition, a maximum of
						45 retrieve profile characters can be entered, including those on the
						u_where clause as well as those entered on the form in a query-by-form
						action; if the search profile of a single field exceeds 512 bytes, it is
						truncated to 512 bytes. </para>
				</sect2>
				<sect2>
					<title>Selection Criteria</title>
					<para>Possible profile characters are always stripped from the
						SelectionCriteria, with the exception of "*" and "?", which are treated as
						literals. For example: </para>
					<programlisting role="uniface"><![CDATA[read u_where (NAME = "A|B")
]]></programlisting>
					<para>results in the following SelectionCriteria: </para>
					<programlisting role="uniface"><![CDATA[NAME = "AB"
]]></programlisting>
					<para>In each relational phrase in the selection criteria, the operand to the
						left of the relational operator refers to a field in an entity. By default,
						it is to a field in the current entity. To specify another entity, qualify
						the field name with the entity name, for example, PAY_BY_DATE.INVOICE. If a
						value is used as the first operand, the criteria will not be evaluated
						correctly.</para>
					<para>The operand to the right of the relational operator determines whether the
						relational phrase refers to values in the database or in the component. The
						rules for this are: </para>
					<itemizedlist>
						<listitem>
							<para>If the field following the operator is in the same entity and no
								substitution or format conversion is applied, Uniface uses the
								database value of that field when evaluating the statement. </para>
						</listitem>
						<listitem>
							<para>If the field following the operator is not in the same entity,
								Uniface uses the component value of that field when evaluating the
								statement. The field must be present in the component. </para>
						</listitem>
						<listitem>
							<para>If the field following the operator is preceded by a string
								substitution marker (%%) or a format conversion function (for
								example, $number or $date), Uniface uses the component value of that
								field when evaluating the statement. </para>
						</listitem>
					</itemizedlist>
					<para>Figure 1. Using a database value from the same entity in u_where select
						criteria</para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_11.jpg"/>
						</imageobject>
					</mediaobject>
					<para> Figure 2. Using component values from two entities in u_where select
						criteria</para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_12.jpg"/>
						</imageobject>
					</mediaobject>
					<para> Figure 3. Using a component value with a function in u_where select
						criteria </para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/fig13_13.jpg"/>
						</imageobject>
					</mediaobject>
				</sect2>
				<sect2>
					<title>Performance Considerations</title>
					<para>Although u_where is DBMS-independent (that is, it works with every DBMS
						supported by Uniface), performance when using u_where can vary greatly.
						Performance depends both on the way you code the Proc module and on the DBMS
						you are using. This is because Uniface leaves the evaluation of the
						statement to the DBMS, where possible; if the DBMS cannot handle this,
						Uniface does it itself. Leaving it to the DBMS is almost always faster. </para>
					<para>Generally, record-level DBMSs, such as RMS, cannot perform this sort of
						selection. Instead, the driver and Uniface have to perform the relevant
						sorting, and, if used in conjunction with selectdb, the aggregate function.
						In a record-level environment, it is not possible for the DBMS driver to
						specify a preferred index for selecting records when using selectdb in
						combination with a u_where clause. Instead, the primary key index is used.
						If this is not the field you are referring to, you can expect poor
						performance. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example causes all occurrences of the relevant entities to
						be retrieved for which the following conditions are true: </para>
					<itemizedlist>
						<listitem>
							<para>NAME begins with 'A'. </para>
						</listitem>
						<listitem>
							<para>SALARY is greater than or equal to 4975. </para>
						</listitem>
					</itemizedlist>
					<programlisting role="uniface"><![CDATA[read u_where ((name = "A<emphasis role="underline">*</emphasis>") &amp; (salary &gt;= 4975))
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example retrieves the average salary and the number of
						employees from the employee database for which the following conditions are
						true: </para>
					<itemizedlist>
						<listitem>
							<para>The employee’s salary is less than or equal to 4975. </para>
						</listitem>
						<listitem>
							<para>The employee’s age is less than or equal to 25. </para>
						</listitem>
					</itemizedlist>
					<para>The resulting average salary value is loaded into the field AVERAGE.DUMMY
						and the total number of occurrences is loaded into the field TOTAL.DUMMY.
						(Note the use of the continuation markers to improve legibility.) </para>
					<programlisting role="uniface"><![CDATA[$3 = 4975
selectdb (ave(SALARY), count(NAME)) %\
   from EMPLOYEE %\
   u_where ((SALARY &lt;= $3) &amp; (birthdate &lt;= $date(01-01-1972)) %\
   to (AVERAGE.DUMMY, TOTAL.DUMMY)
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows how to use a global variable to supply a
						clause value to the read statement. The global variable is called $$NAME,
						the field being selected on is called FNAME: </para>
					<programlisting role="uniface"><![CDATA[read u_where (FNAME = "%%$$name")
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.until">
				<title>until</title>
				<para> Introduced in: U9 </para>
				<para>Clause in a repeat statement that must evaluate to TRUE before the repeat loop
					can complete.</para>
				<sect2>
					<title>Syntax</title>
					<para>See repeat.</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.uppercase">
				<title>uppercase [DEPRECATED]</title>
				<para>Convert a string to uppercase. </para>
				<sect2>
					<title>Syntax</title>
					<para>uppercase Source , Target </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>Source—content to convert to uppercase; can be a string, or a
								field (or indirect reference to a field), a variable, or a function
								that evaluates to a string. </para>
						</listitem>
						<listitem>
							<para>Target—destination of converted content; can be a field or
								variable that can accept a string value. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The uppercase statement converts the contents of Source to uppercase, then
						places the result in Target. </para>
					<para>Conversion is on a character-by-character basis as defined by
						Unicode.</para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Locale-based processing rules are
						not applies when using uppercase. If this is desired, use $uppercase.
					</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example converts the contents of vString1 to uppercase: </para>
					<programlisting role="uniface"><![CDATA[vString1 = "abc"
uppercase vString1, vString2
;Result: : vString2 = "ABC"
 ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.validate">
				<title>validate</title>
				<para>Validate all data marked as modified. </para>
				<sect2>
					<title>Syntax</title>
					<para>validate{/switch} {Entity} DVO - between brackets is optional, this way of
						syntaxing stuff deprecates the other three ways below</para>
					<para>validate </para>
					<para>validate/e {Entity} </para>
					<para>validate/o {Entity} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist>
						<listitem>
							<para>/e—only the modified occurrences of Entity and the entities
								painted within Entity are validated. </para>
						</listitem>
						<listitem>
							<para>/o—only the current occurrence of Entity and its inner entities
								are validated. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity whose data is to be validated. Can be a string, or a field,
						variable, function, or parameter that evaluates to a string containing the
						entity name. If omitted, the current entity ($entname) is used.</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The values returned in $status following validate are: </para>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Statement executed successfully</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							validate</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -34 </entry>
									<entry> &lt;UGENERR_CURRENCY&gt; </entry>
									<entry> Changes to the active path not allowed. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -300 </entry>
									<entry> &lt;UVALERR_SYNTAX&gt; </entry>
									<entry> An error in declarative syntax occurred. </entry>
								</row>
								<row>
									<entry> -303 </entry>
									<entry> &lt;UVALERR_KEY_EMPTY&gt; </entry>
									<entry> A key field is empty. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Whenever one or more errors occur, the function $dataerrorcontext contains
						information about the exact context of the error first validation error
						encountered by validate; the function $procerrorcontext indicates the exact
						location of this error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, session service, entity service,
						service components (and in report components that are not self-contained).
					</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The validate statement builds a list of data within the component that is
						marked as modified and has not previously been successfully validated. It
						then activates the necessary Validate Field, Validate Key, and Validate
						Occurrence triggers for each modification. For example, if a modified
						non-key field needs to be validated, only the Validate Field and Validate
						Occurrence triggers are activated. </para>
					<para>As each stage of the validation process completes successfully, the
						corresponding validation flag ($fieldvalidation, $keyvalidation,
						$occvalidation) is set to 0. When the entire process completes successfully,
						$instancevalidation is set to 0. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Validation statements
						(validatefield, validatekey, validateocc, and validate) activate the
						Validate triggers (Validate Field, Validate Key, and Validate Occurrence
						triggers). You should therefore be careful when using these statements in
						Validate triggers. </para>
					<para>Used without a switch, the validate statement validates all modified data
						within the component. The scope of the modified data to be validated can be
						restricted by supplying one of the switches. </para>
				</sect2>
				<sect2>
					<title>Sequence of validation</title>
					<para>During the validation process, the data in the component is searched in a
						depth-first fashion, traversing the occurrences in the component structure
						from top to bottom, left to right, validating occurrences of the inner
						entities before validating the outer occurrence. For each occurrence that
						needs validating, the following actions occur: </para>
					<orderedlist>
						<listitem>
							<para>For the primary key: <itemizedlist>
									<listitem>
										<para>Declarative checks and Validate Field trigger, for
											each field of the primary key that needs validation
										</para>
									</listitem>
									<listitem>
										<para>Validate Key trigger, for the primary key, if the
											primary key needs validation </para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>For each candidate key: <itemizedlist>
									<listitem>
										<para>Declarative checks and Validate Field trigger, for
											each field of the candidate key that needs validation
										</para>
									</listitem>
									<listitem>
										<para>Validate Key trigger, for the candidate key, if the
											Validate property for the candidate key is clicked
												<emphasis role="italic">on </emphasis>(on the Define
											Key form) and the candidate key needs validation </para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>For each remaining field that has been modified: <itemizedlist>
									<listitem>
										<para>Declarative checks </para>
									</listitem>
									<listitem>
										<para>Validate Field trigger, if the field needs validation
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>For the occurrence: <itemizedlist>
									<listitem>
										<para>Declarative checks </para>
									</listitem>
									<listitem>
										<para>Validate Occurrence trigger, if the occurrence needs
											validation </para>
									</listitem>
								</itemizedlist></para>
						</listitem>
					</orderedlist>
					<para>The extent of the activation of triggers depends on the particular
						validation Proc statements used. This is summarized in the following table: </para>
					<table>
						<title>Table 3. Activation of triggers during validation</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Statement </entry>
									<entry> Validate Field trigger activated ... </entry>
									<entry> Validate Key trigger activated ... </entry>
									<entry> Validate Occurrence trigger activated ... </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> validate <emphasis role="italic">For all occurrences in
											the component: </emphasis></entry>
									<entry> All fields that need validation </entry>
									<entry> All keys that need validation </entry>
									<entry> All occurrences that need validation </entry>
								</row>
								<row>
									<entry> validate/e <emphasis role="italic">For all occurrences
											of the specified entity and all its inner entities:
										</emphasis></entry>
									<entry> All fields that need validation </entry>
									<entry> All keys that need validation </entry>
									<entry> All occurrences that need validation </entry>
								</row>
								<row>
									<entry> validate/o <emphasis role="italic">For the specified
											occurrence and all its inner entities:
										</emphasis></entry>
									<entry> All fields that need validation </entry>
									<entry> All keys that need validation </entry>
									<entry> All occurrences that need validation </entry>
								</row>
								<row>
									<entry> validateocc <emphasis role="italic">For the specified
											occurrence (no inner entities): </emphasis></entry>
									<entry> All fields that need validation </entry>
									<entry> All keys that need validation </entry>
									<entry> That occurrence only </entry>
								</row>
								<row>
									<entry> validatekey <emphasis role="italic">For the specified
											key: </emphasis></entry>
									<entry> All key fields that need validation </entry>
									<entry> That key only </entry>
									<entry> — </entry>
								</row>
								<row>
									<entry> validatefield <emphasis role="italic">For the specified
											field: </emphasis></entry>
									<entry> That field only </entry>
									<entry> — </entry>
									<entry> — </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example: validate</title>
					<para>The following example validates all modified (and nonvalidated)
						occurrences of the entity CUSTOMER, along with modified occurrences of any
						inner entities: </para>
					<programlisting role="uniface"><![CDATA[$MYENTITY$ = "CUSTOMER"
validate/e "%%$MYENTITY$"
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.validatefield">
				<title>validatefield</title>
				<para>Validate a field of the current occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>validatefield Field </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para> Field—field to validate; can be a literal name, an indirect reference to
						a field, a string, or a variable, function, or parameter that evaluates to a
						string. </para>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Statement executed successfully</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							validatefield</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -34 </entry>
									<entry> &lt;UGENERR_CURRENCY&gt; </entry>
									<entry> Changes to the active path not allowed. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -300 </entry>
									<entry> &lt;UVALERR_SYNTAX&gt; </entry>
									<entry> An error in declarative syntax occurred. </entry>
								</row>
								<row>
									<entry> -1101 </entry>
									<entry> &lt;UPROCERR_FIELD&gt; </entry>
									<entry> An incorrect field name was provided; either the field
										name is not valid syntactically or the field is not
										available in the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Whenever an error occurs, the field-level On Error is activated. The
						function $dataerrorcontext contains information about the exact context of
						the error, and the function $procerrorcontext indicates the exact location
						of the error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, session service, entity service,
						(and in report components that are not self-contained). </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The validatefield statement validates the specified field of the current
						occurrence. If the field is marked as modified and has not been successfully
						validated or if $fieldcheck is 1, declarative checks for Field are performed
						and the Validate Field trigger is activated. (The section titled ‘Sequence
						of validation’ in the discussion of the validate statement describes the
						sequence and extent of declarative checks and trigger activation.) </para>
					<para>If the field is successfully validated, the Validate Field trigger sets
						$fieldvalidation to 0. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Validation statements
						(validatefield, validatekey, validateocc, and validate) activate the
						Validate triggers (Validate Field, Validate Key, and Validate Occurrence
						triggers). You should therefore be careful when using these statements in
						Validate triggers. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<programlisting role="uniface"><![CDATA[$MYFIELD$ = "CUSTID.CUSTOMER"
validatefield $MYFIELD$
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.validatekey">
				<title>validatekey</title>
				<para>Validate a key of the current occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>validatekey Entity{, KeyNumber} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Entity—entity in which a key is to be validated. Can be a
									string, or a field, variable, function, or parameter that
									evaluates to a string containing the entity name. </para>
							</listitem>
							<listitem>
								<para>KeyNumber—key that is to be located (as defined for Entity on
									the Define Key form); can be constant, or a field (or indirect
									reference to a field), a variable, or a function that can be
									converted to a whole (integer) number; the value will be
									truncated to form an integer. </para>
								<para>If omitted, the default value of 1 (the primary key) is
									chosen. Higher KeyNumbers (2, 3, 4, and so on) identify a
									candidate key depending upon your model definition. Indexes are
									not allowed. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Statement executed successfully</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							validatekey</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -34 </entry>
									<entry> &lt;UGENERR_CURRENCY&gt; </entry>
									<entry> Changes to the active path not allowed. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -300 </entry>
									<entry> &lt;UVALERR_SYNTAX&gt; </entry>
									<entry> An error in declarative syntax occurred. </entry>
								</row>
								<row>
									<entry> -302 </entry>
									<entry> &lt;UVALERR_KEY_PROFILE&gt; </entry>
									<entry> A key field contains a profile character or the key is
										incomplete. </entry>
								</row>
								<row>
									<entry> -303 </entry>
									<entry> &lt;UVALERR_KEY_EMPTY&gt; </entry>
									<entry> A key field is empty. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1104 </entry>
									<entry> &lt;UPROCERR_KEY&gt; </entry>
									<entry> The key number provided is not valid; for example, the
										key number was out of range. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Whenever an error occurs, the entity-level On Error is activated. The
						function $dataerrorcontext contains information about the exact context of
						the error, and the function $procerrorcontext indicates the exact location
						of the error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, session service, entity service, and
						service components (and in report components that are not self-contained).
					</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The validatekey statement validates the specified key of the current
						occurrence of Entity. If any field of the key is marked as modified and has
						not been successfully validated, the necessary Validate Field triggers and
						the Validate Key trigger are activated. (For more information on the
						sequence and extent of declarative checks and trigger activation, see
						validate.) </para>
					<para>As each field of the key is successfully validated, the corresponding
						validation flag ($fieldvalidation) is set to 0. When the entire key is
						successfully validated, $keyvalidation is set to 0. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Validation statements
						(validatefield, validatekey, validateocc, and validate) activate the
						Validate triggers (Validate Field, Validate Key, and Validate Occurrence
						triggers). You should therefore be careful when using these statements in
						Validate triggers. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following operation validates a new primary key that it receives as an
						argument: </para>
					<programlisting role="uniface"><![CDATA[operation NEWKEYCHECK
params
   string NEWKEY : IN
   boolean OK : OUT
endparams
PK1.MYENT = NEWKEY
validatekey "MYENT", 1
if ($status = 0)
  OK = &lt;TRUE&gt;
else
  OK = &lt;FALSE&gt;
endif ]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.validateocc">
				<title>validateocc</title>
				<para>Validate an occurrence. </para>
				<sect2>
					<title>Syntax</title>
					<para>validateocc {Entity} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Entity—entity whose data is to be validated. Can be a string, or a field,
						variable, function, or parameter that evaluates to a string containing the
						entity name. If omitted, the current entity ($entname) is used. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> &gt;=0</entry>
									<entry> Statement executed successfully</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							validateocc</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -34 </entry>
									<entry> &lt;UGENERR_CURRENCY&gt; </entry>
									<entry> Changes to the active path not allowed. </entry>
								</row>
								<row>
									<entry> -35 </entry>
									<entry> &lt;UGENERR_4GL_SAYS_ERROR&gt; </entry>
									<entry> A trigger returned a negative value in $status. </entry>
								</row>
								<row>
									<entry> -300 </entry>
									<entry> &lt;UVALERR_SYNTAX&gt; </entry>
									<entry> An error in declarative syntax occurred. </entry>
								</row>
								<row>
									<entry> -302 </entry>
									<entry> &lt;UVALERR_KEY_PROFILE&gt; </entry>
									<entry> A key field contains a profile character or the key is
										incomplete. </entry>
								</row>
								<row>
									<entry> -303 </entry>
									<entry> &lt;UVALERR_KEY_EMPTY&gt; </entry>
									<entry> A key field is empty. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> &lt;UPROCERR_ENTITY&gt; </entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>Whenever an error occurs, the entity-level On Error is activated. The
						function $dataerrorcontext contains information about the exact context of
						the error, and the function $procerrorcontext indicates the exact location
						of the error. </para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, session service, entity service, and
						service components (and in report components that are not self-contained).
					</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The validateocc statement validates the current occurrence of Entity. If
						any field of the occurrence is marked as modified and has not been
						successfully validated, the necessary Validate Field, Validate Key, and
						Validate Occurrence triggers are activated. (For more information on the
						sequence and extent of declarative checks and trigger activation, see
						validate. ) </para>
					<para>validateocc validates only the current occurrence; it does not validate
						related inner entities. In contrast, the validate/o statement validates all
						inner entities in addition to the current occurrence. </para>
					<para>You can use the function $occvalidation to determine if an occurrence
						requires validation. </para>
					<para>As each stage of the validation process completes successfully, the
						corresponding validation flag ($fieldvalidation and $keyvalidation) is set
						to 0. When the entire process completes successfully, $occvalidation is set
						to 0. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> Validation statements
						(validatefield,validatekey, validateocc, and validate) activate the Validate
						triggers (Validate Field, Validate Key, and Validate Occurrence triggers).
						You should therefore be careful when using these statements in Validate
						triggers. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>
						<programlisting role="uniface"><![CDATA[$MYOCC$ = "CUSTID.CUSTOMER"
validateocc $MYOCC$
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.variables">
				<title>variables</title>
				<para>Define the local variables for an application, component, or Proc module. </para>
				<sect2>
					<title>Syntax</title>
					<para>variables </para>
					<para> VariableSpec 1 VariableName 1 </para>
					<para>...</para>
					<para> VariableSpec n VariableName n </para>
					<para>endvariables </para>
					<para>VariableSpec can be any of the following: </para>
					<itemizedlist>
						<listitem>
							<para>DataType </para>
						</listitem>
						<listitem>
							<para>{public | partner} handle {SignatureName} </para>
						</listitem>
						<listitem>
							<para>xmlstream [DTD: DTDName ] </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>VariableSpec—variable specification </para>
							</listitem>
							<listitem>
								<para>VariableName—name of the variable. It has a maximum length of
									32 characters, including letters (A-Z), digits (0-9), and
									underscores (_); the first character must be a letter. A local
									variable cannot have the same name as a named parameter in the
									same module or operation. </para>
							</listitem>
							<listitem>
								<para>BasicDataType—a Uniface data type </para>
							</listitem>
							<listitem>
								<para>SignatureName—name of a component signature </para>
							</listitem>
							<listitem>
								<para>DTDName—name of the DTD that defines the structure of XML
									stream variables; can be one of the following: <itemizedlist>
										<listitem>
											<para>String that evaluates to the name of a DTD in the
												format LitDTDName{. LitModelName} where LitDTDName
												is a literal DTD name defined in the application
												model LitModelName </para>
										</listitem>
										<listitem>
											<para>Component constant that evaluates to a literal DTD
												name during compilation. </para>
										</listitem>
										<listitem>
											<para>Global or component variable that evaluates to a
												string that contains the name of a DTD. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>...</para>
					<para>Allowed in all components (component and local variables) </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>If a params block is present, the variables block must follow that;
						otherwise, it must be the first statement present. </para>
					<para>The value of a local variable is set to NULL at the start of the Proc
						module. </para>
					<para>Variable definitions of the same data type can occur on one line. For
						example: </para>
					<programlisting role="uniface"><![CDATA[; Single line
variables
   string STRING1, STRING2, STRING3
endvariables
]]></programlisting>
					<para>Uniface generates warnings and errors in the following
						circumstances:</para>
					<itemizedlist>
						<listitem>
							<para>A field exists with the same name as a local variable (warning).
							</para>
						</listitem>
						<listitem>
							<para>A variable is defined more than once in one variable block
								(error). </para>
						</listitem>
						<listitem>
							<para>Declared component variable is not used. (info message). </para>
						</listitem>
						<listitem>
							<para>Variable type mismatches (info message); for example:
								<programlisting role="uniface"><![CDATA[variables
  string Counter
endvariables
  counter = counter + 1  ; results in an info warning
]]></programlisting></para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Scope of Variables</title>
					<para>The scope of variables defined with the variables statement depends on
						where they are declared. Local variables must be declared at the beginning
						of a Proc module (trigger, operation, or entry). </para>
					<para>A local variable exists only in the operation or module in which it is
						defined. Its scope is limited to that operation or module. It cannot be
						directly referenced from another operation or module in the component, or
						from a local or global Proc called by the operation or module. If a local
						variable has the same name as a field in the component, then the local
						variable takes precedence over the field; to access the field, you must use
						the qualified field name. </para>
					<para>For example, consider a component that contains a field named DATE in the
						entity PO. The operation TODAY has a local variable, DATE. To update the
						field DATE, the field must be referenced by its qualified name, including
						its entity: </para>
					<programlisting role="uniface"><![CDATA[operation TODAY
variables
   date DATE
endvariables
;assign the current date to local variable DATE
DATE = $date
;assign the current date to field DATE.PO
DATE.PO = DATE
...
end ; operation TODAY
]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The operation, SWAP_STRINGS, in the following example swaps the contents
						of two strings: </para>
					<programlisting role="uniface"><![CDATA[operation SWAP_STRINGS
params
   string STR1 : INOUT
   string STR2 : INOUT
endparams
variables
   string TEMPSTR
endvariables
TEMPSTR = STR1
STR1 = STR2
STR2 = TEMPSTR
end; SWAP_STRINGS
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.web">
				<title>web</title>
				<para> Introduced in: U9 </para>
				<para>Determines whether the trigger or operation in which the web statement is used
					can be called from a web browser in a dynamic request-response exchange.</para>
				<sect2>
					<title>Syntax</title>
					<para>public | partner web </para>
					<para>{Scope Declaration}</para>
				</sect2>
				<sect2>
					<title>Arguments</title>
					<itemizedlist>
						<listitem>
							<para>public—the trigger or operation can be called by the browser. Data
								specified in the scope declaration is included in the DSP
								request-response exchange. </para>
						</listitem>
						<listitem>
							<para>partner—the trigger or operation can only be called by Uniface and
								not by the browser. However the data specified in the scope
								declaration can be included in the DSP request-response exchange of
								other triggers or operations. </para>
						</listitem>
						<listitem>
							<para>Scope Declaration—see scope </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed only in Dynamic Server Page components in the following
						locations:</para>
					<itemizedlist>
						<listitem>
							<para>Execute trigger </para>
						</listitem>
						<listitem>
							<para>Any operation </para>
						</listitem>
						<listitem>
							<para>Any field trigger that is valid for the assigned widget. For valid
								triggers, see the specific widget description. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.webdefinitions">
				<title>webdefinitions</title>
				<para> Introduced in: U9 </para>
				<para>Use the current component to load channels in the $webinfo.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$webdefinitions</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Use only in dynamic server pages</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>Using the information provided in the web widget mappings in <emphasis
							role="bold">uweb.ini</emphasis>, the webdefinitions loads the following
						information into $webinfo channels:</para>
					<itemizedlist>
						<listitem>
							<para>Component definitions for the current component are loaded into
								the Definitions channel. These definitions can include properties,
								initial values, and valrep lists. </para>
						</listitem>
						<listitem>
							<para>Names of JavaScript files for the current component's web widgets
								are loaded into the JavaScript channel. </para>
						</listitem>
						<listitem>
							<para>All references to CSS files in the current component are loaded
								into the css channel. </para>
						</listitem>
					</itemizedlist>
					<para>By default, the data is appended to each channel. This allows multiple
						component definitions to be handled by one channel without Proc
						intervention. If this behavior is not desired, you must explicitly clear
						each channel before calling webdefinitions.</para>
					<para>The webdefinitions statement ensures that both the CSS and the JavaScript
						channels do not contain duplicate references to CSS or JavaScript files.
					</para>
				</sect2>
				<sect2>
					<title>Example: Set State for DSP</title>
					<para>The default code of the DSP Set State trigger generates the initial page
						or a page updated, depending on the value of $webresponsetype. The following
						example shows a simplified version of this code (excluding the error
						handling.)</para>
					<programlisting role="uniface"><![CDATA[selectcase $webresponsetype
case "UPDATE"         ; Update page
  websave               ; Generate data
case "FULLPAGE"       ; Initial page
  weblayout             ; Generate layout
  webdefinitions        ; Generate component definitions
  websave               ; Generate data
endselectcase]]></programlisting>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>In this example <emphasis role="bold">myScript.js</emphasis> is assigned
						to $webinfo ("javascript"). When webdefinitions is called, the necessary
						JavaScripts for the current component are added.</para>
					<programlisting role="uniface"><![CDATA[ 
; assign mySscript.js
$webinfo("javascript") = "myScript.js"
putmess $webinfo("javascript")
; only myscript.js is printed
; Running web definitions appends the default javascript files. 
webdefinitions]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.webgen">
				<title>webgen</title>
				<para> Introduced in: U8 </para>
				<para>Generate an XHTML document from the layout definition and the component
					definition of a server page. </para>
				<sect2>
					<title>Syntax</title>
					<para>webgen{/append} {LayoutFile}{, OutputFile} </para>
				</sect2>
				<sect2>
					<title>Switches</title>
					<para>/append—appends the generated XHTML document to an existing OutputFile. If
						OutputFile does not exist, a new file is created. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>LayoutFile—name of the file to be used as a layout definition
									of the server page; can be a string, or a field (or indirect
									reference to a field), a variable, or a function that evaluates
									to a string, with a maximum length of 79 bytes. No default
									extension is provided for LayoutFile. If LayoutFile does not
									exist, the layout definition of a server page is determined by
									$SEARCH_SKELETON. </para>
							</listitem>
							<listitem>
								<para>OutputFile—name of the file to contain the generated document;
									can be a string, or a field (or indirect reference to a field),
									a variable, or a function that evaluates to a string, with a
									maximum length of 79 bytes. No default extension is provided for
									OutputFile. If OutputFile does not exist, a new file is created.
									If OutputFile exists, that file is overwritten, unless the
									/append switch is used. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>

					<table>
						<title>Table 1. Values returned by webgen in $status</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Explanation</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &gt;0 </entry>
									<entry> Number of times that an unknown field or entity in the
										layout definition was skipped while preparing the XHTML
										document. If the layout definition contains references to
										fields or entities that are not present in the component
										definition, this is not considered an error. The affected
										part of the layout is simply skipped. However, the total
										number of fields and entities skipped is reported in
										$status. </entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> No errors detected, all field values transferred.
									</entry>
								</row>
								<row>
									<entry> &lt; 0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> License error. The current license does not include the
										WebApplication Server or has expired. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error. A network protocol error occurred during
										communication with the WebApplication Server. </entry>
								</row>
								<row>
									<entry> -21 </entry>
									<entry> The layout definition is not found or it contains an
										incorrect layout. </entry>
								</row>
								<row>
									<entry> -23 </entry>
									<entry> When $web ="", OutputFile is not specified, or is the
										same as LayoutFile. </entry>
								</row>
								<row>
									<entry> -24 </entry>
									<entry> OutputFile could not be written. </entry>
								</row>
								<row>
									<entry> -25 </entry>
									<entry> An image file could not be written. </entry>
								</row>
								<row>
									<entry> -26 </entry>
									<entry> Nested iteration over the same entity. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values of $procerror commonly returned by webgen </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -31 </entry>
									<entry> &lt;UGENERR_LICENSE&gt; </entry>
									<entry> No license for requested action. Contact your Uniface
										representative. </entry>
								</row>
								<row>
									<entry> -250 </entry>
									<entry> &lt;UWEBERR_SKELETON&gt; </entry>
									<entry> Layout definition not found or incorrect. </entry>
								</row>
								<row>
									<entry> -251 </entry>
									<entry> &lt;UWEBERR_OUTFILE&gt; </entry>
									<entry> When $web is empty, the output file is not specified or
										is the same as the layout file. </entry>
								</row>
								<row>
									<entry> -252 </entry>
									<entry> &lt;UWEBERR_IO&gt; </entry>
									<entry> Could not write output file. </entry>
								</row>
								<row>
									<entry> -253 </entry>
									<entry> &lt;UWEBERR_IO_IMAGE&gt; </entry>
									<entry> Could not write image file. </entry>
								</row>
								<row>
									<entry> -254 </entry>
									<entry> &lt;UWEBERR_ITERATION&gt; </entry>
									<entry> Nested iteration over the same entity. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>

				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all form and server page components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The webgen statement generates an XHTML document from LayoutFile,
						replacing any field values (marked by &lt;X-SUBST&gt; and
						&lt;X-OCCURRENCE&gt; tags) with the current values in the component
						definition. </para>
					<itemizedlist>
						<listitem>
							<para>If the application was started by the Request Dispatcher
								($web="wrd") and the OutputFile argument is omitted, the generated
								document is passed to the Web server. </para>
						</listitem>
						<listitem>
							<para>If the OutputFile argument is specified, the generated document is
								written to the OutputFile. </para>
						</listitem>
					</itemizedlist>
					<para>The names of LayoutFile and OutputFile are subject to non-DBMS file
						assignments in the [FILES] section of the assignment file. </para>
					<para>Always do a store operation before webgen, because webgen creates
						different XHTML for fields that are stored in a database. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> If there are no parameters
						specified, webgen defaults to the current component name. </para>
				</sect2>
				<sect2>
					<title>Multiple Occurrences in HTML forms</title>
					<para>When a new XHTML page is generated with the webgen statement, Uniface
						parses the layout definition. When the entity is surrounded by
						&lt;X-OCCURRENCE&gt; tags, HTML fields are created for each occurrence
						currently in the component definition. To mark which occurrence is shown,
						the occurrence number is added to each field name. Outside
						&lt;X-OCCURRENCE&gt; tags, no occurrence number is added because it is
						assumed to be 1. </para>
					<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.webget">
				<title>webget</title>
				<para> Introduced in: U8 </para>
				<para>Load data from an HTML document into a server page and activate a Detail or On
					Error trigger if required. </para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$webget</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by webget in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0 </entry>
									<entry> No errors detected and all field values transferred, or
										On Error trigger is empty. </entry>
								</row>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> -2 </entry>
									<entry> License error. The current license does not include the
										WebApplication Server or it has expired. </entry>
								</row>
								<row>
									<entry> -3 </entry>
									<entry> A time-out occurred while waiting for input from the
										WebApplication Server. </entry>
								</row>
								<row>
									<entry> -4 </entry>
									<entry> The webget statement was used in an incorrect context:
										the current Uniface application was not started by the
										WebApplication Server (that is, $web=""). </entry>
								</row>
								<row>
									<entry> -5 </entry>
									<entry> No further input is expected, because no fill-out
										document has been generated. </entry>
								</row>
								<row>
									<entry> -6 </entry>
									<entry> One or more fields cannot be accessed. This occurs when
										field names mentioned in the fill-out document are not
										available in the current form in Uniface. </entry>
								</row>
								<row>
									<entry> -7 </entry>
									<entry> Form synchronization error, that is, the user has
										submitted an HTML document that does not correspond to the
										last one generated. It is, instead, a form generated by
										Uniface earlier in the same session. </entry>
								</row>
								<row>
									<entry> -16 </entry>
									<entry> Network error. A network protocol error occurred during
										communication with the WebApplication Server. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values of $procerror commonly returned by webget </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Error constant </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -31 </entry>
									<entry> &lt;UGENERR_LICENSE&gt; </entry>
									<entry> No license available for the requested action. Contact
										your Uniface representative </entry>
								</row>
								<row>
									<entry> -255 </entry>
									<entry> &lt;UWEBERR_NO_CGI&gt; </entry>
									<entry> You can only use webget in a Web run-time environment
										($web!=" "). </entry>
								</row>
								<row>
									<entry> -257 </entry>
									<entry> &lt;UWEBERR_ILLEGAL_ACT&gt; </entry>
									<entry> One or more fields are not accessible, that is, field
										names referenced in the skeleton file are not available in
										the current Uniface form. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>

				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Pages. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The webget statement loads the data that was submitted from a browser into
						the current server page. It creates new occurrences for each occurrence on
						the HTML request. Occurrences that are already stored in the database are
						reconnected to the database occurrence. When a button is pressed on the HTML
						page, the Detail trigger from the corresponding command button is fired. The
						webget statement gets the input from the internal $webinfo object. This can
						be accessed by $webinfo("input"). This input is an associated list with
						fieldname = value pairs. The list can be manipulated by setting the
						$webinfo("input") content from Proc. Each field name is the full description
						of Field.Entity.Model with the addition of an occurrence number. </para>
					<para>The first field of an new occurrence should be preceded by a special entry
						with field name equal to #. Entity.Model for a DBMS occurrence, and %.
						Entity.Model for a non-DBMS occurrence. The webget statement creates a new
						occurrence whenever it encounters a field in this format. When the field
						name corresponds with a Uniface command button, webget remembers this button
						and fires the Detail trigger after processing all input. Only one command
						button is remembered. </para>
					<para>
						<emphasis role="bold"> Note:</emphasis> The webget statement clears the
						input buffer after processing. Subsequent calls to webget do not produce any
						action. </para>
					<para> webget has its own procedure for handling errors. See Error Triggers in
						Web Applications </para>
				</sect2>
				<sect2>
					<title>Reconnecting Occurrences to the Database</title>
					<para>A Uniface Server Page is a stateless form that is only active for the
						duration of an user request. There is an important difference in the way
						occurrences are handled. When an XHTML page is created, Uniface adds
						additional information about each occurrence. It marks the beginning of each
						occurrence with information about the database state of that occurrence. If
						the occurrence was already stored in the database, the primary key of this
						occurrence is added so Uniface can restore the database context in the next
						request, and the CRC checksum is added. </para>
					<para>A CRC checksum mechanism provides a means of checking whether database
						occurrences have been modified <emphasis role="italic">after</emphasis> a
						browser requested the occurrence, and <emphasis role="italic"
							>before</emphasis> the browser returned the data to the server. </para>
					<para>Two hidden fields are added just before the first field. The names of this
						field starts with a hash character (#). The value of the field is the
						partially encoded primary key, and the CRC checksum. </para>
					<para>A non-database entity is preceded by a percent sign (%). In this case, no
						attempt is made to reconnect to the database. For example: </para>
					<itemizedlist>
						<listitem>
							<para>Existing occurrence of entity ORDER:
								<programlisting role="uniface"><![CDATA[&lt;INPUT TYPE="HIDDEN" NAME="#.ORDER.WEBAPP.1" VALUE="}/IC1"&gt;
&lt;INPUT TYPE="HIDDEN" NAME="#CRC.ORDER.WEBAPP.1" VALUE="6682E55"&gt;]]></programlisting>
							</para>
						</listitem>
						<listitem>
							<para>New occurrence of entity ORDER:
								<programlisting role="uniface"><![CDATA[&lt;INPUT TYPE="HIDDEN" NAME="#.ORDER.WEBAPP.1" VALUE=""&gt;
&lt;INPUT TYPE="HIDDEN" NAME=#CRC.ORDER.WEBAPP.1 VALUE=""&gt;]]></programlisting></para>
						</listitem>
					</itemizedlist>
					<para>When Uniface processes these field values during the webget command, it
						tries to load any occurrence that is marked as stored. It decodes the value
						from the additional hidden field, creates an empty occurrence, fills the
						primary key fields, and performs a retrieve/x action to load this occurrence
						from the database, and checks the checksum. </para>
					<para>If the value of the hidden field is empty, Uniface creates a new
						occurrence. </para>
					<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.weblayout">
				<title>weblayout</title>
				<para> Introduced in: U9 </para>
				<para>Copies the Web layout of the dynamic server page instance and prepares to send
					it to Web browser.</para>
				<sect2>
					<title>Syntax</title>
					<para> weblayout {FileName} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>FileName—name of a file containing the Web layout. If not specified, the
						layout is copied from the Repository definitions. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values Returned in $status and $procerror </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value</entry>
										<entry> Meaning</entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> 0</entry>
										<entry> Success</entry>
									</row>
									<row>
										<entry> &lt;0</entry>
										<entry> Error. $procerror contains the exact error.</entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Use only in dynamic server pages.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The weblayout copies the layout of a DSP component instance, either from
						an external file or from an internal layout, into the $webinfo ("LAYOUT")
						channel, in preparation for sending the page to the browser. </para>
				</sect2>
				<sect2>
					<title>Example: Set State for DSP</title>
					<para>The default code of the DSP Set State trigger generates the initial page
						or a page updated, depending on the value of $webresponsetype. The following
						example shows a simplified version of this code (excluding the error
						handling.)</para>
					<programlisting role="uniface"><![CDATA[selectcase $webresponsetype
case "UPDATE"         ; Update page
  websave               ; Generate data
case "FULLPAGE"       ; Initial page
  weblayout             ; Generate layout
  webdefinitions        ; Generate component definitions
  websave               ; Generate data
endselectcase]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.webload">
				<title>webload</title>
				<para> Introduced in: U9 </para>
				<para>Loads data from a JSON (Java Object Notation) stream into a component.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$webload</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>
						<table>
							<title>Table 1. Values returned in $status </title>
							<tgroup cols="3">
								<thead>
									<row>
										<entry> Value </entry>
										<entry> Meaning </entry>
									</row>
								</thead>
								<tbody>
									<row>
										<entry> -259</entry>
										<entry> Mismatch between the security hash of a field and
											the field value. This occurs when the value of a NED
											field has been modified by the browser or other web user
											agent. </entry>
									</row>
									<row>
										<entry> &lt;0 </entry>
										<entry> An error occurred. $procerror contains the exact
											error. </entry>
									</row>
									<row>
										<entry> 0 </entry>
										<entry> JSON stream successfully loaded</entry>
									</row>
									<row>
										<entry> &gt;0 </entry>
										<entry> JSON stream loaded, but could not find all the field
											and entity names specified in the default and local
											mappings. For each field not found, $status is
											incremented by 1. More information is available in the
											message frame if the assignment setting
											$TEST_MODE_COMPONENTS is set. </entry>
									</row>
								</tbody>
							</tgroup>
						</table>
					</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The webload statement transfers data from a JSON stream into a component.
						The data is loaded from the $webinfo ("input") channel directly into the
						component's data structure. </para>
					<para>webload does not interpret or initiate validation of data, so the data
						loaded by webload can include duplicates of occurrences already within the
						component, as well as occurrences marked for deletion. </para>
					<para>All occurrences loaded from a data stream (including occurrences marked
						for deletion) are displayed on forms and accessible in Proc. </para>
					<para>You can use the $JSON_INDENT and $JSON_SHOWNAMES assignment settings to
						make the JSON stream more human-readable for development and debugging
						purposes.</para>
				</sect2>
				<sect2>
					<title>Reconnect Loaded Data</title>
					<para>The webload statement also sets state flags used by reconnect. After every
						webload statement, you should use a reconnect statement to reconnect the
						loaded data with the data in the component and the database (if connected).
						reconnect removes duplicates of occurrences, removes occurrences marked for
						deletion from the component, and sets the appropriate modification
						flags.</para>
				</sect2>
				<sect2>
					<title>Triggers Fired by webload</title>
					<para>The webload statement fires the following triggers that can be used to to
						customize how a JSON stream is loaded into a component: </para>
					<itemizedlist>
						<listitem>
							<para>Pre Load Occurrence—fired immediately before an occurrence is
								loaded from a JSON stream into a component. The new occurrence is
								not yet available and cannot be accessed. </para>
							<para>This trigger tunes the execution of webload and websave. You can
								use this trigger to customize the process of loading a JSON stream
								into a component. </para>
						</listitem>
						<listitem>
							<para>Post Load Occurrence—fired immediately after an occurrence is
								loaded from a JSON stream into a component and after all On Error
								triggers caused by validation errors. The new occurrence is
								available and can be accessed. For example, use this trigger if an
								occurrence can be discarded, or the value for a derived field can be
								calculated. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example loads a text file containing JSON-formatted data
						with Japanese characters and data for a non-modeled (dummy) entity. </para>
					<para>The component structure contains one database entity JAPAN.JAPAN and a
						non-modeled entity containing two buttons. </para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/webloadExample.jpg"/>
						</imageobject>
					</mediaobject>
					<para>The following JSON data loads the data for the database fields as well as
						for the dummy fields.</para>
					<para>
						<emphasis role="bold"> Note:</emphasis> By default, fields and entities in
						JSON streams are identified by ID. Fully-qualified names for fields and
						entities are shown in the nm attribute only when you use the $JSON_SHOWNAMES
						assignment setting.</para>
					<programlisting role="uniface"><![CDATA[{ 
   "#2" : { 
    "nm" : "JAPAN.JAPAN",
    "type" : "entity",
    "occs" : [ 
     { 
      "id" : "BhJDMTIzNA==",
      "crc" : "00000021",
      "status" : "est",
      "#3" : { 
       "nm" : "ID.JAPAN.JAPAN",
       "value" : "1234"
      },
      "#4" : { 
       "nm" : "BRAND.JAPAN.JAPAN",
       "value" : "SONY"
      },
      "#5" : { 
       "nm" : "DESCRIPTION.JAPAN.JAPAN",
       "value" : "\u3044\u307E"
      }
     }
    ]
   },
   "#6" : { 
    "nm" : "DUM.JAPAN",
    "type" : "entity",
    "occs" : [ 
     { 
      "id" : "VE1QOjQ3ODM0M2RhXzFfYmJmNTAw",
      "crc" : "",
      "status" : "new",
      "#7" : { 
       "nm" : "PB1.DUM.JAPAN",
       "value" : "MickeyMouse"
      },
      "#8" : { 
       "nm" : "PB2.DUM.JAPAN",
       "value" : "DonaldDuck"
      }
     }
    ]
   }
  }
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.webmessage">
				<title>webmessage</title>
				<para> Introduced in: U9 </para>
				<para>Displays a message in a dialog box in the browser. </para>
				<sect2>
					<title>Syntax</title>
					<para>webmessage /info | /warning | /error Message {, PropertyList} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>/info, /warning, /error—specify the message severity; the dialog box
						displays a matching icon. </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>Message—message to be displayed. The interpretation of the
									message depends on the switch. </para>
							</listitem>
							<listitem>
								<para>PropertyList—associative list of one or more of the following
									property names,controlling the size and content of the dialog: <itemizedlist>
										<listitem>
											<para>xsize—horizontal size in pixels; value must be
												from 100 through 800. </para>
										</listitem>
										<listitem>
											<para>ysize—vertical size in pixels; value must be from
												100 through 500. </para>
										</listitem>
										<listitem>
											<para>buttontext—text on the confirmation button;
												default is OK is used. Text is truncated at 128
												characters. </para>
										</listitem>
										<listitem>
											<para>title—text of the title bar. When not defined,
												Uniface is used. Text is truncated at 128
												characters. </para>
										</listitem>
									</itemizedlist></para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Use in dynamic server pages</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>webmessage produces an asynchronous message box and does not stop
						JavaScript execution. Calling this function three times in a row causes
						three message boxes to appear in the browser.</para>
					<para>The dimensions of the message box can be controlled by xsize and ysize in
						the PropertyList. If they are not defined, the message box is sized to fit
						the data, with the minimum dimension of approximately 400 pixels. If the
						text is too long to fit, the message box wraps the text and displays a
						scroll bar. </para>
					<para><emphasis role="bold"> Note:</emphasis> For predictable behavior, it is
						recommended that you define at least the xsize of the message box.</para>
					<para>The appearance of the message dialog is determined the <emphasis
							role="bold">uwindow.css</emphasis> stylesheet. You can change the look
						and feel of the dialog by editing this file. </para>
					<para>The message severity, as indicated by the switch used, is by the following
						icons.</para>
					<table>
						<title>Table 1. Message Severity Icons</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Icon</entry>
									<entry> Severity</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<mediaobject>
											<imageobject>
												<imagedata fileref="images/info.gif"/>
											</imageobject>
										</mediaobject>
									</entry>
									<entry> Info</entry>
								</row>
								<row>
									<entry>
										<mediaobject>
											<imageobject>
												<imagedata fileref="images/warning.gif"/>
											</imageobject>
										</mediaobject>
									</entry>
									<entry> Warning</entry>
								</row>
								<row>
									<entry>
										<mediaobject>
											<imageobject>
												<imagedata fileref="images/error.gif"/>
											</imageobject>
										</mediaobject>
									</entry>
									<entry> Error</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>...<programlisting role="uniface"><![CDATA[
; Place your code here 
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.websave">
				<title>websave</title>
				<para> Introduced in: U9 </para>
				<para>Creates a JSON stream from the data in a component. </para>
				<sect2>
					<title>Syntax</title>
					<para>websave{/mod | /one} </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>
						<itemizedlist>
							<listitem>
								<para>/mod—includes only modified occurrences in the JSON stream
								</para>
							</listitem>
							<listitem>
								<para>/one—includes only current outer occurrence (with all inner
									occurrences) in the JSON stream </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>The output of websave returns the CRC, ID, and STATUS for every occurrence
						and is put in the $webinfo ("data") channel.</para>
					<table>
						<title>Table 1. Values returned in $status </title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value </entry>
									<entry> Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> &lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry> 0 </entry>
									<entry> Success</entry>
								</row>
								<row>
									<entry> &gt;0 </entry>
									<entry> Number of images for which a temporary file could not be
										created. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The websave statement creates a JSON stream from the data in a component.
						The stream is built from the complete hitlist, including occurrences
						currently marked for deletion. Occurrences and fields are selected from the
						data set based on switches used by the websave statement. </para>
					<para>The entities and fields included in the stream are defined by the
						component structure, so both database and non-database fields are included
						in the JSON stream. </para>
					<para>You can use the $JSON_INDENT and $JSON_SHOWNAMES assignment settings to
						make the JSON stream more human-readable for development and debugging
						purposes.</para>
				</sect2>
				<sect2>
					<title>Triggers Fired by websave</title>
					<para>The following triggers are fired by the websave statement and can be used
						to customize the process of saving a component into an JSON stream: </para>
					<itemizedlist>
						<listitem>
							<para>Pre Save Occurrence—fired immediately before an occurrence is
								saved from a component into a JSON stream. The occurrence is
								available and can be examined. For example, the value for a derived
								field can be calculated. </para>
						</listitem>
						<listitem>
							<para>Post Save Occurrence—fired immediately after an occurrence is
								saved from a component into an JSON stream. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Images</title>
					<para>When the component contains images from a database, the Uniface Server
						creates temporary image files in the project directory. If it does not have
						write privileges for the project directory, this action fails. The page is
						still presented to the browser, but with image load error icons in the
						locations of the images.</para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following code creates a JSON stream from a component's data structure
						and writes the result to the message frame. </para>
					<programlisting role="uniface"><![CDATA[clear
retrieve/e "ORDER.INOUTER"
websave
putmess $webinfo("data")
return]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.websetocc">
				<title>websetocc</title>
				<para> Introduced in: U9 </para>
				<para>Get a list of entity name and occurrence id from httprequestparams channel of
					$webinfo, and set the current occurrence according this list.</para>
				<sect2>
					<title>Syntax</title>
					<para>
						<command>$websetocc</command></para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>...</para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Return Values</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> 0</entry>
									<entry> Current occurrence has been successfully set.</entry>
								</row>
								<row>
									<entry> &lt;0</entry>
									<entry> An error occurred. $procerror contains the exact
										error.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 1. Values Commonly Returned by $procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry> Value</entry>
									<entry> Error constant</entry>
									<entry> Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry> -1</entry>
									<entry> &lt;UGENERR_ERROR&gt;</entry>
									<entry> An error occurred. Entity is the outer entity of a
										Record component. </entry>
								</row>
								<row>
									<entry> -1102 </entry>
									<entry> UPROCERR_ENTITY&gt;</entry>
									<entry> The entity name provided is not a valid name or the
										entity is not painted on the component. </entry>
								</row>
								<row>
									<entry> -1133 </entry>
									<entry> &lt;UPROCERR_OCC_NOT_FOUND&gt;</entry>
									<entry> Occurrence could not be found </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Server pages</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The websetocc statement is similar to setocc, but it sets the occurrence
						based on an ID instead of on hit list position.</para>
					<para>Before using websetocc, a parameter list of entity names and occurrence
						ID’s must be set in the channel $webinfo ("httprequestparams").</para>
					<para>The format of this list should satisfy the following, where E0…En is a
						nested entity list in which E0 is the top outer entity, and E1 through En
						are sequentially nested inner entities. </para>
					<itemizedlist>
						<listitem>
							<para>For any number Num, where 0&lt;=Num&lt;=n, the parameter pair of
								entity. Num = EntityNameNum ; occid. Num = EntityNameNumOccID
								specifies the current occurrence of entity EntityNameNum; </para>
						</listitem>
						<listitem>
							<para>websetocc will set the current occurrence following the order of
								index Num from 0 to n. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>$webinfo ("httprequestparams") contains the following parameter list for
						for nested entities ORDER (outer) and ORDERLINE (inner):</para>
					<programlisting role="uniface"><![CDATA[entity.0=ORDER.BOOKSTORE;occid.0=???;entity.1=ORDERLINE.BOOKSTORE;occid.1=???]]></programlisting>
					<para>You can use the following Proc to set the current occurrence after
						reconnect:</para>
					<programlisting role="uniface"><![CDATA[reconnect/readcheck
websetocc]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.while">
				<title>while</title>
				<para>Define a while/endwhile loop. </para>
				<sect2>
					<title>Syntax</title>
					<para>while ( Condition ) </para>
					<para> ... one or more Proc statements ... </para>
					<para>endwhile </para>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<para>Condition—expression that evaluates to a Boolean. Uniface converts any
						data types specified in the expression to boolean data types (see Implicit
						Type Conversion). For more information on the operators that can be used in
						expressions, see Operators. </para>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<para>None</para>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The while statement loops through all the following Proc statements (up to
						the associated endwhile) as long as Condition is evaluated as TRUE (that is,
						nonzero). The endwhile statement causes an implicit goto to the associated
						while statement. When Condition is FALSE (that is, 0), Uniface continues
						with the statements (if any) following the associated endwhile. </para>
					<para>It is advisable to indent all statements between the while and
						corresponding endwhile. </para>
					<para>If only one Proc statement is required for the while block, that statement
						can appear on the same line as the while instruction; in this case, do not
						include an endwhile. (You are advised not to use one-line while statements,
						since they make Proc code difficult to read and maintain.) </para>
					<para>Use the break statement to terminate a while loop early. </para>
					<para>Conditional statements such as if/endif, while/endwhile, and repeat/until
						can be nested up to 32 levels. </para>
				</sect2>
				<sect2>
					<title>Example</title>
					<para>The following example shows the use of the while statement: </para>
					<programlisting role="uniface"><![CDATA[; this code selects the occurence of F2.E1
; that matches NAMEDUMMY
if (F2.E1 != NAMEDUMMY)
   $CURR_OCC$ = $curocc
   $NAME$ = NAMEDUMMY
   $COUNTER$ = 1
   setocc "E1", $COUNTER$
   while ((F2.E1 != $NAME$) &amp; ($status &gt;= 0))
      $COUNTER$ = ($COUNTER$ + 1)
      setocc "E1", $COUNTER$
   endwhile
   if ($status &lt; 0)
      message "%%$NAME$ is not available."
      setocc "E1", $CURR_OCC$
      return (-1)
   endif
endif
$prompt = F2.E1
]]></programlisting>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.write">
				<title>write</title>
				<para> Write the current occurrence to the database </para>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned by write in $status </title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Value</entry>
									<entry>Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>0</entry>
									<entry>Data was successfully written. </entry>
								</row>
								<row>
									<entry>&lt;0</entry>
									<entry>An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry>-1</entry>
									<entry>No entities are painted on the component. </entry>
								</row>
								<row>
									<entry>-3</entry>
									<entry>Exceptional I/O error (hardware or software). </entry>
								</row>
								<row>
									<entry>-4</entry>
									<entry>Open request for table or file failed. The table or file
										is not painted, or it does not exist. </entry>
								</row>
								<row>
									<entry>-5 </entry>
									<entry>Update request for nonupdatable occurrence. </entry>
								</row>
								<row>
									<entry>-6</entry>
									<entry>Exceptional I/O error on write request; for example, lack
										of disk space, no write permission, or violation of a
										database constraint. Check the message frame for
										details.</entry>
								</row>
								<row>
									<entry>-7</entry>
									<entry>Duplicate key.</entry>
								</row>
								<row>
									<entry>-10</entry>
									<entry>Occurrence has been modified or removed since it was
										retrieved; the occurrence should be reloaded. </entry>
								</row>
								<row>
									<entry>-11</entry>
									<entry>Occurrence already locked. </entry>
								</row>
								<row>
									<entry>-15 </entry>
									<entry>Uniface network error. </entry>
								</row>
								<row>
									<entry>-16</entry>
									<entry>Network error: unknown. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror following
							write</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Value </entry>
									<entry>Error constant </entry>
									<entry>Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>-2 through -12</entry>
									<entry>&lt;UIOSERR_*&gt;</entry>
									<entry>Errors during database I/O. </entry>
								</row>
								<row>
									<entry>-16 through -30</entry>
									<entry>&lt;UNETERR_*&gt;</entry>
									<entry>Errors during network I/O. </entry>
								</row>
								<row>
									<entry>-1</entry>
									<entry>&lt;UGENERR_ERROR&gt;</entry>
									<entry>An error occurred. No entities are painted on the
										component.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in Uniface Server Page, form, service, session service, entity
						service and report components. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>The write statement writes an occurrence to the database. This statement
						should only be used in the Write or Write Up triggers. If fields of the
						occurrences have Proc code in their Encrypt trigger, the Encrypt triggers
						will be activated. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The following example uses the write statement in the Write trigger to
						log information about which user updated or created a particular occurrence.
						; &lt;Write&gt; trigger if ($dbocc = 0) CREATED_BY = $user CREATED_DATE =
						$date else UPDATED_BY = $user endif write </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.xmlload">
				<title>xmlload</title>
				<para> Introduced in: U8 </para>
				<para> Load data from an XML stream into occurrences drawn on the component. </para>
				<para> xmlload{/incldefmap}{/noprofile} XMLVariable, DTDName{, DTDMapping} </para>
				<sect2>
					<title>Switches</title>
					<itemizedlist spacing="compact">
						<listitem>
							<para> /incldefmap—instructs xmlload to use the default DTD mapping
								defined in the DTD Editor. </para>
						</listitem>
						<listitem>
							<para> /noprofile—escape sequences for profile characters and subfield
								separators are not converted to the corresponding profile character
								of subfield separator during xmlload. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist spacing="compact">
						<listitem>
							<para> XMLVariable—field, variable, or parameter containing the XML
								stream. </para>
						</listitem>
						<listitem>
							<para> DTDName—DTD used to validate the XML stream. </para>
							<para> DTDName— literal string, variable, or constant using the
								following format: </para>
							<para> {DTD:}Name.Model </para>
							<itemizedlist spacing="compact">
								<listitem>
									<para> DTD:—specifies that the XML stream is defined using a DTD
										(this is to ensure compatibility with future developments in
										the XML standard). </para>
								</listitem>
								<listitem>
									<para> Name—name of the DTD as specified in the application
										model. </para>
								</listitem>
								<listitem>
									<para> Model—name of the DTD's application model. </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para> DTDMapping—Uniface list mapping elements to field names. For more
								information, see Mapping Between Uniface and XML Streams. </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in $status</title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Value </entry>
									<entry>Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>&lt;0 </entry>
									<entry> An error occurred. $procerror contains the exact error.
									</entry>
								</row>
								<row>
									<entry>0</entry>
									<entry> XML stream successfully loaded</entry>
								</row>
								<row>
									<entry>&gt;0</entry>
									<entry> XML stream loaded, but could not find all the field and
										entity names specified in the default and local mappings.
										For each field not found, $status is incremented by 1. More
										information is available in the message frame if the
										assignment setting $TEST_MODE_COMPONENTS is set. </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> xmlload transfers data from an XML stream into a component. The data is
						loaded directly into the component's data structure. xmlload does not
						interpret or initiate validation of data, so the data loaded by xmlload can
						include duplicates of occurrences already within the component, as well as
						occurrences marked for deletion. </para>
					<para> All occurrences loaded from an XML stream (including occurrences marked
						for deletion) are displayed on forms and accessible in Proc. </para>
					<para> Note: The value of a boilerplate or control field cannot be loaded when
						using XMLLOAD. Only fields of the type database or non-database are allowed
						in XML streams. </para>
				</sect2>
				<sect2>
					<title>Reconnect Loaded Data</title>
					<para> After every xmlload statement, you should use a retrieve/reconnect
						statement to reconnect the loaded data with the data in the component and
						the database (if connected). retrieve/reconnect removes duplicates of
						occurrences, removes occurrences marked for deletion from the component, and
						sets the appropriate modification flags. </para>
					<para> Note: Use clear before data retrieved from a database is uploaded on the
						client, so all occurrences have the required initial (unmodified) state.
					</para>
				</sect2>
				<sect2>
					<title>Triggers Fired by xmlload</title>
					<para>The xmlload statement fires the following triggers that can be used to to
						customize how an XML stream is loaded into a component: <itemizedlist
							spacing="compact">
							<listitem>
								<para> Pre Load Occurrence—fired immediately before an occurrence is
									loaded from an XML stream into a component. The new occurrence
									is not yet available and cannot be accessed. </para>
								<para> This trigger tunes the execution of xmlload and xmlsave. You
									can use this trigger to customize the process of loading an XML
									stream into a component. </para>
							</listitem>
							<listitem>
								<para> Post Load Occurrence—fired immediately after an occurrence is
									loaded from an XML stream into a component and after all On
									Error triggers caused by validation errors. The new occurrence
									is available and can be accessed. For example, use this trigger
									if an occurrence can be discarded, or the value for a derived
									field can be calculated. </para>
							</listitem>
						</itemizedlist></para>
					<para> The xmlload statement fires the following triggers that can be used to
						display errors: <itemizedlist spacing="compact">
							<listitem>
								<para> On Error (Entity)—fired immediately after the occurrence is
									loaded if the valerr attribute is present in an occurrence
									element of the XML stream. The new occurrence is available and
									can be accessed. </para>
								<para> $occproperties returns an associated list of occurrence
									properties, including the property with id errormsg which
									contains the the validation error. The validation error can be
									used to display the error. </para>
							</listitem>
							<listitem>
								<para> On Error (Field)—fired if the valerr attribute is present in
									a field element of the XML stream. Is is fired after the
									occurrence is loaded from the XML stream into the component and
									after any occurrence-level errors. The data of the field is
									available and can be accessed. </para>
								<para> $fieldproperties returns an associated list of field instance
									properties, including the property with id errormsg which
									contains the the validation error. The validation error can be
									used to display the error. </para>
							</listitem>
						</itemizedlist></para>
				</sect2>
				<sect2>
					<title>Example: Receiving an XML Stream </title>
					<para> The following code shows an operation that receives an XML stream, and
						loads the data from the XML into the component’s data structure. <programlisting role="uniface"><![CDATA[
operation XMLIN
; This operation receives and
; reconnects an XML stream.
params
xmlstream [DTD:ABCDTD.ABC] MYSTREAM : IN
endparams
clear
xmlload MYSTREAM, "DTD:ABCDTD.ABC"
retrieve/reconnect
...
]]></programlisting>
					</para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.xmlsave">
				<title>xmlsave</title>
				<para> Introduced in: U8 </para>
				<para> Place component data in an XML stream. </para>
				<para> xmlsave{/mod}{/one}{/dtd | /ref}{/incldefmap}{/root} XMLvariable, DTDname{,
					DTDmapping} </para>
				<sect2>
					<title>Switches</title>
					<itemizedlist spacing="compact">
						<listitem>
							<para> /mod—includes only modified occurrences in the XML stream </para>
						</listitem>
						<listitem>
							<para> /one—includes only current outer occurrence (with all inner
								occurrences) in the XML stream </para>
						</listitem>
						<listitem>
							<para> /dtd—includes the DTD in the XML stream </para>
						</listitem>
						<listitem>
							<para> /ref—includes the URI location of the DTD in the XML stream
							</para>
						</listitem>
						<listitem>
							<para> /incldefmap—instructs xmlsave to use the default DTD mapping
								defined in the DTD Editor </para>
						</listitem>
						<listitem>
							<para> /root—excludes the XML version declaration from the saved output
							</para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Parameters</title>
					<itemizedlist spacing="compact">
						<listitem>
							<para> XMLvariable—field, variable, or parameter for the XML stream
							</para>
						</listitem>
						<listitem>
							<para> DTDName—DTD used for the XML stream; can be a literal string,
								variable, or constant using the following format: </para>
							<para> {DTD:}Name.Model </para>
							<para> Where: </para>
							<itemizedlist spacing="compact">
								<listitem>
									<para> DTD:—specifies that the XML stream is defined using a DTD
										(this is to ensure compatibility with future developments in
										the XML standard). </para>
								</listitem>
								<listitem>
									<para> Name—name of the DTD as specified in the application
										model. </para>
								</listitem>
								<listitem>
									<para> Model—name of the DTD"s application model. </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para> DTDMapping—Uniface list mapping XML elements to Uniface fields
								and entities </para>
						</listitem>
					</itemizedlist>
				</sect2>
				<sect2>
					<title>Return Values</title>
					<table>
						<title>Table 1. Values returned in <literal>$status</literal></title>
						<tgroup cols="2">
							<thead>
								<row>
									<entry>Value </entry>
									<entry>Meaning </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>&lt; 0</entry>
									<entry>An error occurred. <literal>$procerror</literal> contains
										the exact error. </entry>
								</row>
								<row>
									<entry>0</entry>
									<entry>XML stream successfully created</entry>
								</row>
								<row>
									<entry>&gt;</entry>
									<entry>XML stream created, but could not find all the field and
										entity names specified in the default and local mappings.
										For each field not found, <literal>$status</literal> is
										incremented by 1. More information is available in the
										message frame if the assignment setting
											<literal>$TEST_MODE_COMPONENTS</literal> is set.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>Table 2. Values commonly returned by $procerror for xmlsave</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Value</entry>
									<entry>Error Constant</entry>
									<entry>Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>-1500</entry>
									<entry> &lt;UXMLERR_DTD_NOTFOUND&gt;</entry>
									<entry> A DTD could not be located.</entry>
								</row>
								<row>
									<entry>-1501 </entry>
									<entry> &lt;UXMLERR_DTD_INVALID&gt;</entry>
									<entry> There is a syntax error in the DTD.</entry>
								</row>
								<row>
									<entry>-1502 </entry>
									<entry> &lt;UXMLERR_GENERATION&gt;</entry>
									<entry> An error occurred during generation of an XML
										stream.</entry>
								</row>
								<row>
									<entry>-1503</entry>
									<entry>&lt;UXMLERR_PARSE&gt; </entry>
									<entry>An error occurred during parsing of an XML stream.
									</entry>
								</row>
								<row>
									<entry>-1504 </entry>
									<entry>&lt;UXMLERR_VALIDATE&gt; </entry>
									<entry>An error occurred during validation of an XML stream.
									</entry>
								</row>
								<row>
									<entry>-1505 </entry>
									<entry>&lt;UXMLERR_TRANSFORM&gt; </entry>
									<entry>An error occurred during transformation of an XML stream.
									</entry>
								</row>
								<row>
									<entry>-1506 </entry>
									<entry>&lt;UXMLERR_FIELD_NOTAVAIL&gt; </entry>
									<entry>A mandatory field is not available in the field list of
										the entity. In the DTD, such fields must be followed by a
										question mark (?). </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</sect2>
				<sect2>
					<title>Use</title>
					<para> Allowed in all Uniface component types. </para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para> The xmlsave statement writes all occurrences on the component (connected
						or disconnected) to an XML stream. The stream is built from the complete
						hitlist, including occurrences currently marked for deletion. Occurrences
						and fields are selected from the data based on the mapping and switches used
						by the xmlsave statement. Note: Only fields of the type database or
						non-database are allowed in XML streams. The value of a boilerplate or
						control field cannot be included into an XML stream when using xmlsave. For
						more information, see Uniface XML Stream Processing and Data Processing
						Information.. </para>
				</sect2>
			</sect1>
			<sect1 xml:id="langref.xmlvalidate">
				<title>xmlvalidate</title>
				<para> Introduced in: U8 </para>
				<para> Validate an XML stream. xmlvalidate{/file} XMLStream{, ValidationData}
					Switches /file—instructs xmlvalidate to treat ValidationData as a system path to
					a DTD file. Parameters XMLStream—field, variable, or parameter containing the
					XML stream. ValidationData—field, variable, or parameter containing the
					validation rules to be applied to XMLStream; can refer to a Repository object,
					to a file, or can contain the validation rules itself. Return Values Table 1.
					Values commonly returned by $procerror following xmlvalidate <table>
						<title>$procerror</title>
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Value</entry>
									<entry>Error constant</entry>
									<entry>Meaning</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>-1</entry>
									<entry> &lt;UGENERR_ERROR&gt;</entry>
									<entry>An error occurred</entry>
								</row>
								<row>
									<entry>-1406</entry>
									<entry> &lt;UPROCERR_MEMORY&gt;</entry>
									<entry>Memory allocation failure </entry>
								</row>
								<row>
									<entry>-1504</entry>
									<entry> &lt;UXMLERR_VALIDATE&gt;</entry>
									<entry>An error occurred during validation of an XML
										stream</entry>
								</row>
							</tbody>
						</tgroup>
					</table> Additional information is provided in $procerrorcontext, such as error
					messages from the XML parser. </para>
				<sect2>
					<title>Use</title>
					<para>Allowed in all Uniface component types.</para>
				</sect2>
				<sect2>
					<title>Description</title>
					<para>xmlvalidate validates an XML stream.</para>
					<para>Validation objects (files, variables and so on) must follow the W3C
						Recommendations for DTDs. Furthermore, DTD objects should not contain the
						following items: <itemizedlist spacing="compact">
							<listitem>
								<para> XML declaration (for example, &lt;?xml version="1.0"?&gt;)
								</para>
							</listitem>
							<listitem>
								<para> Enclosing DOCTYPE declaration (in fact, DTDs that include a
									DOCTYPE declaration do not conform to the XML 1.0
									Recommendation.) </para>
							</listitem>
						</itemizedlist> If ValidationData is omitted, Uniface reads the DTD
						declarations embedded in the XMLStream. If no declarations are embedded in
						XMLStream, the parser reports a validation error. </para>
					<para> If XMLStream contains embedded element and attribute declarations and you
						also specify ValidationData, the XML parser receives multiple declarations
						for items in the stream. The XML parser reports a validation error in this
						situation. </para>
					<para> xmlvalidate applies the following rules to distinguish ValidationData:
							<itemizedlist spacing="compact">
							<listitem>
								<para> If the argument /file is used, ValidationData is treated as a
									system path . </para>
							</listitem>
							<listitem>
								<para> If ValidationData uses DTD syntax, xmlvalidate treats
									ValidationData as a DTD. </para>
							</listitem>
							<listitem>
								<para> Otherwise, ValidationData is treated as the name of a DTD
									stored in the Repository. </para>
							</listitem>
						</itemizedlist>
					</para>
					<para> When ValidationData specifies a DTD stored in the Repository, use the
						following format: {DTD:}Name.Model <itemizedlist spacing="compact">
							<listitem>
								<para> DTD:—specifies that the XML stream is defined using a DTD
									(this is to ensure compatibility with future developments in the
									XML standard). </para>
							</listitem>
							<listitem>
								<para> Name—name of the DTD as specified in the application model.
								</para>
							</listitem>
							<listitem>
								<para> Model—name of the DTD's application model. </para>
							</listitem>
						</itemizedlist>
					</para>
				</sect2>
				<sect2>
					<title>Example: Validate an XML stream </title>
					<para> You can use the Proc statement xmlvalidate to validate an XML stream,
						even if the DTD for the XML stream is not in your Repository. The following
						operation XVALIDATE validates an XML stream using xmlvalidate: 
<programlisting role="uniface"><![CDATA[
operation XVALIDATE
params
numeric I_STATUS : OUT
string I_STATUSCONTEXT : OUT
string I_DTD : IN
string I_XML : IN
endparams
; I_DTD is a file path; use the argument /file
; to indicate this to xmlvalidate.
xmlvalidate/file I_XML, I_DTD
I_STATUS = $procerror
I_STATUSCONTEXT = $procerrorcontext
end ; operation XVALIDATE
]]></programlisting>
					</para>
				</sect2>
			</sect1>
		</chapter>
		<chapter>
			<title>Javascript API</title>
			<sect1>
				<title>Objects</title>
				<sect2>
					<title>uniface</title>
					<para></para>
				</sect2>
				<sect2>
					<title>uniface.DSPInstance</title>
					<para></para>
				</sect2>
				<sect2>
					<title>uniface.Entity</title>
					<para></para>
				</sect2>
				<sect2>
					<title>uniface.Occurences</title>
					<para></para>
				</sect2>
				<sect2>
					<title>uniface.Field</title>
					<para></para>
				</sect2>
			</sect1>
		</chapter>
	</book>

		
	<!-- Stolen directly from the PHP manual file -->
	<book xml:id="faq">
		<title>FAQ: Frequently Asked Questions</title>
		<titleabbrev>FAQ</titleabbrev>
		
	<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="faq.general">
		<title>General Information</title>
		<titleabbrev>General Information</titleabbrev>
		
		<para>
			This section holds the most general questions about PHP:
			what it is and what it does.
		</para>
		
		<qandaset>
			<qandaentry xml:id="faq.general.what">
				<question>
					<para>What is PHP?</para>
				</question>
				<answer>
					<para>
						From the preface of the manual:
					</para>
					<para>
						PHP is an HTML-embedded scripting language. Much of
						its syntax is borrowed from C, Java and Perl with a couple of unique
						PHP-specific features thrown in. The goal of the language is to
						allow web developers to write dynamically generated pages quickly.
					</para>
				</answer>
			</qandaentry>
			
			<qandaentry xml:id="faq.general.acronym">
				<question>
					<para>What does PHP stand for?</para>
				</question>
				<answer>
					<para>
						PHP stands for <emphasis>PHP: Hypertext Preprocessor</emphasis>. 
						This confuses many people because the first word of the acronym is 
						the acronym. This type of acronym is called a recursive acronym. 
						For more information, the curious can visit 
						<link xlink:href="http://foldoc.org/">Free On-Line Dictionary of Computing</link>
						or the
						<link xlink:href="http://en.wikipedia.org/wiki/Recursive_acronym">Wikipedia entry on
							recursive acronyms</link>.
					</para>
				</answer>
			</qandaentry>
		</qandaset>
	</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->	
 <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="faq.mailinglist">
  <title>Mailing lists</title>
  <titleabbrev>Mailing lists</titleabbrev>

   <para>
    This section holds questions about how to get in touch with
    the PHP community. The best way is the mailing lists. 
   </para>

  <qandaset>
   <qandaentry xml:id="faq.mailinglist.isthere">
    <question>
     <para>Are there any PHP mailing lists?</para>
    </question>
    <answer>
     <para>
      Of course! There are many mailing lists for several subjects.
      The most common community mailing lists can be found on our
      <link xlink:href="http://www.php.net/mailing-lists.php">mailing list</link> page.
     </para>
     <para>
      The most general mailing list is <literal>php-general</literal>.
      To subscribe, send a blank email message to
      <link xlink:href="mailto:php-general-subscribe@lists.php.net">php-general-subscribe@lists.php.net</link>.
      To unsubscribe, send a blank email to <link xlink:href="mailto:php-general-unsubscribe@lists.php.net">php-general-unsubscribe@lists.php.net</link>.
     </para>
     <para>
      You can also subscribe and unsubscribe using the web
      interface on our <link xlink:href="http://www.php.net/mailing-lists.php">mailing list</link>
      page, and unsubscribe instructions are included in the footer of
      every mailing list message.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.mailinglist.others">
    <question>
     <para>Are there any other communities?</para>
    </question>
    <answer>
     <para>
      There are countless PHP-centric communities around the world, and we have
      links to some of these resources (and information on how to learn more)
      on our <link xlink:href="http://www.php.net/support.php">Support</link> page.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.mailinglist.myown">
    <question>
     <para>Can I start my own PHP mailing list?</para>
    </question>
    <answer>
     <para>
      Absolutely! In fact, we not only freely allow it, we encourage it!
      Helping others by sharing your knowledge and experience with PHP
      helps to foster the growth and development of the global PHP
      community and the language itself.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.mailinglist.subscribing">
    <question>
     <para>
      Help! I can't seem to subscribe to/unsubscribe from
      one of the mailing lists!
     </para>
    </question>
    <answer>
     <para>
      If you have problems subscribing to or unsubscribing from a mailing
      list, it may be because the mailing list software can't figure out
      the correct mailing address to use. If your email address is
      <literal>joeblow@example.com</literal>, and you are trying to
      subscribe to php-general, you can send your subscription request to
      <literal>php-general-subscribe-joeblow=example.com@lists.php.net</literal>,
      or your unsubscription request to
      <literal>php-general-unsubscribe-joeblow=example.com@lists.php.net</literal>.
      Use similar addresses for the other mailing lists.
     </para>
     <para>
      The most common reason folks have a hard time unsubscribing from our
      mailing lists is due to the use of mail forwarders.  For example,
      if your email address is danbrown@example.com, but you subscribed to
      the mailing list with the forwarder php-lists@example.com and forward
      that to danbrown@example.com, attempting to unsubscribe
      danbrown@example.com will not work, as that address is not even known
      to our systems.  Instead, you will need to unsubscribe the address to
      which the mail is being sent - in this example, php-lists@example.com.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.mailinglist.archive">
    <question>
     <para>Is there an archive of the mailing lists anywhere?</para>
    </question>
    <answer>
     <para>
       Yes, you will find links to some of the archive sites on the 
       <link xlink:href="http://www.php.net/mailing-lists.php">mailing list</link> page.
       You will also find dozens of sites that archive and/or syndicate
       our mailing list content by using your favorite Internet search
       engine and searching for "php mailing list archives".
     </para>
     <para>
       All mailing list articles are also archived as news
       messages. You can access the news server at <link xlink:href="news://news.php.net/">news://news.php.net/</link>
       with a news client. There is also an experimental web
       interface for the news server at <link xlink:href="http://news.php.net/">http://news.php.net/</link>
     </para>
    </answer>
   </qandaentry>
  
   <qandaentry xml:id="faq.mailinglist.question">
    <question>
     <para>What can I ask the mailing list?</para>
    </question>
    <answer>
     <para>
      Since PHP is growing more and more popular by the day, the traffic 
      on the php-general mailing list can be very heavy, ranging from
      75 to 200 or more posts per day. Because of this, it is in everyone's
      interest that you use the list as a last resort, when you have
      exhausted all other avenues.
     </para>
     <para>
      Before you post to the list please have a look in this FAQ and the 
      manual to see if you can find the help there. If there is nothing 
      to be found there try out the mailing list archives (see above). 
      If you're having problem with installing or configuring PHP, please
      read through all included documentation and README's. If you still
      can't find any information that helps you out, you're more than 
      welcome to use the appropriate mailing list.
     </para>
     <para>
      To ensure that you receive the best responses (and to reduce the
      likelihood of frustrating your fellow developers), please be sure to
      post your question to the appropriate list.  For example, if you are
      having difficulties installing PHP, you should send your question to
      the <literal>php-install</literal> mailing list.  A caveat: some lists
      have similar names and completely different uses; a question regarding
      PHP scripts on Windows should be directed to the Windows PHP users
      list, <emphasis>not</emphasis> to the Windows Internals list.
     </para>
     <para>
      Before asking questions, you may want to read the paper on 
      <link xlink:href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart
      Way</link> as this is a good idea for everyone.
     </para>
    </answer>
   </qandaentry>
   
   <qandaentry xml:id="faq.mailinglist.guideline">
    <question>
     <para>What information should I include when posting to the mailing list?</para>
    </question>
    <answer>
     <para>
      Posts like "I can't get PHP up and running! Help me! What is
      wrong?" are of absolutely no use to anyone. If you're having problems
      getting PHP up and running you must include the operating system being
      used, the version of PHP you're trying to use, how you got it
      (pre-compiled, SVN, RPM, and so on), what you have done so far,
      and the exact error message or present result.
     </para>
     <para>
      This goes for any other problem as well: you must include an explanation
      of what you have done, what you're trying to do, and any error messages
      encountered in the process. If you're having problems with your source
      code, you should include the part of the code that isn't working,
      indicating which line is the problem by an appropriately-placed code
      comment. Do not include more code than necessary though!  It makes the
      post difficult to read, causing many to ignore your request. If you're
      unsure about how much information should be included, post what you
      believe is immediately relevant to your present issue, and be prepared
      to provide more information upon request.
     </para>
     <para>
      Another important thing to remember is to summarize your problem
      on the subject line. A subject like "HELP MEEEE!!!" or "What is the
      problem here?" will be ignored by the majority of the readers.
     </para>
     <para>
      And lastly, you're encouraged to read the paper on
      <link xlink:href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The 
      Smart Way</link> as this will be a great help for everyone, 
      especially yourself.
     </para>
    </answer>
   </qandaentry>
  </qandaset>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

  
<!-- $Revision: 322138 $ -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="faq.obtaining">
 <title>Obtaining PHP</title>
  <titleabbrev>Obtaining PHP</titleabbrev>

   <para>
    This section has details about PHP download locations, and
    OS issues.
   </para>

  <qandaset>
   <qandaentry xml:id="faq.obtaining.where">
    <question>
     <para>Where can I obtain PHP?</para>
    </question>
    <answer>
     <para>
      You can download PHP from any of the members of the
      PHP network of sites. These can be found at 
      <link xlink:href="http://www.php.net/">http://www.php.net/</link>.
      You can also use anonymous SVN to get the absolute latest
      version of the source. For more information, go to 
      <link xlink:href="http://php.net/svn.php">http://php.net/svn.php</link>.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.obtaining.precompiled">
    <question>
     <para>Are pre-compiled binary versions available?</para>
    </question>
    <answer>
     <para>
      We only distribute precompiled binaries for Windows systems,
      as we are not able to compile PHP for every major Linux/Unix
      platform with every extension combination. Also note, that
      many Linux distributions come with PHP built in these days.
      Windows binaries can be downloaded from our <link xlink:href="http://www.php.net/downloads.php">Downloads</link> page, for Linux
      binaries, please visit your distribution's website.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.obtaining.optional">
    <question>
     <para>
      Where can I get libraries needed to compile some of
      the optional PHP extensions?
     </para>
    </question>
    <answer>
     <para>
      <note>
       <simpara>
        Those marked with * are not thread-safe libraries, and
        should not be used with PHP as a server module in the multi-threaded
        Windows web servers (IIS, Netscape). This does not matter in Unix
        environments, yet.
       </simpara>
      </note>
     </para>
     <para>
      <itemizedlist>
       <listitem>
        <simpara>
         <link xlink:href="ftp://ftp.openldap.org/pub/OpenLDAP/openldap-stable/">LDAP (Unix)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.mozilla.org/directory/">LDAP (Unix/Win)</link> : 
         Mozilla Directory (LDAP) SDK
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.bind9.net/download-openldap/">free LDAP server</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.sleepycat.com/">Berkeley DB2 (Unix/Win)</link> :
         http://www.sleepycat.com/.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.net-snmp.org/">SNMP* (Unix): </link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.libgd.org/">GD* (Unix/Win)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.hughes.com.au/">mSQL* (Unix)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.postgresql.org/">PostgreSQL (Unix)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="ftp://ftp.cac.washington.edu/imap/">IMAP* (Win/Unix)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.sybase.com/">Sybase-CT* (Linux, libc5)</link> : 
         Available locally.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.freetype.org/">FreeType (libttf):</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.zlib.net/">ZLib (Unix/Win32)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.jclark.com/xml/expat.html">expat XML parser (Unix/Win32)</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://www.pdflib.com/products/pdflib-family/">PDFLib</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://mcrypt.sourceforge.net/">mcrypt</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://mhash.sourceforge.net/">mhash</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="ftp://sunsite.unc.edu/pub/Linux/libs/graphics/">t1lib</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://dmalloc.com/">dmalloc</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://aspell.net/">aspell</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         <link xlink:href="http://cnswww.cns.cwru.edu/~chet/readline/rltop.html">readline</link>.
        </simpara>
       </listitem>
      </itemizedlist>
     </para>
    </answer>
   </qandaentry>
  
   <qandaentry xml:id="faq.obtaining.how">
    <question>
     <para>How do I get these libraries to work?</para>
    </question>
    <answer>
     <para>
      You will need to follow instructions provided with the library. Some of
      these libraries are detected automatically when you run the 'configure'
      script of PHP (such as the GD library), and others you will have to
      enable using '<literal>--with-EXTENSION</literal>' options to 
      '<literal>configure</literal>'. Run 
      '<literal>configure --help</literal>' for a listing of these.     
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.obtaining.compilent">
    <question>
     <para>
      I got the latest version of the PHP source code from the SVN
      repository on my Windows machine, what do I need to compile it?
     </para>
    </question>
    <answer>
     <para>
      See the manual section about
      building PHP from
      source on Windows.
    </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.obtaining.browscap">
    <question>
     <para>Where do I find the Browser Capabilities File?</para>
    </question>
    <answer>
     <para>
      You can find a <filename>browscap.ini</filename> file at 
      <link xlink:href="http://browsers.garykeith.com/downloads.asp">http://browsers.garykeith.com/downloads.asp</link>.
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.obtaining.threadsafety">
    <question>
     <para>What does thread safety mean when downloading PHP?</para>
    </question>
    <answer>
     <para>
      Thread Safety means that binary can work in a multithreaded webserver 
      context, such as Apache 2 on Windows. Thread Safety works by creating 
      a local storage copy in each thread, so that the data won't collide 
      with another thread.
     </para>
     <para>
      So what do I choose? If you choose to run PHP as a CGI binary, then 
      you won't need thread safety, because the binary is invoked at each 
      request. For multithreaded webservers, such as IIS5 and IIS6, you should 
      use the threaded version of PHP.
     </para>
    </answer>
   </qandaentry>
  </qandaset>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
	</book>	
</set>
